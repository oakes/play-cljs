<html><head><link href="paren-soup-light.css" rel="stylesheet" type="text/css" /></head><body><a name="Screen"></a><h1>Screen</h1><p>A screen object provides the basic lifecycle for a game. Simple games may only need to have one screen. They are a useful way to isolate different aspects of your game. For example, you could make one screen display the title and menu, and another screen contain the game itself.</p><p>You can create a screen by using <code>reify</code> like this:</p><pre><code>&#40;def main-screen
  &#40;reify p/Screen
    &#40;on-show &#91;this&#93;&#41;
    &#40;on-hide &#91;this&#93;&#41;
    &#40;on-render &#91;this&#93;&#41;
    &#40;on-event &#91;this event&#93;&#41;&#41;&#41;
</code></pre><a name="Game"></a><h1>Game</h1><p>A game object contains the internal renderer object and various bits of state that are important to the overall execution of the game. Every play-cljs game should create just one such object by calling <a href='#create-game'>create-game</a>.</p><a name="create-game"></a><h2>(create-game width height)</h2><p>Returns a game object.</p><a name="get-canvas"></a><h2>(get-canvas game)</h2><p>Returns the internal canvas object.</p><a name="get-delta-time"></a><h2>(get-delta-time game)</h2><p>Returns the time since the last frame was rendered, in milliseconds.</p><a name="get-height"></a><h2>(get-height game)</h2><p>Returns the virtual height of the game.</p><a name="get-pressed-keys"></a><h2>(get-pressed-keys game)</h2><p>Returns a set containing the key codes for the keys currently being pressed.</p><a name="get-renderer"></a><h2>(get-renderer game)</h2><p>Returns the internal renderer object.</p><a name="get-screen"></a><h2>(get-screen game)</h2><p>Returns the <a href='#Screen'>Screen</a> object currently being displayed.</p><a name="get-total-time"></a><h2>(get-total-time game)</h2><p>Returns the total time transpired since the game started, in milliseconds.</p><a name="get-width"></a><h2>(get-width game)</h2><p>Returns the virtual width of the game.</p><a name="load-image"></a><h2>(load-image game path)</h2><p>Returns an <a href='#Image'>Image</a> object downloaded from the provided path.</p><a name="load-tiled-map"></a><h2>(load-tiled-map game map-name)</h2><p>Returns a <a href='#TiledMap'>TiledMap</a> object. A tiled map with the provided name must already be loaded (see the TiledMap docs for details).</p><a name="pre-render"></a><h2>(pre-render game width height content)</h2><p>Renders the provided data structure off-screen and returns an <a href='#Image'>Image</a> object.</p><a name="render"></a><h2>(render game content)</h2><p>Renders the provided data structure.</p><a name="set-screen"></a><h2>(set-screen game screen)</h2><p>Sets the <a href='#Screen'>Screen</a> object to be displayed.</p><a name="set-size"></a><h2>(set-size game width height)</h2><p>Sets the virtual width and height of the game.</p><a name="start"></a><h2>(start game events)</h2><p>Creates the canvas element and begins listening to the supplied events.</p><a name="stop"></a><h2>(stop game)</h2><p>Stops displaying any screen or listening to any events.</p><a name="Elements"></a><h1>Elements</h1><a name=":div"></a><h2>:div</h2><div class="paren-soup"><div class="content" contenteditable="true">[:div {:x 10 :y 10}
 [:rect {:x 0 :y 0 :width 10 :height 10}]
 [:ellipse {:x 0 :y 10 :width 10 :height 10}]]</div></div><a name=":text"></a><h2>:text</h2><div class="paren-soup"><div class="content" contenteditable="true">[:text {:value "Hello, world!" :x 0 :y 50 :size 16 :font "Georgia" :style :italic}]</div></div><a name=":arc"></a><h2>:arc</h2><div class="paren-soup"><div class="content" contenteditable="true">[:arc {:x 0 :y 0 :width 50 :height 50 :start 0 :stop 3.14}]</div></div><a name=":ellipse"></a><h2>:ellipse</h2><div class="paren-soup"><div class="content" contenteditable="true">[:ellipse {:x 0 :y 0 :width 50 :height 50}]</div></div><a name=":line"></a><h2>:line</h2><div class="paren-soup"><div class="content" contenteditable="true">[:line {:x1 0 :y1 0 :x2 10 :y2 10}]</div></div><a name=":point"></a><h2>:point</h2><div class="paren-soup"><div class="content" contenteditable="true">[[:point {:x 5 :y 5}]
 [:point {:x 10 :y 5}]]</div></div><a name=":quad"></a><h2>:quad</h2><div class="paren-soup"><div class="content" contenteditable="true">[:quad {:x1 -10 :y1 -15 :x2 10 :y2 -15 :x3 10 :y3 15 :x4 -10 :y4 15}]</div></div><a name=":rect"></a><h2>:rect</h2><div class="paren-soup"><div class="content" contenteditable="true">[:rect {:x -10 :y -15 :width 20 :height 30}]</div></div><a name=":triangle"></a><h2>:triangle</h2><div class="paren-soup"><div class="content" contenteditable="true">[:triangle {:x1 -10 :y1 -15 :x2 10 :y2 -15 :x3 0 :y3 15}]</div></div><a name=":image"></a><h2>:image</h2><div class="paren-soup"><div class="content" contenteditable="true">[:image {:value (:logo @state) :x 0 :y 0 :width 30 :height 30}]</div></div><a name=":fill"></a><h2>:fill</h2><div class="paren-soup"><div class="content" contenteditable="true">[:fill {:color "lightblue"}
 [:rect {:x 0 :y 0 :width 10 :height 10}]]</div></div><a name=":stroke"></a><h2>:stroke</h2><div class="paren-soup"><div class="content" contenteditable="true">[:stroke {:color "lightblue"}
 [:rect {:x 0 :y 0 :width 10 :height 10}]]</div></div><a name=":bezier"></a><h2>:bezier</h2><div class="paren-soup"><div class="content" contenteditable="true">[:stroke {:colors [0 0 0]}
 [:bezier {:x1 85 :y1 20 :x2 10 :y2 10 :x3 90 :y3 90 :x4 15 :y4 80}]]</div></div><a name=":curve"></a><h2>:curve</h2><div class="paren-soup"><div class="content" contenteditable="true">[:stroke {:colors [255 102 0]}
 [:curve {:x1 5 :y1 26 :x2 5 :y2 26 :x3 73 :y3 24 :x4 73 :y4 61}]]</div></div><a name=":rgb"></a><h2>:rgb</h2><div class="paren-soup"><div class="content" contenteditable="true">[:rgb {:max-r 100 :max-g 100 :max-b 100}
 [:fill {:colors [0 0 0]}
  [:rect {:x 0 :y 0 :width 10 :height 10}]]]</div></div><a name=":hsb"></a><h2>:hsb</h2><div class="paren-soup"><div class="content" contenteditable="true">[:hsb {:max-h 100 :max-s 100 :max-b 100}
 [:fill {:colors [0 0 0]}
  [:rect {:x 0 :y 0 :width 10 :height 10}]]]</div></div><a name=":tiled-map"></a><h2>:tiled-map</h2><div class="paren-soup"><div class="content" contenteditable="true">[:tiled-map {:value (:map @state)}]</div></div><a name="Image"></a><h1>Image</h1><p>Image objects are returned by <a href='#load-image'>load-image</a> and <a href='#pre-render'>pre-render</a>. They can be placed in an :image element.</p><pre><code>&#40;def state &#40;atom {}&#41;&#41;

&#40;def main-screen
  &#40;reify p/Screen
    &#40;on-show &#91;this&#93;
      &#40;swap! state assoc :player-image &#40;p/load-image &quot;player.jpg&quot;&#41;&#41;&#41;
    &#40;on-hide &#91;this&#93;&#41;
    &#40;on-render &#91;this&#93;
      &#40;p/render game &#91;:image {:value &#40;:player-image @state&#41;}&#93;&#41;&#41;
    &#40;on-event &#91;this event&#93;&#41;&#41;&#41;
</code></pre><a name="loadPixels"></a><h2>(.loadPixels image)</h2><p>Loads the pixels data for this image into the pixels attribute.</p><a name="updatePixels"></a><h2>(.updatePixels image x y w h)</h2><p>Updates the backing canvas for this image with the contents of the pixels array.</p><h3>Parameters</h3><ul><li><code>x</code>  x-offset of the target update area for the underlying canvas</li><li><code>y</code>  y-offset of the target update area for the underlying canvas</li><li><code>w</code>  width of the target update area for the underlying canvas</li><li><code>h</code>  height of the target update area for the underlying canvas</li></ul><a name="get"></a><h2>(.get image)</h2><h2>(.get image x y)</h2><h2>(.get image x y w h)</h2><p>Get a region of pixels from an image.</p><h3>Parameters</h3><ul><li><code>x</code>  x-coordinate of the pixel</li><li><code>y</code>  y-coordinate of the pixel</li><li><code>w</code>  width</li><li><code>h</code>  height</li></ul><h3>Returns</h3><p>If no params are passed, those whole Image object is returned. If x and y are the only params passed, the color of the pixel is returned in array format: [R, G, B, A]. If all params are passed, a rectangle region is extracted and an Image object is returned. If the region is outside the bounds of the image, nil is returned.</p><a name="set"></a><h2>(.set image x y a)</h2><p>Set the color of a single pixel or write an image into this Image object.</p><p>Note that for a large number of pixels this will be slower than directly manipulating the pixels array and then calling <a href='#updatePixels'>updatePixels</a>.</p><h3>Parameters</h3><ul><li><code>x</code>  x-coordinate of the pixel</li><li><code>y</code>  y-coordinate of the pixel</li><li><code>a</code>  grayscale value | pixel array | a <a href='#Color'>Color</a> object | <a href='#Image'>Image</a> object to copy</li></ul><a name="resize"></a><h2>(.resize image width height)</h2><p>Resize the image to a new width and height. To make the image scale proportionally, use 0 as the value for the wide or high parameter. For instance, to make the width of an image 150 pixels, and change the height using the same proportion, use <code>&#40;.resize image 150 0&#41;</code>.</p><h3>Parameters</h3><ul><li><code>width</code>  the resized image width</li><li><code>height</code>  the resized image height</li></ul><a name="copy"></a><h2>(.copy image src-image sx sy sw sh dx dy dw dh)</h2><p>Loads the pixels data for this image into the pixels attribute.</p><h3>Parameters</h3><ul><li><code>src-image</code>  source image object</li><li><code>sx</code>  X coordinate of the source's upper left corner</li><li><code>sy</code>  Y coordinate of the source's upper left corner</li><li><code>sw</code>  source image width</li><li><code>sh</code>  source image height</li><li><code>dx</code>  X coordinate of the destination's upper left corner</li><li><code>dy</code>  Y coordinate of the destination's upper left corner</li><li><code>dw</code>  destination image width</li><li><code>dh</code>  destination image height</li></ul><a name="mask"></a><h2>(.mask image src-image)</h2><p>Masks part of an image from displaying by loading another image and using its blue channel as an alpha channel for this image.</p><h3>Parameters</h3><p><code>src-image</code>  source image object</p><a name="filter"></a><h2>(.filter image operation)</h2><p>Applies an image filter to an Image object.</p><h3>Parameters</h3><p><code>operation</code>  one of "threshold", "gray", "invert", "posterize" and "opaque"</p><a name="blend"></a><h2>(.blend image src-image sx sy sw sh dx dy dw dh blend-mode)</h2><p>Copies a region of pixels from one image to another, using a specified blend mode to do the operation.</p><h3>Parameters</h3><ul><li><code>src-image</code>  source image object</li><li><code>sx</code>  X coordinate of the source's upper left corner</li><li><code>sy</code>  Y coordinate of the source's upper left corner</li><li><code>sw</code>  source image width</li><li><code>sh</code>  source image height</li><li><code>dx</code>  X coordinate of the destination's upper left corner</li><li><code>dy</code>  Y coordinate of the destination's upper left corner</li><li><code>dw</code>  destination image width</li><li><code>dh</code>  destination image height</li><li><code>blend-mode</code>  the blend mode</li></ul><p>Available blend modes are: normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity</p><a name="save"></a><h2>(.save image filename extension)</h2><p>Saves the image to a file and force the browser to download it. Accepts two strings for filename and file extension Supports png (default) and jpg.</p><h3>Parameters</h3><ul><li><code>filename</code>  give your file a name</li><li><code>extension</code>  "png" or "jpg"</li></ul><a name="TiledMap"></a><h1>TiledMap</h1><p>TiledMap objects are returned by <a href='#load-tiled-map'>load-tiled-map</a>. They can be placed in a :tiled-map element.</p><p>The map must be exported from an editor like <a href='http://www.mapeditor.org/'>Tiled</a> in JavaScript format. The resulting <code>.js</code> file must be included in the game's HTML before <code>main.js</code>. Lastly, the name provided to <code>load-tiled-map</code> should coorespond to the name saved in that JS file.</p><pre><code>&#40;def state &#40;atom {}&#41;&#41;

&#40;def main-screen
  &#40;reify p/Screen
    &#40;on-show &#91;this&#93;
      &#40;swap! state assoc :map &#40;p/load-tiled-map &quot;dungeon&quot;&#41;&#41;&#41;
    &#40;on-hide &#91;this&#93;&#41;
    &#40;on-render &#91;this&#93;
      &#40;p/render game &#91;:tiled-map {:value &#40;:map @state&#41;}&#93;&#41;&#41;
    &#40;on-event &#91;this event&#93;&#41;&#41;&#41;
</code></pre><a name="getName"></a><h2>(.getName tiled-map)</h2><h3>Returns</h3><p>The name of the map</p><a name="getVersion"></a><h2>(.getVersion tiled-map)</h2><h3>Returns</h3><p>The version of the map</p><a name="getOrientation"></a><h2>(.getOrientation tiled-map)</h2><h3>Returns</h3><p>The orientation of the map</p><a name="getBackgroundColor"></a><h2>(.getBackgroundColor tiled-map)</h2><h3>Returns</h3><p>The background <a href='#Color'>Color</a> of the map</p><a name="getMapSize"></a><h2>(.getMapSize tiled-map)</h2><h3>Returns</h3><p>The width and height of the map (in number of tiles) as a <a href='#Vector'>Vector</a></p><a name="getTileSize"></a><h2>(.getTileSize tiled-map)</h2><h3>Returns</h3><p>The width and height of the tiles (in pixels) as a <a href='#Vector'>Vector</a></p><a name="getHexSideLength"></a><h2>(.getHexSideLength tiled-map)</h2><h3>Returns</h3><p>The side length (only for hexagonal maps)</p><a name="getCamCorner"></a><h2>(.getCamCorner tiled-map)</h2><h3>Returns</h3><p>The left and top corner coordinates as a <a href='#Vector'>Vector</a></p><a name="getCamCenter"></a><h2>(.getCamCenter tiled-map)</h2><h3>Returns</h3><p>The center coordinates as a <a href='#Vector'>Vector</a></p><a name="getPosition"></a><h2>(.getPosition tiled-map)</h2><h3>Returns</h3><p>Depending on dramMode, returns the camera corner or center coordinates. Depending on positionMode, returns the Map or Canvas coordinates. Essentially, you get the coordinates of last draw as a <a href='#Vector'>Vector</a>.</p><a name="getCamSize"></a><h2>(.getCamSize tiled-map)</h2><h3>Returns</h3><p>The camera's width and height as a <a href='#Vector'>Vector</a></p><a name="setCamSize"></a><h2>(.setCamSize tiled-map width height)</h2><p>Only useful for some pre-draw calculations, since Cam size is always the last Canvas used to draw.</p><h3>Parameters</h3><ul><li><code>width</code>  cam width</li><li><code>height</code>  cam height</li></ul><a name="getDrawMargin"></a><h2>(.getDrawMargin tiled-map)</h2><h3>Returns</h3><p>Number of tiles to be draw in excess around Canvas. Default: 2</p><a name="setDrawMargin"></a><h2>(.setDrawMargin tiled-map margin)</h2><h3>Parameters</h3><ul><li><code>margin</code>  Number of tiles to be draw in excess around Canvas. Default: 2</li></ul><a name="getDrawMode"></a><h2>(.getDrawMode tiled-map)</h2><h3>Returns</h3><p>CORNER or CENTER. Default: CORNER</p><a name="setDrawMode"></a><h2>(.setDrawMode tiled-map mode)</h2><p>Defines the meaning of draw and drawLayer coordinates. Traditionally, they are camLeft and camTop - the left/top coordinates of the camera, but with setDrawMode(CENTER), they become the coordinates of the camera center.</p><h3>Parameters</h3><ul><li><code>mode</code>  CORNER or CENTER</li></ul><a name="getPositionMode"></a><h2>(.getPositionMode tiled-map)</h2><h3>Returns</h3><p>"CANVAS" or "MAP". Default: "CANVAS"</p><a name="setPositionMode"></a><h2>(.setPositionMode tiled-map mode)</h2><p>Defines the meaning of draw and drawLayer coordinates. Traditionally, the coordinates are read as pixel position. but with setPositionMode("MAP"), they become Tiles Coordinates.</p><h3>Parameters</h3><ul><li><code>mode</code>  "CANVAS" or "MAP"</li></ul><a name="getType"></a><h2>(.getType tiled-map layer)</h2><h3>Parameters</h3><ul><li><code>layer</code>  layer index</li></ul><h3>Returns</h3><p>Layer type ("tilelayer", "imagelayer" or "objectgroup")</p><a name="getVisible"></a><h2>(.getVisible tiled-map layer)</h2><h3>Parameters</h3><ul><li><code>layer</code>  layer index</li></ul><h3>Returns</h3><p>Layer visibility.</p><a name="setVisible"></a><h2>(.setVisible tiled-map layer visible)</h2><h3>Parameters</h3><ul><li><code>layer</code>  layer index</li><li><code>visible</code>  true or false</li></ul><a name="getImage"></a><h2>(.getImage tiled-map layer)</h2><h3>Parameters</h3><ul><li><code>layer</code>  layer index</li></ul><h3>Returns</h3><p><a href='#Image'>Image</a> of an Image Layer.</p><a name="getObjects"></a><h2>(.getObjects tiled-map layer)</h2><h3>Parameters</h3><ul><li><code>layer</code>  layer index</li></ul><h3>Returns</h3><p>Array of Objects on a Object Layer.</p><a name="getObjectsColor"></a><h2>(.getObjectsColor tiled-map layer)</h2><h3>Parameters</h3><ul><li><code>layer</code>  layer index</li></ul><h3>Returns</h3><p><a href='#Color'>Color</a> of an Object Layer. Default: Black.</p><a name="getData"></a><h2>(.getData tiled-map layer)</h2><h3>Parameters</h3><ul><li><code>layer</code>  layer index</li></ul><h3>Returns</h3><p>Data of a Tile Layer.</p><a name="getCustomProperties"></a><h2>(.getCustomProperties tiled-map layer)</h2><h3>Parameters</h3><ul><li><code>layer</code>  layer index</li></ul><h3>Returns</h3><p>Custom Properties of a Layer.</p><a name="getOpacity"></a><h2>(.getOpacity tiled-map layer)</h2><h3>Parameters</h3><ul><li><code>layer</code>  layer index</li></ul><h3>Returns</h3><p>Opacity of a Layer (between 0 and 1).</p><a name="setOpacity"></a><h2>(.setOpacity tiled-map layer opacity)</h2><h3>Parameters</h3><ul><li><code>layer</code>  layer index</li><li><code>opacity</code>  Opacity of a Layer (between 0 and 1).</li></ul><a name="getTileIndex"></a><h2>(.getTileIndex tiled-map layer x y)</h2><p>Returns the tile index. Remember that:</p><ul><li>x and y are Integers.</li><li>0 is an empty tile.</li><li>The stored tile index is the index indicated by Tiled +1.</li></ul><h3>Parameters</h3><ul><li><code>layer</code>  layer index</li><li><code>x</code>  horizontal coordinate</li><li><code>y</code>  vertical coordinate</li></ul><h3>Returns</h3><p>Tile index.</p><a name="setTileIndex"></a><h2>(.setTileIndex tiled-map layer x y t)</h2><p>Changes a tile index. Remember that:</p><ul><li>x and y are Integers.</li><li>0 is an empty tile.</li><li>The stored tile index is the index indicated by Tiled +1.</li></ul><h3>Parameters</h3><ul><li><code>layer</code>  layer index</li><li><code>x</code>  horizontal coordinate</li><li><code>y</code>  vertical coordinate</li><li><code>t</code> tile index</li></ul><a name="canvasToMap"></a><h2>(.canvasToMap tiled-map x y)</h2><h3>Parameters</h3><ul><li><code>x</code>  canvas horizontal coordinate</li><li><code>y</code>  canvas vertical coordinate</li></ul><h3>Returns</h3><p>Map coordinates as a <a href='#Vector'>Vector</a>.</p><a name="mapToCanvas"></a><h2>(.mapToCanvas tiled-map x y)</h2><h3>Parameters</h3><ul><li><code>x</code>  map horizontal coordinate</li><li><code>y</code>  map vertical coordinate</li></ul><h3>Returns</h3><p>Canvas coordinates as a <a href='#Vector'>Vector</a>.</p><a name="camToCanvas"></a><h2>(.camToCanvas tiled-map x y)</h2><h3>Parameters</h3><ul><li><code>x</code>  cam horizontal coordinate</li><li><code>y</code>  cam vertical coordinate</li></ul><h3>Returns</h3><p>Canvas coordinates as a <a href='#Vector'>Vector</a>.</p><a name="canvasToCam"></a><h2>(.canvasToCam tiled-map x y)</h2><h3>Parameters</h3><ul><li><code>x</code>  canvas horizontal coordinate</li><li><code>y</code>  canvas vertical coordinate</li></ul><h3>Returns</h3><p>Cam coordinates as a <a href='#Vector'>Vector</a>.</p><a name="camToMap"></a><h2>(.camToMap tiled-map x y)</h2><h3>Parameters</h3><ul><li><code>x</code>  cam horizontal coordinate</li><li><code>y</code>  cam vertical coordinate</li></ul><h3>Returns</h3><p>Map coordinates as a <a href='#Vector'>Vector</a>.</p><a name="mapToCam"></a><h2>(.mapToCam tiled-map x y)</h2><h3>Parameters</h3><ul><li><code>x</code>  map horizontal coordinate</li><li><code>y</code>  map vertical coordinate</li></ul><h3>Returns</h3><p>Cam coordinates as a <a href='#Vector'>Vector</a>.</p><a name="Vector"></a><h1>Vector</h1><p>Vector objects are used to hold (<code>x</code>, <code>y</code>) positions. They are returned by some of the JavaScript functions. For your own code, use ClojureScript's built-in vectors instead. See <a href='http://p5js.org/reference/#/p5.Vector'>the p5.js docs</a> for more.</p><a name="Color"></a><h1>Color</h1><p>Color objects represent a single given color. See <a href='http://p5js.org/reference/#/p5/color'>the p5.js docs</a> for more.</p><script src="paren-soup.js" type="text/javascript"></script><script type="text/javascript">paren_soup.core.init_all();</script></body></html>