<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="../../style.css">
        <link rel="stylesheet" type="text/css" href="../../paren-soup-light.css">
    </head>
    <body>
        <span id="app"><div data-reactroot="" data-reactid="1" data-react-checksum="-793117945"><div style="left:0;" class="vars" data-reactid="2"><!-- react-empty: 3 --><div class="var-info" data-reactid="4"><div data-reactid="5"><h2 data-reactid="6">(set-screen game screen)</h2></div><div class="section" data-reactid="7"><h3 data-reactid="8"><!-- react-text: 9 -->Part of the <!-- /react-text --><a href="../../cljs/play-cljs.core/Game.html" data-reactid="10">Game</a><!-- react-text: 11 --> protocol<!-- /react-text --></h3></div><div class="section doc" data-reactid="12">Sets the `Screen` object to be displayed.</div></div><div class="footer" data-reactid="13"><!-- react-text: 14 -->Generated by <!-- /react-text --><a href="https://github.com/oakes/Dynadoc" target="_blank" data-reactid="15">Dynadoc</a></div></div></div></span>
        <script type="text/edn" id="initial-state">{:ns-meta nil, :var-sym set-screen, :type :cljs, :nses [{:var-syms [cljs cljs-version main-files assert-cljs-edn!], :type :clj, :sym adzerk.boot-cljs} {:var-syms [compiled analyzed], :type :clj, :sym adzerk.boot-cljs.js-deps} {:var-syms [main non-standard-defaults compiler-options modules set-option source-map], :type :clj, :sym adzerk.boot-cljs.middleware} {:var-syms [last-cause find-original-path path->js path get-name merge-cause-ex-data path->ns deserialize-object last-cause-message find-relative-path serialize-object], :type :clj, :sym adzerk.boot-cljs.util} {:var-syms [reload], :type :clj, :sym adzerk.boot-reload} {:var-syms [js-reserved path->ns ns->file], :type :clj, :sym adzerk.boot-reload.util} {:var-syms [deps load-deps], :type :clj, :sym boot-tools-deps.core} {:var-syms [clifn defclifn], :type :clj, :sym boot.cli} {:var-syms [tmppath tmptime output-dirs replace-task! sync! reset-fileset fileset-changed post-env! fileset-namespaces get-env with-pre-wrap not-by-path *warnings* deftask tmp-dir patch! user-dirs tmpget cleanup rm input-files fileset-reduce not-by-meta output-files bootignore add-cached-source with-post-wrap merge-env! tmpdir mv by-meta init! output-fileset get-checkouts gpg-decrypt by-name not-by-ext add-cached-asset tmp-get input-fileset new-fileset commit! not-by-re configure-repositories! by-ext mv-asset by-re *app-version* boot user-files set-env! task-options! file-filter temp-dir! mv-resource add-resource load-data-readers! tmp-path template json-parse reset-build! pre-env! fileset-diff new-build-at rebuild! ls *boot-script* watch-dirs add-source last-file-change fileset-removed cp *boot-opts* add-asset launch-nrepl yaml-generate yaml-parse empty-dir! add-cached-resource get-sys-env not-by-name set-sys-env! mv-source cache-dir! json-generate git-files touch fileset-added disable-task! tmp-dir! tmpfile with-pass-thru input-dirs tmp-file by-path tmp-time *boot-version* add-meta], :type :clj, :sym boot.core} {:var-syms [windows? sync! delete-empty-subdirs! guard hard-link delete-file path srcdir->outdir parent? tmpdir clean! copy-with-lastmod patch parent parent-seq copy-files *hard-link* name *include* move *exclude* *ignore* *sync-delete* file-seq relative-to lockfile file-seq-nofollow file? walk-file-tree patch-cp? empty-dir! watcher! split-path print-ex exists? sym-link dir? delete-all match-filter? tmpfile time-diff tmpfile-permissions copy-atomically keep-filters? tree-for], :type :clj, :sym boot.file} {:var-syms [windows? tree-diff map->FileSystemTree read-only skip-subtree link! merge-trees mkignores patch! mkvisitor ->FileSystemTree IToPath touch! path->segs ->path tmp-attrs open-opts continue mkparents! link-opts copy! tree-patch copy-opts write! mkjarfs delete! mktree], :type :clj, :sym boot.filesystem} {:var-syms [patch patch-result], :type :clj, :sym boot.filesystem.patch} {:var-syms [syntax-quote-fn unquote-splicing? quote-fn unquote? *resolve* resolve-symbol template syntax-quote defquote template-fn], :type :clj, :sym boot.from.backtick} {:var-syms [cli parse-opts summarize compile-option-specs], :type :clj, :sym boot.from.clojure.tools.cli} {:var-syms [sha-256 sha Digestible sha-1 md5 sha-384 -digest md2 sha-512 digest sha1 sha-224 algorithms *buffer-size*], :type :clj, :sym boot.from.digest} {:var-syms [cyan-bg magenta red-font bold-yellow-bg-font bold-green bold-yellow bold-red-bg bold-white-bg bold-cyan italic cyan-font strip-ansi bold-green-bg-font bold-red-bg-font visual-length black bold-black-bg bold bold-yellow-bg white-font bold-white bold-red red-bg cyan-bg-font bold-cyan-bg magenta-bg-font yellow-bg black-font yellow-bg-font white yellow bold-black-bg-font bold-green-bg bold-font inverse reset-font green-bg-font inverse-font white-bg-font green cyan black-bg-font green-font bold-magenta bold-red-font blue-bg-font bold-magenta-bg-font bold-cyan-font bold-white-bg-font blue-bg green-bg bold-blue-bg italic-font csi black-bg blue-font magenta-font yellow-font red-bg-font bold-yellow-font white-bg bold-cyan-bg-font magenta-bg bold-magenta-bg sgr bold-magenta-font red blue bold-black-font bold-blue-font bold-white-font bold-black bold-blue-bg-font bold-green-font bold-blue], :type :clj, :sym boot.from.io.aviso.ansi} {:var-syms [max-value-length format-columns write-rows max-length], :type :clj, :sym boot.from.io.aviso.columns} {:var-syms [*traditional* *fonts* format-exception *default-frame-filter* write-exception* *default-frame-rules* exception-dispatch demangle expand-stack-trace write-exception parse-exception analyze-exception], :type :clj, :sym boot.from.io.aviso.exception} {:var-syms [pretty-print format-exception pretty-print-stack-trace copy uncaught-exception-handler install-pretty-exceptions paste pretty-repl-caught pretty-pst], :type :clj, :sym boot.from.io.aviso.repl} {:var-syms [StringWriter flush-writer write into-string write-string writeln writef eol], :type :clj, :sym boot.from.io.aviso.writer} {:var-syms [feed-from flush exit-code done feed-from-string stream-to-string proc stream-to destroy read-line stream-to-out], :type :clj, :sym boot.from.me.raynes.conch} {:var-syms [format-cell table *style* table-str], :type :clj, :sym boot.from.table.core} {:var-syms [auto-resize-widths outer-border-length get-widths get-initial-widths ensure-valid-width *width* inner-border-length], :type :clj, :sym boot.from.table.width} {:var-syms [tag branch-current ls-tags clean? dirty? status last-commit describe ls-files make-gitignore-matcher], :type :clj, :sym boot.git} {:var-syms [gpg sign gpg-program signing-args sign-jar decrypt], :type :clj, :sym boot.gpg} {:var-syms [update-zip! spit-jar! jarentry spit-zip! dupe? update-jar!], :type :clj, :sym boot.jar} {:var-syms [normalize no-incoming choose topo-sort], :type :clj, :sym boot.kahnsort} {:var-syms [cli-opts parse-bootignore -main shebang? pr-boot-form emit], :type :clj, :sym boot.main} {:var-syms [prn-conflicts dep-conflicts safe-read-string compare-version resolved-versions sortable-version], :type :clj, :sym boot.pedantic} {:var-syms [sealed-classloader-fns with-worker apply-global-exclusions require-in copy-url classloader-resources resolve-release-versions resources pom-xml concat-merger jars-dep-graph eval-in* full-id with-eval-in worker-pod jar-entries* pom-xml-map dependency-pom-properties pod-pool pom-properties data resolve-dependency-jar dependency-pom-properties-map add-dependencies first-wins-merger standard-jar-exclusions destroy-pod canonical-id coord->map with-call-worker send! pom-properties-map canonical-coord unpack-jar this-pod make-pod extend-addable-classloader outdated with-eval-worker resolve-dependencies make-pod-cp pod-id non-caching-url-input-stream into-merger add-shutdown-hook! eval-fn-call pod-name with-invoke-in modifiable-classloader? with-call-in add-dependencies-in jar-entries seal-app-classloader jar-entries-memoized* call-in* classloader-hierarchy copy-resource resolve-nontransitive-dependencies default-dependencies eval-in-callee set-worker-pod! env set-this-pod! caller-namespace add-classpath set-data! with-invoke-worker dependency-loaded? apply-exclusions copy-dependency-jar-entries set-pod-id! map->coord standard-jar-mergers resource-last-modified resolve-dependency-jars jars-in-dep-order with-pod get-classpath pods get-pods eval-in-caller extract-ids set-pods! add-dependencies-worker shutdown-hooks lifecycle-pool], :type :clj, :sym boot.pod} {:var-syms [*default-dependencies* *default-middleware* launch-nrepl], :type :clj, :sym boot.repl} {:var-syms [sift-action read-pass print-fileset], :type :clj, :sym boot.task-helpers} {:var-syms [notify-method boot-logo get-themefiles audible-notify! visual-notify!], :type :clj, :sym boot.task-helpers.notify} {:var-syms [target notify help speak pom sift show web install push jar checkout javac with-cp war add-repo aot zip watch repl wait uber], :type :clj, :sym boot.task.built-in} {:var-syms [->TmpDir ->TmpFileSet add add-tmp map->TmpFileSet removed rm diff path add-cached ITmpFileSet mv hash dir bdir commit! added *hard-link* file time map->TmpDir CACHE_VERSION map->TmpFile state ITmpFile ls cp tmpfileset? ->TmpFile tmpfile? fileset-patch restrict-dirs id changed], :type :clj, :sym boot.tmpdir} {:var-syms [->TmpRegistry -mk! mkdir! mk! mark-delete-me! -get munged-file -init! get init! clean-delete-me! dir-id registry map->TmpRegistry unmk! make-file! tmp-file? -unmk! delete! ITmpRegistry -tmpfile?], :type :clj, :sym boot.tmpregistry} {:var-syms [deploy local run-docs], :type :clj, :sym boot.user} {:var-syms [sh with-let dbug *verbosity* without-exiting exit-error with-err-str guard dotoseq extends-protocol with-rethrow with-semaphore dosh colorize?-system-default jarname do-while-let exit-ok dep-as-map bind-syms warn path->ns let-assert-keys read-string-all pp-str with-semaphore-noblock *sh-dir* with-resolve dbug* print-tree auto-flush *colorize?* fail print-ex map-as-dep pp* while-let warn-deprecated index-of info extract-ids], :type :clj, :sym boot.util} {:var-syms [->clj *to-pod* *from-pod* *for-eval*], :type :clj, :sym boot.xform} {:var-syms [type? get-namespace error-message elide-reader-meta missing-rename? resolve-invokeable-ns analyze-let with-core-macros var-meta desugar-ns-specs js-tag? analyze-map NUMERIC_SET analyze-record analyze-seq* constants-ns-sym resolve-alias *cljs-dep-set* resolve-var write-analysis-cache disallowing-ns* process-rewrite-form js-star-seg dep-has-global-exports? register-specs gen-user-ns *passes* has-extern?* get-expander-ns message parse-invoke *cljs-warning-handlers* disallowing-recur analyze-seq*-wrap confirm-bindings has-extern? foreign-dep? missing-rename-macro? missing-uses missing-use? with-warning-handlers es5-allowed analyze used? node-module-dep? parse-type gets check-rename-macros-inferring-missing *allow-ns* transit-write-opts forms-seq* infer-invoke *cljs-static-fns* array-types *check-alias-dupes* macro-ns-name *reload-macros* resolve-existing-var required? NOT_NATIVE *unchecked-arrays* IGNORE_SYM parse-invoke* *checked-arrays* aliasable-clj-ns? loaded-js-ns? analyze-vector transit-read-opts namespaces elide-analyzer-meta analyze-let-body get-col basic-validate-ns-spec *cljs-warnings* alias->type analyzed? analyze-deps array-type? dotted-symbol? *cljs-macros-is-classpath* locate-src ns-side-effects *allow-redef* analyze-fn-method-body infer-type parse-import-spec clj-ns->cljs-ns constant-value? dump-specs *fn-invoke-direct* use->require inferred-use-macros read-analysis-cache analyze-symbol confirm-var-exists analyze-keyword SENTINEL analyze-let-bindings munge-global-export *loop-lets* js-tag js-reserved *load-tests* requires-analysis? check-use-macros-inferring-missing load-core macroexpand-1* check-use-macros get-expander analyze-js-star build-dot-form js-star-interp *recur-frames* analyze-fn-methods-pass2* macroexpand-1 analyze-file resolve-macro-var analyze-let-binding-init infer-tag canonicalize-import-specs analyze-form-seq analyze-let-body* analyze-js-star* inferred-rename-macros parse-ns-error-msg missing-use-macro? analyzed resolve-symbol all-warn missing-renames resolve* *cljs-macros-path* load-mutex confirm-var-exist-warning unchecked-arrays? analyze-dot analyze-do-statements get-line analyze-do-statements* analyze-seq find-def-clash get-expander* no-warn allowing-redef fn-name-var munge-node-lib *load-macros* excluded? empty-env public-name? default-warning-handler resolve-ns-alias intern-macros BOOLEAN_OR_SEQ *macro-infer* gen-constant-id BOOLEAN_SYM cache-file macro-autoload-ns? get-tag implicit-nses valid-proto parse-ns normalize-js-tag analyze-list warning implicit-import? missing-use-macros rewrite-cljs-aliases analyze* -cljs-macros-loaded check-uses find-matching-method invoke-arg-type-validators *cljs-file* *file-defs* infer-if *verbose* analyze-js-value ns->module-type source-info wrapping-errors transit analyze-fn-method-param analyze-set numeric-type? ast? checked-arrays elide-env js-module-exists?* parse-require-spec analyze-wrap-meta ANY_SYM get-js-tag parse forms-seq *analyze-deps* analyze-let-bindings* analysis-error? replace-env-pass parse-ns-excludes analyze-fn-methods-pass2 core-name? get-let-tag specials resolve-macro-ns-alias check-invoke-arg-types confirm-ns default-namespaces *unchecked-if* canonicalize-specs confirm-var-exists-throw js-module-exists? analyze-form with-core-macros-file var-ast add-consts error invokeable-ns? *cljs-ns*], :type :clj, :sym cljs.analyzer} {:var-syms [emit-constants-table-to-file protocol-prefix emit-arguments-to-array compile-file* distinct-keys? munge compile-root get-define valid-define-value? find-source emit-cached-core emits-keyword emit-inferred-externs-to-file *lexical-renames* emit-let with-core-cljs find-root-sources cljs-reserved-file-names base-types resolve-type emit-variadic-fn-method js-reserved *recompiled* rename-to-js requires-compilation? emits emit-constant emit-constants-table get-first-ns-segment emit-fn-params munge-reserved emit-source fn-self-name load-libs compile-file macro-ns? munge-param-return find-ns-starts-with emit* checking-types? cljs-files-in emit-fn-method emit-comment hash-scope emit-apply-to emits-symbol falsey-constant? *source-map-data* mapped-types resolve-types cached-core *inputs* emit-str compiled-by-string truthy-constant? emitln url-path emit safe-test? emit-externs emit-source-map distinct-constants? emit-wrap shadow-depth], :type :clj, :sym cljs.compiler} {:var-syms [sort-by ITransientAssociative chunk-first m3-hash-int pr-str* tree-seq unchecked-remainder-int seq reduce contains? every? keep-indexed subs IFind MODULE_URIS take-last bit-set string-hash-cache-count qualified-keyword? -with-meta unchecked-subtract-int -iterator *print-namespace-maps* first native-satisfies? seq? -sorted-seq-from inst-ms iterate -empty ILookup -chunked-rest fn? -assoc keyword-identical? *print-err-fn* dissoc atom bit-shift-right *clojurescript-version* -first peek IKVReduce aget -write iter last namespace -conj = ITransientMap take vector? boolean IChunk bit-shift-left any? aclone vreset! chunk dec APersistentVector map < rest -drop-first boolean? -clone char? -reduce -count swap-vals! keep char mapcat unchecked-long m3-seed some? unchecked-negate symbol-identical? *command-line-args* reverse inst? bit-count sort unchecked-inc-int -compare map-indexed comp array-chunk bit-shift-right-zero-fill -as-transient simple-symbol? IIndexed disj IPrintWithWriter IVector IIterable cons floats pos? fnil nthrest *warn-on-infer* -find sequential? m3-mix-H1 prim-seq *print-level* shuffle hash-keyword find alength bit-xor unsigned-bit-shift-right neg? js-invoke m3-mix-K1 unchecked-float undefined? IMeta reduced? disj! -lookup float? ICloneable booleans int-array set? iterable? -pr-writer vary-meta INext is_proto_ ICounted IMapEntry <= MODULE_INFOS conj! -pop repeatedly reset-vals! IStack -remove-watch IVolatile remove * min -persistent! -nth pop! chunk-append *unchecked-arrays* IReversible reversible? -realized? -add-watch -deref-with-timeout conj -sorted-seq transduce -swap! *print-length* js-delete truth_ compare-and-set! array-seq interleave map? m3-C1 get identity into long double volatile? -key nfirst meta -kv-reduce IHash bit-and-not var? -comparator unchecked-add-int hash-ordered-coll IEquiv cycle -deref empty? short -chunked-first filterv hash quot unchecked-double ranged-iterator ITransientVector longs not= set-print-err-fn! string? es6-iterator m3-C2 *print-newline* unchecked-multiply-int chunk-rest double? vec *print-meta* -notify-watches int second IEditableCollection hash-combine > -name int? associative? unchecked-int js-keys inst-ms* keyword? array-iter -rseq unchecked-multiply even? es6-iterator-seq unchecked-dec Inst double-array spread rseq IReset IEmptyableCollection *print-fn-bodies* float IRecord concat IDerefWithTimeout symbol to-array-2d mod ISet pop IPending -entry-key dissoc! indexed? - -equiv assoc! reduce-kv reset! Fn ffirst counted? assoc-in bit-test ISwap zero? simple-keyword? *main-cli-fn* -assoc-n unchecked-dec-int persistent! set-print-fn! nnext not-every? rem ifind? some INamed IReduce neg-int? drop js-obj ITransientCollection nth sorted? nil? split-at not-native bit-and bounded-count update list* update-in ensure-reduced instance? mix-collection-hash unchecked-add transformer-iterator not -vreset! with-meta unreduced record? type identical? -namespace unchecked-divide-int *out* hash-string set-validator! ident? -meta swap! -chunked-next unchecked-subtract IMap cloneable? qualified-ident? hash-string* true? array -peek ISeq empty volatile! / bit-or m3-fmix vector >= drop-last object? not-empty partition DEMUNGE_PATTERN IAssociative bit-flip long-array ISeqable js-mod integer? mapv infinite? ISequential equiv-map object-array seq-iter IChunkedSeq -next flatten -dissoc doubles -contains-key? ifn? IAtom nat-int? IWatchable subvec -pop! partial chunked-seq? replicate reduced ITransientSet unchecked-byte every-pred missing-protocol load-file distinct? pos-int? unchecked-short odd? reduceable? string-hash-cache inc type->str bit-clear filter -assoc-n! IWithMeta list + aset int-rotate-left keyword *ns* *assert* ICollection chars next ASeq IFn -reset! -rest nil-iter false? *print-readably* ints some-fn *flush-on-newline* to-array list? array? simple-ident? clone bit-not byte max IComparable == count -disjoin! *loaded-libs* apply add-to-string-hash-cache IChunkedNext interpose deref assoc transient -disjoin chunk-cons drop-while IWriter *print-fn* compare complement -assoc! *print-dup* string-iter IDeref sequence constantly chunked-seq ISorted make-array shorts *unchecked-if* enable-console-print! -flush completing unchecked-negate-int hash-unordered-coll repeat unchecked-inc nthnext get-validator number? -conj! chunk-next not-any? into-array -hash qualified-symbol? -dissoc! chunk-buffer seqable? symbol? m3-hash-unencoded-chars unchecked-char system-time -invoke coll? get-in fnext IList -val bytes -seq], :type :cljs, :sym cljs.core} {:var-syms [Pub reduce remove> timeout unsub* admix* unmix* mix pub take unsub-all* <! map Mux mapcat> buffer close! offer! chan solo-mode* tap admix promise-chan unique muxch* solo-mode transduce onto-chan to-chan dropping-buffer untap-all into pipeline sub map> pipe unmix filter< sub* remove< untap* toggle untap-all* sliding-buffer partition Mult merge partition-by unsub-all >! unmix-all* split unmix-all filter> tap* untap alts! unsub poll! map< do-alts pipeline-async Mix toggle* mult mapcat< ioc-alts! unblocking-buffer? put! take!], :type :cljs, :sym cljs.core.async} {:var-syms [acopy ring-buffer fixed-buffer dropping-buffer sliding-buffer promise-buffer], :type :cljs, :sym cljs.core.async.impl.buffers} {:var-syms [box put-active? MAX_DIRTY abort MMC chan], :type :cljs, :sym cljs.core.async.impl.channels} {:var-syms [tasks running? queued? TASK_BATCH_SIZE process-messages queue-dispatcher run queue-delay], :type :cljs, :sym cljs.core.async.impl.dispatch} {:var-syms [EXCEPTION-FRAMES process-exception STATE-IDX aset-object add-exception-frame run-state-machine-wrapped FN-IDX aget-object return-chan BINDINGS-IDX CURRENT-EXCEPTION run-state-machine finished? USER-START-IDX put! take! VALUE-IDX], :type :cljs, :sym cljs.core.async.impl.ioc-helpers} {:var-syms [remove! close-buf! close! Handler blockable? active? Buffer full? add! add!* ReadPort Channel closed? UnblockingBuffer MAX-QUEUE-SIZE commit put! take! WritePort], :type :cljs, :sym cljs.core.async.impl.protocols} {:var-syms [MAX_LEVEL P random-level skip-list-node least-greater-node skip-list timeouts-map TIMEOUT_RESOLUTION_MS timeout], :type :cljs, :sym cljs.core.async.impl.timers} {:var-syms [ensure with-compiler-env default-compiler-env *compiler*], :type :clj, :sym cljs.env} {:var-syms [parse-extern-node get-type parse-externs externs-map annotate index-externs get-type*], :type :clj, :sym cljs.externs} {:var-syms [zip-file goog-dependencies load-foreign-library find-js-jar find-js-fs find-js-resources to-url -requires build-index jar-entry-names find-js-classpath goog-dependencies* -provides native-node-modules IJavaScript -source lib-spec-merge dependency-order-visit js-dependency-index -relative-path load-foreign-library* load-library -url find-url -foreign? get-file load-library* jar-entry-names* -closure-lib? library-dependencies find-classpath-lib parse-js-ns dependency-order], :type :clj, :sym cljs.js-deps} {:var-syms [pprint get-pretty-writer *print-suppress-namespaces* char-code *print-pretty* *print-pprint-dispatch* pprint-newline float? pprint-tab pprint-set print-table set-pprint-dispatch fresh-line pprint-indent *print-radix* IPrettyFlush cl-format *print-miser-width* write -ppflush *print-right-margin* write-out *print-base*], :type :cljs, :sym cljs.pprint} {:var-syms [print-doc], :type :cljs, :sym cljs.repl} {:var-syms [update-result encode invert-reverse-map relativize-path decode seg->map source-compare decode-reverse lines->segs merge-source-maps update-reverse-result indexed-sources encode* seg-combine], :type :clj, :sym cljs.source-map} {:var-syms [chars64 encode int->char decode char->int], :type :clj, :sym cljs.source-map.base64} {:var-syms [encode-val encode vlq-continuation-bit vlq-base-mask bit-shift-right-zero-fill decode vlq-base-shift from-vlq-signed to-vlq-signed vlq-base], :type :clj, :sym cljs.source-map.base64-vlq} {:var-syms [form nilable-impl *recursion-limit* *coll-error-limit* explain-printer Specize alt-impl def-impl *explain-out* regex-spec-impl merge-spec-impl explain-data* MAX_INT check-asserts assert* inst-in-range? and-spec-impl describe* map-spec-impl explain with-gen* or-spec-impl *fspec-iterations* Spec unform valid? gen nonconforming unform* abbrev regex? int-in-range? spec? registry rep+impl exercise explain-data tuple-impl multi-spec-impl conform gen* fspec-impl *coll-check-limit* get-spec every-impl spec-impl invalid? amp-impl cat-impl explain-str *compile-asserts* with-gen conform* check-asserts? rep-impl describe explain-out specize* maybe-impl explain*], :type :cljs, :sym cljs.spec.alpha} {:var-syms [quick-check for-all* delay-impl cat gen-for-pred], :type :cljs, :sym cljs.spec.gen.alpha} {:var-syms [read-uuid valid-js-literal-key? read-inst read-queue *cljs-data-readers* ->JSValue read-js], :type :clj, :sym cljs.tagged-literals} {:var-syms [output-directory windows? *clojurescript-version* boolean? file-or-resource distinct-by path normalize-path clojurescript-version ext content-sha valid-js-id-start? ns->relpath get-name debug-prn-mutex map-merge to-target-file mkdirs compile-if url? module-file-seq conjunction-str suggestion path-seq compiled-by-version measure ns->source last-modified debug-prn file? unknown-opts levenshtein-distance filename to-path topo-sort munge-path build-options changed? relative-name], :type :clj, :sym cljs.util} {:var-syms [primitives-classnames +' decimal? restart-agent sort-by macroexpand ensure chunk-first eduction tree-seq unchecked-remainder-int seq reduce when-first find-ns get-thread-bindings contains? every? proxy-mappings keep-indexed cond->> subs ref-min-history set take-last bit-set reader-conditional gen-class qualified-keyword? while ->Eduction butlast satisfies? line-seq unchecked-subtract-int *print-namespace-maps* take-nth first re-groups seq? dec' ns-unmap println-str with-bindings* inst-ms iterator-seq iterate slurp newline short-array fn? doall prefers enumeration-seq dedupe dissoc atom import bit-shift-right print-method peek aget pvalues bound-fn vswap! last pr namespace push-thread-bindings bases = dosync remove-ns take vector? thread-bound? send-via boolean bit-shift-left any? find-var rand-int aclone vreset! chunk dec future-call resultset-seq struct map juxt ns-publics < *source-path* with-loading-context test rest ex-data compile isa? boolean? .. munge delay set-error-mode! re-seq char? make-hierarchy set-agent-send-executor! swap-vals! keep char mapcat unchecked-long aset-long some? unchecked-negate gen-interface *command-line-args* reverse inst? range sort -cache-protocol-fn unchecked-inc-int map-indexed with-bindings rand-nth comp await spit future-done? *read-eval* dorun simple-symbol? disj *2 eval cons refer print-dup -reset-methods floats pos? fnil merge-with nthrest load if-not *verbose-defrecords* sequential? *print-level* shuffle boolean-array find alength bit-xor deliver doseq unsigned-bit-shift-right neg? var-set unchecked-float pmap error-mode num reduced? disj! float? aset-float deftype bean booleans ns-unalias when-let int-array set? inc' cat StackTraceElement->vec *suppress-read* flush take-while vary-meta <= alter -' if-some conj! repeatedly zipmap reset-vals! alter-var-root biginteger remove * re-pattern min pop! chunk-append prn-str with-precision format reversible? shutdown-agents conj bound? transduce lazy-seq *print-length* *file* compare-and-set! *use-context-classloader* await1 let ref-set pop-thread-bindings interleave printf map? -> defstruct *err* get doto identity into areduce long double volatile? definline nfirst meta find-protocol-impl bit-and-not *default-data-reader-fn* var? method-sig unchecked-add-int unquote-splicing hash-ordered-coll future reset-meta! cycle fn seque empty? short definterface filterv hash quot ns-aliases read unchecked-double key longs not= string? uri? aset-double unchecked-multiply-int chunk-rest pcalls *allow-unresolved-vars* remove-all-methods ns-resolve as-> aset-boolean trampoline double? when-not *1 vec *print-meta* when int map-entry? ns-refers rand second vector-of hash-combine > replace int? associative? unchecked-int set-error-handler! inst-ms* keyword? force bound-fn* namespace-munge group-by prn extend unchecked-multiply some->> default-data-readers ->VecSeq even? unchecked-dec Inst tagged-literal? double-array in-ns create-ns re-matcher defn ref bigint extends? promise aset-char rseq construct-proxy agent-errors *compile-files* *math-context* float pr-str concat aset-short set-agent-send-off-executor! ns symbol to-array-2d mod amap pop use unquote declare dissoc! reductions aset-byte indexed? ref-history-count - assoc! hash-set reduce-kv or cast reset! name ffirst sorted-set counted? byte-array tagged-literal println extend-type macroexpand-1 assoc-in char-name-string bit-test defmethod EMPTY-NODE time memoize alter-meta! future? zero? simple-keyword? require unchecked-dec-int persistent! nnext add-watch not-every? class? rem agent-error some future-cancelled? memfn neg-int? struct-map drop *data-readers* nth sorted? nil? extend-protocol split-at *e load-reader random-sample cond-> dotimes select-keys bit-and bounded-count update list* reify update-in prefer-method aset-int *clojure-version* ensure-reduced *' instance? with-open mix-collection-hash re-find run! val defonce unchecked-add loaded-libs ->Vec bytes? not with-meta unreduced the-ns record? type identical? unchecked-divide-int ns-name max-key *unchecked-math* defn- *out* file-seq agent ns-map set-validator! ident? defprotocol swap! vals unchecked-subtract *warn-on-reflection* sorted-set-by sync qualified-ident? assert *compile-path* true? release-pending-sends print empty remove-method *in* print-ctor letfn volatile! / read-line reader-conditional? bit-or clear-agent-errors vector proxy-super >= drop-last not-empty distinct partition loop add-classpath bit-flip long-array descendants merge accessor integer? mapv partition-all partition-by numerator object-array with-out-str condp derive load-string special-symbol? ancestors subseq error-handler gensym cond ratio? delay? intern print-simple flatten doubles halt-when with-in-str remove-watch ex-info ifn? some-> nat-int? proxy-name ns-interns all-ns find-protocol-method subvec for binding partial chunked-seq? find-keyword replicate min-key reduced char-escape-string re-matches array-map unchecked-byte with-local-vars ns-imports send-off defmacro every-pred keys rationalize load-file distinct? pos-int? extenders unchecked-short methods odd? ->ArrayChunk float-array *3 alias frequencies read-string proxy rsubseq inc get-method with-redefs uuid? bit-clear filter locking list + split-with aset ->VecNode keyword *ns* destructure *assert* defmulti chars str next hash-map if-let underive ref-max-history Throwable->map false? *print-readably* ints class some-fn case *flush-on-newline* to-array bigdec list? simple-ident? bit-not io! xml-seq byte max == *agent* lazy-cat comment parents count supers *fn-loader* sorted-map-by apply interpose deref assoc rational? transient clojure-version chunk-cons comparator sorted-map send drop-while proxy-call-with-super realized? char-array resolve compare complement *compiler-options* *print-dup* defrecord with-redefs-fn sequence constantly get-proxy-class make-array shorts completing update-proxy unchecked-negate-int hash-unordered-coll repeat unchecked-inc *reader-resolver* nthnext and create-struct get-validator number? await-for chunk-next print-str not-any? into-array qualified-symbol? init-proxy chunk-buffer seqable? symbol? when-some unchecked-char ->> future-cancel var-get commute coll? get-in fnext denominator bytes refer-clojure], :type :clj, :sym clojure.core} {:var-syms [Pub reduce remove> timeout unsub* admix* unmix* mix pub take unsub-all* <! map Mux mapcat> buffer close! offer! chan solo-mode* tap go admix promise-chan unique muxch* solo-mode transduce onto-chan to-chan dropping-buffer untap-all into >!! alt! pipeline sub go-loop map> pipe unmix filter< sub* remove< alt!! untap* <!! toggle untap-all* sliding-buffer partition Mult merge partition-by unsub-all >! unmix-all* split unmix-all filter> tap* untap alts! unsub poll! thread map< fn-handler do-alts pipeline-blocking pipeline-async Mix toggle* mult thread-call alts!! mapcat< ioc-alts! unblocking-buffer? do-alt put! take!], :type :clj, :sym clojure.core.async} {:var-syms [->PromiseBuffer ->DroppingBuffer dropping-buffer fixed-buffer ->FixedBuffer sliding-buffer ->SlidingBuffer promise-buffer], :type :clj, :sym clojure.core.async.impl.buffers} {:var-syms [cleanup chan box MMC abort assert-unlock ->ManyToManyChannel], :type :clj, :sym clojure.core.async.impl.channels} {:var-syms [counted-thread-factory processors], :type :clj, :sym clojure.core.async.impl.concurrent} {:var-syms [executor run], :type :clj, :sym clojure.core.async.impl.dispatch} {:var-syms [thread-pool-executor], :type :clj, :sym clojure.core.async.impl.exec.threadpool} {:var-syms [index-state-machine ->PopTry EXCEPTION-FRAMES block-references reads-from index-block map->Case map->InstanceInterop add-block instruction? ->RawCode let-binding-to-ssa map->CondBr map->Const ->Call ->Jmp ->CondBr map->PushTry count-persistent-values get-binding gen-plan -item-to-ssa ->Case get-block id-for-inst index-instruction pdebug writes-to ->Dot map->CustomTerminator terminator-code set-block ->CatchHandler STATE-IDX ->PushTry mark-transitions ->Fn map->CatchHandler ->Return aset-object run-passes IEmittableInstruction map->Call ITerminator map->Fn emit-instruction IInstruction map->Dot make-env propagate-recur terminate-block ->InstanceInterop map->PopTry persistent-value? propagate-transitions assoc-in-plan run-state-machine-wrapped push-alter-binding aset-all! debug parse-to-state-machine get-plan FN-IDX aget-object return-chan all pop-binding ->EndFinally nested-go? ->Recur add-instruction no-op passes push-binding ->CustomTerminator BINDINGS-IDX map->Return item-to-ssa map->EndFinally async-custom-terminators ->StaticCall map->RawCode CURRENT-EXCEPTION emit-hinted ->Const map->StaticCall print-plan run-state-machine get-in-plan update-in-plan map->Recur map->Jmp finished? USER-START-IDX put! take! var-name state-machine VALUE-IDX], :type :clj, :sym clojure.core.async.impl.ioc-macros} {:var-syms [mutex], :type :clj, :sym clojure.core.async.impl.mutex} {:var-syms [remove! close-buf! close! Handler blockable? active? Buffer full? add! lock-id exec Executor add!* ReadPort Channel closed? UnblockingBuffer MAX-QUEUE-SIZE commit put! take! WritePort], :type :clj, :sym clojure.core.async.impl.protocols} {:var-syms [->TimeoutQueueEntry timeout timeout-daemon TIMEOUT_RESOLUTION_MS], :type :clj, :sym clojure.core.async.impl.timers} {:var-syms [defcache clear-soft-cache! make-reference ->FnCache ->SoftCache soft-cache-factory ->TTLCache has? evict miss lookup hit through ttl-cache-factory lu-cache-factory ->LIRSCache ->LRUCache ->BasicCache lirs-cache-factory basic-cache-factory CacheProtocol seed fifo-cache-factory ->FIFOCache ->LUCache lru-cache-factory], :type :clj, :sym clojure.core.cache} {:var-syms [memo-ttl ->PluggableMemoization memo memoized? lu fifo memo-unwrap through* memo-fifo memo-swap! ->RetryingDelay lru build-memoizer snapshot ttl memo-lu memo-clear! memo-lru], :type :clj, :sym clojure.core.memoize} {:var-syms [IKVReduce CollReduce coll-reduce internal-reduce InternalReduce kv-reduce], :type :clj, :sym clojure.core.protocols} {:var-syms [stop-server repl-init start-server start-servers stop-servers repl-read *session* repl], :type :clj, :sym clojure.core.server} {:var-syms [diff equality-partition EqualityPartition diff-similar Diff], :type :clj, :sym clojure.data} {:var-syms [pprint -write read-json read-str read json-str write-str pprint-json JSONWriter write write-json print-json], :type :clj, :sym clojure.data.json} {:var-syms [->PersistentPriorityMap priority-map-by apply-keyfn priority-map-keyfn priority-map-keyfn-by priority-map], :type :clj, :sym clojure.data.priority-map} {:var-syms [read read-string], :type :clj, :sym clojure.edn} {:var-syms [validated read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym clojure.instant} {:var-syms [default-streams-impl make-output-stream make-parents delete-file input-stream make-writer as-relative-path copy as-file output-stream make-reader Coercions file make-input-stream IOFactory resource writer as-url reader], :type :clj, :sym clojure.java.io} {:var-syms [sh *sh-dir* with-sh-dir *sh-env* with-sh-env], :type :clj, :sym clojure.java.shell} {:var-syms [main with-bindings stack-element-str repl-caught repl-exception repl-read load-script skip-if-eol skip-whitespace root-cause repl-requires demunge with-read-known repl repl-prompt], :type :clj, :sym clojure.main} {:var-syms [pprint simple-dispatch get-pretty-writer *print-suppress-namespaces* *print-pretty* *print-pprint-dispatch* pprint-newline code-dispatch print-length-loop pprint-tab pprint-logical-block print-table pp set-pprint-dispatch fresh-line formatter-out formatter pprint-indent *print-radix* cl-format *print-miser-width* write *print-right-margin* write-out with-pprint-dispatch *print-base*], :type :clj, :sym clojure.pprint} {:var-syms [->Field ->Method TypeReference reflect map->Field map->Method typename ->JavaReflector ->AsmReflector resolve-class flag-descriptors do-reflect ClassResolver Reflector ->Constructor map->Constructor type-reflect], :type :clj, :sym clojure.reflect} {:var-syms [source-fn doc stack-element-str find-doc dir pst dir-fn source set-break-handler! root-cause demunge thread-stopper apropos], :type :clj, :sym clojure.repl} {:var-syms [union map-invert join select intersection superset? index subset? rename rename-keys project difference], :type :clj, :sym clojure.set} {:var-syms [form & nilable-impl *recursion-limit* *coll-error-limit* fspec explain-printer Specize every keys* alt-impl def-impl *explain-out* regex-spec-impl merge-spec-impl explain-data* check-asserts assert* inst-in-range? nilable and-spec-impl describe* map-spec-impl coll-of cat * explain with-gen* or-spec-impl *fspec-iterations* Spec unform valid? gen every-kv int-in alt nonconforming unform* abbrev regex? int-in-range? or spec? registry rep+impl exercise-fn exercise multi-spec explain-data tuple-impl multi-spec-impl tuple conform gen* fspec-impl assert ? *coll-check-limit* merge get-spec conformer every-impl spec keys spec-impl + invalid? amp-impl map-of cat-impl explain-str *compile-asserts* with-gen conform* check-asserts? rep-impl double-in inst-in describe explain-out and specize* def maybe-impl explain* fdef], :type :clj, :sym clojure.spec.alpha} {:var-syms [uuid gen-for-pred lazy-prim set one-of any-printable vector-distinct boolean string-alphanumeric map delay simple-type char bind symbol-ns any lazy-prims cat double char-alpha int return gen-for-name symbol quick-check char-alphanumeric choose for-all* string-ascii frequency double* generate delay-impl lazy-combinators tuple string vector large-integer keyword-ns not-empty elements sample list large-integer* keyword hash-map ratio such-that fmap char-ascii simple-type-printable lazy-combinator bytes], :type :clj, :sym clojure.spec.gen.alpha} {:var-syms [print-stack-trace print-trace-element print-cause-trace e root-cause print-throwable], :type :clj, :sym clojure.stacktrace} {:var-syms [ends-with? capitalize reverse join replace-first starts-with? escape last-index-of re-quote-replacement includes? replace split-lines lower-case trim-newline upper-case split trimr index-of trim triml blank?], :type :clj, :sym clojure.string} {:var-syms [ends-with? capitalize reverse join replace-first starts-with? escape last-index-of includes? replace split-lines lower-case trim-newline upper-case split trimr index-of trim triml blank?], :type :cljs, :sym clojure.string} {:var-syms [macroexpand valid-binding-symbol? analyze-let analyze-map parse-def parse-quote parse-new analyze-fn-method parse-invoke analyze parse-dot parse-do analyze-const parse-loop* analyze-vector var? parse-if -analyze-form create-var parse-try analyze-symbol macroexpand-1 analyze-body parse-letfn* parse-catch analyze-seq parse-recur empty-env analyze-in-env parse-fn* validate-bindings parse-let* parse-throw analyze-set -parse parse wrapping-meta parse-set! specials analyze-form parse-var], :type :clj, :sym clojure.tools.analyzer} {:var-syms [update-children postwalk children walk prewalk children* cycling ast->eav update-children-reduced nodes], :type :clj, :sym clojure.tools.analyzer.ast} {:var-syms [ensure deref-env *env* with-env], :type :clj, :sym clojure.tools.analyzer.env} {:var-syms [analyze-ns parse-case* global-env analyze qualify-arglists parse-reify* analyze+eval analyze-method-impls desugar-symbol create-var run-passes parse-monitor-enter parse-import* build-ns-map macroexpand-1 desugar-host-expr parse-deftype* parse-opts+methods -deftype default-passes empty-env update-ns-map! macroexpand-all scheduled-default-passes parse default-passes-opts parse-monitor-exit specials ->ExceptionThrown], :type :clj, :sym clojure.tools.analyzer.jvm} {:var-syms [unbox static-methods members special-arrays static-field primitive? instance-methods numeric? instance-method static-members wider-tag static-method wider-primitive prim-or-obj ns->relpath try-best-match maybe-class instance-members maybe-class-from-string box array-class ns-url members* subsumes? wider-tag* name-matches? convertible? instance-field prim-interface inline? tag-match? maybe-class-literal specials macro? wider-than object-members], :type :clj, :sym clojure.tools.analyzer.jvm.utils} {:var-syms [schedule-passes satisfies-affected? schedule group compile-passes schedule* calculate-deps desugar-deps maybe-looping-pass collapse], :type :clj, :sym clojure.tools.analyzer.passes} {:var-syms [add-binding-atom], :type :clj, :sym clojure.tools.analyzer.passes.add-binding-atom} {:var-syms [cleanup], :type :clj, :sym clojure.tools.analyzer.passes.cleanup} {:var-syms [constant-lift], :type :clj, :sym clojure.tools.analyzer.passes.constant-lifter} {:var-syms [elides elide-meta replace-meta get-elides -elide-meta], :type :clj, :sym clojure.tools.analyzer.passes.elide-meta} {:var-syms [emit-bindings -emit-form emit-form -emit-form* emit-hygienic-form], :type :clj, :sym clojure.tools.analyzer.passes.emit-form} {:var-syms [-analyze-host-expr analyze-host-expr maybe-static-field maybe-instance-method analyze-host-call maybe-instance-field analyze-host-field maybe-static-method], :type :clj, :sym clojure.tools.analyzer.passes.jvm.analyze-host-expr} {:var-syms [annotate-host-info], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-host-info} {:var-syms [annotate-loops check-recur -check-recur -loops], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-loops} {:var-syms [-annotate-tag annotate-tag], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-tag} {:var-syms [if-let-box boxed? -box box], :type :clj, :sym clojure.tools.analyzer.passes.jvm.box} {:var-syms [classify-invoke], :type :clj, :sym clojure.tools.analyzer.passes.jvm.classify-invoke} {:var-syms [constant-lift constant-lift*], :type :clj, :sym clojure.tools.analyzer.passes.jvm.constant-lifter} {:var-syms [-emit-form emit-form -emit-form* class->str emit-hygienic-form class->sym], :type :clj, :sym clojure.tools.analyzer.passes.jvm.emit-form} {:var-syms [fix-case-test], :type :clj, :sym clojure.tools.analyzer.passes.jvm.fix-case-test} {:var-syms [-infer-tag infer-tag =-arglists?], :type :clj, :sym clojure.tools.analyzer.passes.jvm.infer-tag} {:var-syms [validate-tag validate-call validate validate-interfaces -validate], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate} {:var-syms [find-mismatches dirty -validate-loop-locals validate-loop-locals -validate-loop-locals* -cleanup-dirty-nodes], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate-loop-locals} {:var-syms [validate-recur], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate-recur} {:var-syms [warn-on-reflection warn], :type :clj, :sym clojure.tools.analyzer.passes.jvm.warn-on-reflection} {:var-syms [-merge-source-info source-info], :type :clj, :sym clojure.tools.analyzer.passes.source-info} {:var-syms [preserving-raw-forms trim -trim], :type :clj, :sym clojure.tools.analyzer.passes.trim} {:var-syms [normalize uniquify-locals* -uniquify-locals *locals-frame* uniquify-binding *locals-counter* uniquify-locals-around uniquify-locals uniquify], :type :clj, :sym clojure.tools.analyzer.passes.uniquify} {:var-syms [warn-earmuff], :type :clj, :sym clojure.tools.analyzer.passes.warn-earmuff} {:var-syms [type? ctx boolean? mapv' rseqv protocol-node? select-keys' -source-info classify reference? update-vals resolve-sym private? constant? regex? dynamic? compile-if into! const-val dissoc-env update-kv record? butlast+last obj? source-info mmerge resolve-ns update-keys arglist-for-arity macro? merge'], :type :clj, :sym clojure.tools.analyzer.utils} {:var-syms [cli parse-opts summarize get-default-options format-lines make-summary-part], :type :clj, :sym clojure.tools.cli} {:var-syms [resolve-deps make-classpath], :type :clj, :sym clojure.tools.deps.alpha} {:var-syms [-main], :type :clj, :sym clojure.tools.deps.alpha.makecp} {:var-syms [manifest-type manifest-types detect-manifest coord-paths coord-type compare-versions dep-id coord-deps], :type :clj, :sym clojure.tools.deps.alpha.providers} {:var-syms [read-deps], :type :clj, :sym clojure.tools.deps.alpha.reader} {:var-syms [map-keys], :type :clj, :sym clojure.tools.deps.alpha.util.coll} {:var-syms [exclusions->data make-session make-local-repo remote-repo default-local-repo dep->data console-listener ->CustomProvider the-system standard-repos coord->artifact], :type :clj, :sym clojure.tools.deps.alpha.util.maven} {:var-syms [immediate-dependencies remove-edge depends? depend immediate-dependents set-conj remove-node ->MapDependencyGraph transitive-dependents-set topo-comparator transitive-dependencies map->MapDependencyGraph DependencyGraph topo-sort transitive-dependents nodes graph DependencyGraphUpdate remove-all dependent? transitive-dependencies-set], :type :clj, :sym clojure.tools.namespace.dependency} {:var-syms [add-files remove-files read-file-ns-decl clojure-file?], :type :clj, :sym clojure.tools.namespace.file} {:var-syms [find-namespaces-in-jarfile find-namespaces-in-dir find-ns-decls-in-jarfile read-ns-decl-from-jarfile-entry find-ns-decls find-clojure-sources-in-dir clojure-sources-in-jar find-namespaces find-ns-decls-in-dir], :type :clj, :sym clojure.tools.namespace.find} {:var-syms [ns-decl? deps-from-ns-decl read-ns-decl comment?], :type :clj, :sym clojure.tools.namespace.parse} {:var-syms [add tracker remove], :type :clj, :sym clojure.tools.namespace.track} {:var-syms [*read-eval* *suppress-read* *default-data-reader-fn* read read-symbol default-data-readers *data-readers* *read-delim* resolve-symbol *alias-map* read-regex syntax-quote read-string map-func], :type :clj, :sym clojure.tools.reader} {:var-syms [default-uuid-reader validated clojure.tools.reader.default_data_readers.proxy$java.lang.ThreadLocal$ff19274a read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym clojure.tools.reader.default-data-readers} {:var-syms [match-number skip-line int-pattern read-comment parse-symbol number-literal? read-past float-pattern throwing-reader ratio-pattern], :type :clj, :sym clojure.tools.reader.impl.commons} {:var-syms [throw-bad-dispatch throw-invalid-unicode-escape throw-bad-ns throw-unknown-reader-tag throw-eof-at-dispatch throw-bad-metadata-target throw-invalid-number reader-error throw-invalid-unicode-literal throw-ns-map-no-map throw-unsupported-character throw-feature-not-keyword throw-eof-delimited throw-eof-in-character throw-bad-char eof-error throw-bad-metadata throw-eof-reading throw-eof-error illegal-arg-error throw-invalid-octal-len throw-invalid-unicode-digit throw-invalid-unicode-digit-in-token throw-invalid-unicode-len throw-single-colon throw-odd-map throw-bad-octal-number throw-bad-reader-tag throw-unmatch-delimiter throw-invalid-character-literal throw-invalid-unicode-char throw-bad-escape-char throw-no-dispatch throw-eof-at-start throw-invalid], :type :clj, :sym clojure.tools.reader.impl.errors} {:var-syms [inspect inspect*], :type :clj, :sym clojure.tools.reader.impl.inspect} {:var-syms [whitespace? char numeric? make-var second' desugar-meta <=clojure-1-7-alpha5 ex-info? newline? namespace-keys compile-when], :type :clj, :sym clojure.tools.reader.impl.utils} {:var-syms [ReaderCoercer indexing-push-back-reader log-source* merge-meta ->StringReader to-pbr to-rdr Reader source-logging-push-back-reader unread peek-char push-back-reader IPushbackReader indexing-reader? string-reader read-char get-column-number get-file-name read-line ->PushbackReader PushbackReaderCoercer string-push-back-reader log-source ->SourceLoggingPushbackReader ->InputStreamReader line-start? input-stream-push-back-reader source-logging-reader? IndexingReader get-line-number input-stream-reader ->IndexingPushbackReader], :type :clj, :sym clojure.tools.reader.reader-types} {:var-syms [postwalk keywordize-keys walk prewalk-replace stringify-keys prewalk postwalk-demo prewalk-demo macroexpand-all postwalk-replace], :type :clj, :sym clojure.walk} {:var-syms [walk postwalk prewalk keywordize-keys stringify-keys prewalk-replace postwalk-replace], :type :cljs, :sym clojure.walk} {:var-syms [chan <!! put!], :type :clj, :sym dynadoc.aliases} {:var-syms [dynadoc], :type :clj, :sym dynadoc.boot} {:var-syms [var-sym->url spec->html example->html init-editor expandable-section ns-sym->url sidebar var->html page-url update-link export-form export source->html app init-example-editor], :type :clj, :sym dynadoc.common} {:var-syms [print-server handler page-state get-clj-vars dev-start get-cljs-nses-and-vars-dynamically -main get-clj-nses get-examples var-map->vars get-cljs-nses-and-vars start *options public-files get-cljs-vars page export *web-server get-cljs-nses get-clj-var-info], :type :clj, :sym dynadoc.core} {:var-syms [defexample registry-ref parse-example defexamples parse-val parse-ns defexample* parse-keys defexamples*], :type :clj, :sym dynadoc.example} {:var-syms [read-cljs-file get-cljs-arglists get-cljs-nses-and-vars], :type :clj, :sym dynadoc.static} {:var-syms [form->serializable parse-uri flatten-vals cli-options process-example], :type :clj, :sym dynadoc.utils} {:var-syms [*cljs-info watch-request *channel->uri init-watcher!], :type :clj, :sym dynadoc.watch} {:var-syms [when-resolves], :type :clj, :sym dynapath.defaults} {:var-syms [can-read? DynamicClasspath add-classpath-url can-add? base-readable-addable-classpath classpath-urls], :type :clj, :sym dynapath.dynamic-classpath} {:var-syms [all-classpath-urls addable-classpath? add-classpath-url readable-classpath? classpath-urls], :type :clj, :sym dynapath.util} {:var-syms [thunk-timeout uglify-time-unit], :type :clj, :sym eval-soup.clojail} {:var-syms [wrap-security code->results wrap-timeout eval_soup.core.proxy$java.lang.SecurityManager$ff19274a with-security], :type :clj, :sym eval-soup.core} {:var-syms [process-handler process-paths extract-paths-by-type created? watch! stop! deleted? remove-duplicate-paths file? remove-children-paths process-context directory? modified? catch-errors], :type :clj, :sym hawk.core} {:var-syms [standard-watch-event-kinds polling-watcher-impl barbary-watch-event-kinds stop! new-watcher barbary-watcher-impl sensitivity-watch-event-modifiers Watcher java-watcher-impl take! register!], :type :clj, :sym hawk.watcher} {:var-syms [line->segments tag->hiccup line->html code->hiccup split-lines code->html line->hiccup tags-for-line->hiccup tag->html escape-html-str tags-for-line->html structurize-hiccup escape-html-char parse-lines], :type :clj, :sym html-soup.core} {:var-syms [ns-tracker], :type :clj, :sym ns-tracker.core} {:var-syms [dependent seq-union dependencies remove-key depends? depend dependents graph remove-all], :type :clj, :sym ns-tracker.dependency} {:var-syms [deps-from-ns-decl], :type :clj, :sym ns-tracker.nsdeps} {:var-syms [in-ns-decl? read-in-ns-decl], :type :clj, :sym ns-tracker.parse} {:var-syms [*read-eval* *suppress-read* *default-data-reader-fn* read read-symbol default-data-readers *data-readers* *read-delim* resolve-symbol *alias-map* *wrap-value-and-add-metadata?* read-regex syntax-quote read-string map-func], :type :clj, :sym oakclojure.tools.reader} {:var-syms [default-uuid-reader validated oakclojure.tools.reader.default_data_readers.proxy$java.lang.ThreadLocal$ff19274a read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym oakclojure.tools.reader.default-data-readers} {:var-syms [match-number skip-line int-pattern read-comment parse-symbol number-literal? read-past float-pattern throwing-reader ratio-pattern], :type :clj, :sym oakclojure.tools.reader.impl.commons} {:var-syms [throw-bad-dispatch throw-invalid-unicode-escape throw-bad-ns throw-unknown-reader-tag throw-eof-at-dispatch throw-bad-metadata-target throw-invalid-number reader-error throw-invalid-unicode-literal throw-ns-map-no-map throw-unsupported-character throw-feature-not-keyword throw-eof-delimited throw-eof-in-character throw-bad-char eof-error throw-bad-metadata throw-eof-reading throw-eof-error illegal-arg-error throw-invalid-octal-len throw-invalid-unicode-digit throw-invalid-unicode-digit-in-token throw-invalid-unicode-len throw-single-colon throw-odd-map throw-bad-octal-number throw-bad-reader-tag throw-unmatch-delimiter throw-invalid-character-literal throw-invalid-unicode-char throw-bad-escape-char throw-no-dispatch throw-eof-at-start throw-invalid], :type :clj, :sym oakclojure.tools.reader.impl.errors} {:var-syms [inspect inspect*], :type :clj, :sym oakclojure.tools.reader.impl.inspect} {:var-syms [whitespace? char numeric? make-var second' desugar-meta <=clojure-1-7-alpha5 ex-info? newline? namespace-keys compile-when], :type :clj, :sym oakclojure.tools.reader.impl.utils} {:var-syms [ReaderCoercer indexing-push-back-reader log-source* merge-meta ->StringReader to-pbr to-rdr Reader source-logging-push-back-reader unread peek-char push-back-reader IPushbackReader indexing-reader? string-reader read-char get-column-number get-file-name read-line ->PushbackReader PushbackReaderCoercer string-push-back-reader log-source ->SourceLoggingPushbackReader ->InputStreamReader line-start? input-stream-push-back-reader source-logging-reader? IndexingReader get-line-number input-stream-reader ->IndexingPushbackReader], :type :clj, :sym oakclojure.tools.reader.reader-types} {:var-syms [on-receive accept run-server send! send-websocket-handshake! on-close with-channel Channel close sec-websocket-accept websocket? open?], :type :clj, :sym org.httpkit.server} {:var-syms [:bezier :hsb get-screen :stroke set-size :animation :arc :triangle get-canvas pre-render load-image :fill create-game :rgb get-width get-asset get-height :div on-show Game Screen start :line get-delta-time on-hide :quad :shape get-pressed-keys :ellipse on-render :curve :image draw-sketch! :point :contour render listen load-tiled-map set-screen :rect get-total-time get-renderer :text], :type :cljs, :sym play-cljs.core} {:var-syms [update-opts basic-defaults text-defaults img-defaults rgb-defaults hsb-defaults halign->constant valign->constant style->constant], :type :cljs, :sym play-cljs.utils} {:var-syms [wrap-content-type content-type-response], :type :clj, :sym ring.middleware.content-type} {:var-syms [file-request wrap-file], :type :clj, :sym ring.middleware.file} {:var-syms [head-request wrap-head head-response], :type :clj, :sym ring.middleware.head} {:var-syms [keyword-params-request wrap-keyword-params], :type :clj, :sym ring.middleware.keyword-params} {:var-syms [wrap-params params-request assoc-form-params assoc-query-params], :type :clj, :sym ring.middleware.params} {:var-syms [wrap-reload], :type :clj, :sym ring.middleware.reload} {:var-syms [wrap-resource resource-request], :type :clj, :sym ring.middleware.resource} {:var-syms [percent-encode url-decode fix-string-replace-bug form-encode form-decode-str form-decode assoc-conj url-encode FormEncodeable form-encode* base64-decode percent-decode base64-encode], :type :clj, :sym ring.util.codec} {:var-syms [last-modified-date close! piped-input-stream string-input-stream], :type :clj, :sym ring.util.io} {:var-syms [ext-mime-type default-mime-types], :type :clj, :sym ring.util.mime-type} {:var-syms [re-token re-quoted re-charset re-value], :type :clj, :sym ring.util.parsing} {:var-syms [request-url body-string content-length content-type path-info character-encoding urlencoded-form? set-context in-context?], :type :clj, :sym ring.util.request} {:var-syms [get-header redirect redirect-status-codes set-cookie response find-header file-response resource-response get-charset created header charset url-response redirect-after-post update-header resource-data status not-found content-type response?], :type :clj, :sym ring.util.response} {:var-syms [http-date-formats format-date parse-date], :type :clj, :sym ring.util.time} {:var-syms [mount unmount local reactive ref-node react render-static-markup request-render with-key build-defcs ref defc static defcs cursor state cursor-in dom-node with-ref build-defc render-html build-defcc derived-atom defcc], :type :clj, :sym rum.core} {:var-syms [->Cursor], :type :clj, :sym rum.cursor} {:var-syms [derived-atom], :type :clj, :sym rum.derived-atom} {:var-syms [normalize-css-value render-class! render-inner-html! *select-value* render-attrs! render-style-kv! normalize-css-key unitless-css-props render-static-markup to-str normalize-attr-key render-textarea-value! render-content! nothing? normalize-element render-attr! render-classes! append! get-value ToString parse-selector -render-html render-html HtmlRenderer render-element! normalized-attrs escape-html render-style! adler32], :type :clj, :sym rum.server-render} {:var-syms [call-all filter-vals collect collect*], :type :clj, :sym rum.util} {:var-syms [compile-merge-attrs compile-react compile-react-element to-js compile-attr ICompile compile-attrs compile-html IJSValue], :type :clj, :sym sablono.compiler} {:var-syms [map-lookup? attributes compact-map children element match-tag strip-css class class-name merge-with-class], :type :clj, :sym sablono.normalize} {:var-syms [join-classes to-str react-fn camel-case-keys element? *base-url* as-str html-to-dom-attrs ToString ToURI camel-case to-uri], :type :clj, :sym sablono.util} {:var-syms [special-indent code->tags indent-for-line adjust-indent read-safe unwrap-value get-tags-before-line forward-indent-for-line tag-map back-indent-for-line], :type :clj, :sym tag-soup.core}], :cljs-nses-and-vars {cljs.core.async.impl.channels ({:sym box, :meta {:doc nil, :arglists ([val])}, :source "(defn box [val] (reify cljs.core/IDeref (-deref [_] val)))\n"} {:sym put-active?, :meta {:doc nil, :arglists ([box])}, :source "(defn put-active? [box] (impl/active? (.-handler box)))\n"} {:sym MAX_DIRTY, :meta {}, :source "(def MAX_DIRTY 64)\n"} {:sym abort, :meta {:doc nil, :arglists ([this])}, :protocol MMC} {:sym MMC, :meta {:doc nil}, :methods (abort)} {:sym chan, :meta {:doc nil, :arglists [[buf] [buf xform] [buf xform exh]]}, :source "(defn\n chan\n ([buf] (chan buf nil))\n ([buf xform] (chan buf xform nil))\n ([buf xform exh]\n  (ManyToManyChannel.\n   (buffers/ring-buffer 32)\n   0\n   (buffers/ring-buffer 32)\n   0\n   buf\n   false\n   (let\n    [add! (if xform (xform impl/add!) impl/add!)]\n    (fn\n     ([buf] (try (add! buf) (catch :default t (handle buf exh t))))\n     ([buf val]\n      (try (add! buf val) (catch :default t (handle buf exh t)))))))))\n"}), cljs.core.async.impl.dispatch ({:sym tasks, :meta {}, :source "(def tasks (buffers/ring-buffer 32))\n"} {:sym running?, :meta {}, :source "(def running? false)\n"} {:sym queued?, :meta {}, :source "(def queued? false)\n"} {:sym TASK_BATCH_SIZE, :meta {}, :source "(def TASK_BATCH_SIZE 1024)\n"} {:sym process-messages, :meta {:doc nil, :arglists ([])}, :source "(defn\n process-messages\n []\n (set! running? true)\n (set! queued? false)\n (loop\n  [count 0]\n  (let\n   [m (.pop tasks)]\n   (when-not\n    (nil? m)\n    (m)\n    (when (< count TASK_BATCH_SIZE) (recur (inc count))))))\n (set! running? false)\n (when (> (.-length tasks) 0) (queue-dispatcher)))\n"} {:sym queue-dispatcher, :meta {:doc nil, :arglists ([])}, :source "(defn\n queue-dispatcher\n []\n (when-not\n  (and queued? running?)\n  (set! queued? true)\n  (goog.async.nextTick process-messages)))\n"} {:sym run, :meta {:doc nil, :arglists ([f])}, :source "(defn run [f] (.unbounded-unshift tasks f) (queue-dispatcher))\n"} {:sym queue-delay, :meta {:doc nil, :arglists ([f delay])}, :source "(defn queue-delay [f delay] (js/setTimeout f delay))\n"}), play-cljs.utils ({:sym update-opts, :meta {:doc nil, :arglists ([opts parent-opts defaults])}, :source "(defn\n update-opts\n [opts parent-opts defaults]\n (let\n  [parent-opts (merge defaults parent-opts)]\n  (->\n   (merge defaults (dissoc parent-opts :x :y) opts)\n   (update :x + (:x parent-opts))\n   (update :y + (:y parent-opts)))))\n"} {:sym basic-defaults, :meta {}, :source "(def basic-defaults {:x 0, :y 0, :scale-x 1, :scale-y 1})\n"} {:sym text-defaults, :meta {}, :source "(def\n text-defaults\n (merge\n  basic-defaults\n  {:size 32,\n   :font \"Helvetica\",\n   :halign :left,\n   :valign :baseline,\n   :leading 0,\n   :style :normal}))\n"} {:sym img-defaults, :meta {}, :source "(def img-defaults (merge basic-defaults {:sx 0, :sy 0}))\n"} {:sym rgb-defaults, :meta {}, :source "(def\n rgb-defaults\n (merge basic-defaults {:max-r 255, :max-g 255, :max-b 255, :max-a 1}))\n"} {:sym hsb-defaults, :meta {}, :source "(def\n hsb-defaults\n (merge basic-defaults {:max-h 360, :max-s 100, :max-b 100, :max-a 1}))\n"} {:sym halign->constant, :meta {:doc nil, :arglists ([renderer halign])}, :source "(defn\n halign->constant\n [renderer halign]\n (get\n  {:left (.-LEFT renderer),\n   :center (.-CENTER renderer),\n   :right (.-RIGHT renderer)}\n  halign))\n"} {:sym valign->constant, :meta {:doc nil, :arglists ([renderer valign])}, :source "(defn\n valign->constant\n [renderer valign]\n (get\n  {:top (.-TOP renderer),\n   :center (.-CENTER renderer),\n   :bottom (.-BOTTOM renderer),\n   :baseline (.-BASELINE renderer)}\n  valign))\n"} {:sym style->constant, :meta {:doc nil, :arglists ([renderer style])}, :source "(defn\n style->constant\n [renderer style]\n (get\n  {:normal (.-NORMAL renderer),\n   :italic (.-ITALIC renderer),\n   :bold (.-BOLD renderer)}\n  style))\n"}), cljs.core ({:sym sort-by, :meta {:doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :arglists [[keyfn coll] [keyfn comp coll]]}, :source "(defn\n sort-by\n \"Returns a sorted sequence of the items in coll, where the sort\\n   order is determined by comparing (keyfn item).  Comp can be\\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\\n   Comp defaults to compare.\"\n ([keyfn coll] (sort-by keyfn compare coll))\n ([keyfn comp coll]\n  (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))\n"} {:sym ITransientAssociative, :meta {:doc "Protocol for adding associativity to transient collections."}, :methods (-assoc!)} {:sym chunk-first, :meta {:doc nil, :arglists ([s])}, :source "(defn chunk-first [s] (-chunked-first s))\n"} {:sym m3-hash-int, :meta {:doc nil, :arglists ([in])}, :source "(defn\n m3-hash-int\n [in]\n (if\n  (zero? in)\n  in\n  (let [k1 (m3-mix-K1 in) h1 (m3-mix-H1 m3-seed k1)] (m3-fmix h1 4))))\n"} {:sym pr-str*, :meta {:doc "Support so that collections can implement toString without\n   loading all the printing machinery.", :arglists ([obj])}, :source "(defn\n pr-str*\n \"Support so that collections can implement toString without\\n   loading all the printing machinery.\"\n [obj]\n (let\n  [sb (StringBuffer.) writer (StringBufferWriter. sb)]\n  (-pr-writer obj writer (pr-opts))\n  (-flush writer)\n  (str sb)))\n"} {:sym tree-seq, :meta {:doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree.", :arglists ([branch? children root])}, :source "(defn\n tree-seq\n \"Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\\n  branch? must be a fn of one arg that returns true if passed a node\\n  that can have children (but may not).  children must be a fn of one\\n  arg that returns a sequence of the children. Will only be called on\\n  nodes for which branch? returns true. Root is the root node of the\\n  tree.\"\n [branch? children root]\n (let\n  [walk\n   (fn\n    walk\n    [node]\n    (lazy-seq\n     (cons node (when (branch? node) (mapcat walk (children node))))))]\n  (walk root)))\n"} {:sym unchecked-remainder-int, :meta {:doc nil, :arglists ([x n])}, :source "(defn\n unchecked-remainder-int\n [x n]\n (cljs.core/unchecked-remainder-int x n))\n"} {:sym seq, :meta {:doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings.", :arglists ([coll])}, :source "(defn\n seq\n \"Returns a seq on the collection. If the collection is\\n  empty, returns nil.  (seq nil) returns nil. seq also works on\\n  Strings.\"\n [coll]\n (when-not\n  (nil? coll)\n  (cond\n   (implements? ISeqable coll)\n   (-seq coll)\n   (array? coll)\n   (when-not (zero? (alength coll)) (IndexedSeq. coll 0 nil))\n   (string? coll)\n   (when-not (zero? (alength coll)) (IndexedSeq. coll 0 nil))\n   (native-satisfies? ISeqable coll)\n   (-seq coll)\n   :else\n   (throw (js/Error. (str coll \" is not ISeqable\"))))))\n"} {:sym reduce, :meta {:doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :arglists [[f coll] [f val coll]]}, :source "(defn\n reduce\n \"f should be a function of 2 arguments. If val is not supplied,\\n  returns the result of applying f to the first 2 items in coll, then\\n  applying f to that result and the 3rd item, etc. If coll contains no\\n  items, f must accept no arguments as well, and reduce returns the\\n  result of calling f with no arguments.  If coll has only 1 item, it\\n  is returned and f is not called.  If val is supplied, returns the\\n  result of applying f to val and the first item in coll, then\\n  applying f to that result and the 2nd item, etc. If coll contains no\\n  items, returns val and f is not called.\"\n ([f coll]\n  (cond\n   (implements? IReduce coll)\n   (-reduce coll f)\n   (array? coll)\n   (array-reduce coll f)\n   (string? coll)\n   (array-reduce coll f)\n   (native-satisfies? IReduce coll)\n   (-reduce coll f)\n   (iterable? coll)\n   (iter-reduce coll f)\n   :else\n   (seq-reduce f coll)))\n ([f val coll]\n  (cond\n   (implements? IReduce coll)\n   (-reduce coll f val)\n   (array? coll)\n   (array-reduce coll f val)\n   (string? coll)\n   (array-reduce coll f val)\n   (native-satisfies? IReduce coll)\n   (-reduce coll f val)\n   (iterable? coll)\n   (iter-reduce coll f val)\n   :else\n   (seq-reduce f val coll))))\n"} {:sym contains?, :meta {:doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", :arglists ([coll v])}, :source "(defn\n contains?\n \"Returns true if key is present in the given collection, otherwise\\n  returns false.  Note that for numerically indexed collections like\\n  vectors and arrays, this tests if the numeric key is within the\\n  range of indexes. 'contains?' operates constant or logarithmic time;\\n  it will not perform a linear search for a value.  See also 'some'.\"\n [coll v]\n (if\n  (identical? (get coll v lookup-sentinel) lookup-sentinel)\n  false\n  true))\n"} {:sym every?, :meta {:doc "Returns true if (pred x) is logical true for every x in coll, else\n  false.", :arglists ([pred coll])}, :source "(defn\n every?\n \"Returns true if (pred x) is logical true for every x in coll, else\\n  false.\"\n [pred coll]\n (cond\n  (nil? (seq coll))\n  true\n  (pred (first coll))\n  (recur pred (next coll))\n  :else\n  false))\n"} {:sym keep-indexed, :meta {:doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :arglists [[f] [f coll]]}, :source "(defn\n keep-indexed\n \"Returns a lazy sequence of the non-nil results of (f index item). Note,\\n  this means false return values will be included.  f must be free of\\n  side-effects.  Returns a stateful transducer when no collection is\\n  provided.\"\n ([f]\n  (fn\n   [rf]\n   (let\n    [ia (volatile! -1)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [i (vswap! ia inc) v (f i input)]\n       (if (nil? v) result (rf result v))))))))\n ([f coll]\n  (letfn\n   [(keepi\n     [idx coll]\n     (lazy-seq\n      (when-let\n       [s (seq coll)]\n       (if\n        (chunked-seq? s)\n        (let\n         [c (chunk-first s) size (count c) b (chunk-buffer size)]\n         (dotimes\n          [i size]\n          (let\n           [x (f (+ idx i) (-nth c i))]\n           (when-not (nil? x) (chunk-append b x))))\n         (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))\n        (let\n         [x (f idx (first s))]\n         (if\n          (nil? x)\n          (keepi (inc idx) (rest s))\n          (cons x (keepi (inc idx) (rest s)))))))))]\n   (keepi 0 coll))))\n"} {:sym subs, :meta {:doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :arglists [[s start] [s start end]]}, :source "(defn\n subs\n \"Returns the substring of s beginning at start inclusive, and ending\\n  at end (defaults to length of string), exclusive.\"\n ([s start] (.substring s start))\n ([s start end] (.substring s start end)))\n"} {:sym IFind, :meta {:doc "Protocol for implementing entry finding in collections."}, :methods (-find)} {:sym MODULE_URIS, :meta {}, :source "(def MODULE_URIS nil)\n"} {:sym take-last, :meta {:doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", :arglists ([n coll])}, :source "(defn\n take-last\n \"Returns a seq of the last n items in coll.  Depending on the type\\n  of coll may be no better than linear time.  For vectors, see also subvec.\"\n [n coll]\n (loop\n  [s (seq coll) lead (seq (drop n coll))]\n  (if lead (recur (next s) (next lead)) s)))\n"} {:sym bit-set, :meta {:doc "Set bit at index n", :arglists ([x n])}, :source "(defn bit-set \"Set bit at index n\" [x n] (cljs.core/bit-set x n))\n"} {:sym string-hash-cache-count, :meta {}, :source "(def string-hash-cache-count 0)\n"} {:sym qualified-keyword?, :meta {:doc "Return true if x is a keyword with a namespace", :arglists ([x])}, :source "(defn\n qualified-keyword?\n \"Return true if x is a keyword with a namespace\"\n [x]\n (boolean (and (keyword? x) (namespace x) true)))\n"} {:sym -with-meta, :meta {:doc "Returns a new object with value of o and metadata meta added to it.", :arglists ([o meta])}, :protocol IWithMeta} {:sym unchecked-subtract-int, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-subtract-int\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/unchecked-subtract-int x))\n ([x y] (cljs.core/unchecked-subtract-int x y))\n ([x y & more]\n  (reduce\n   unchecked-subtract-int\n   (cljs.core/unchecked-subtract-int x y)\n   more)))\n"} {:sym -iterator, :meta {:doc "Returns an iterator for coll.", :arglists ([coll])}, :protocol IIterable} {:sym *print-namespace-maps*, :meta {:doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax.\n\n  Defaults to false, but the REPL binds it to true."}, :source "(def *print-namespace-maps* false)\n"} {:sym first, :meta {:doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil.", :arglists ([coll])}, :source "(defn\n first\n \"Returns the first item in the collection. Calls seq on its\\n  argument. If coll is nil, returns nil.\"\n [coll]\n (when-not\n  (nil? coll)\n  (if\n   (implements? ISeq coll)\n   (-first coll)\n   (let [s (seq coll)] (when-not (nil? s) (-first s))))))\n"} {:sym native-satisfies?, :meta {:doc "Internal - do not use!", :arglists ([p x])}, :source "(defn\n native-satisfies?\n \"Internal - do not use!\"\n [p x]\n (let\n  [x (if (nil? x) nil x)]\n  (cond\n   (unchecked-get p (goog/typeOf x))\n   true\n   (unchecked-get p \"_\")\n   true\n   :else\n   false)))\n"} {:sym seq?, :meta {:doc "Return true if s satisfies ISeq", :arglists ([s])}, :source "(defn\n seq?\n \"Return true if s satisfies ISeq\"\n [s]\n (if (nil? s) false (satisfies? ISeq s)))\n"} {:sym -sorted-seq-from, :meta {:doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)", :arglists ([coll k ascending?])}, :protocol ISorted} {:sym inst-ms, :meta {:doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT", :arglists ([inst])}, :source "(defn\n inst-ms\n \"Return the number of milliseconds since January 1, 1970, 00:00:00 GMT\"\n [inst]\n (inst-ms* inst))\n"} {:sym iterate, :meta {:doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :arglists ([f x])}, :source "(defn\n iterate\n \"Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects\"\n {:added \"1.0\"}\n [f x]\n (cons x (lazy-seq (iterate f (f x)))))\n"} {:sym -empty, :meta {:doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty.", :arglists ([coll])}, :protocol IEmptyableCollection} {:sym ILookup, :meta {:doc "Protocol for looking up a value in a data structure."}, :methods (-lookup)} {:sym -chunked-rest, :meta {:doc "Return a new collection of coll with the first chunk removed.", :arglists ([coll])}, :protocol IChunkedSeq} {:sym fn?, :meta {:doc "Return true if f is a JavaScript function or satisfies the Fn protocol.", :arglists ([f])}, :source "(defn\n fn?\n \"Return true if f is a JavaScript function or satisfies the Fn protocol.\"\n [f]\n (or (goog/isFunction f) (satisfies? Fn f)))\n"} {:sym -assoc, :meta {:doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it.", :arglists ([coll k v])}, :protocol IAssociative} {:sym keyword-identical?, :meta {:doc "Efficient test to determine that two keywords are identical.", :arglists ([x y])}, :source "(defn\n keyword-identical?\n \"Efficient test to determine that two keywords are identical.\"\n [x y]\n (if\n  (identical? x y)\n  true\n  (if\n   (and (keyword? x) (keyword? y))\n   (identical? (.-fqn x) (.-fqn y))\n   false)))\n"} {:sym *print-err-fn*, :meta {:doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed."}, :source "(defonce *print-err-fn* nil)\n"} {:sym dissoc, :meta {:doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :arglists [[coll] [coll k] [coll k & ks]]}, :source "(defn\n dissoc\n \"dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\\n  that does not contain a mapping for key(s).\"\n ([coll] coll)\n ([coll k] (when-not (nil? coll) (-dissoc coll k)))\n ([coll k & ks]\n  (when-not\n   (nil? coll)\n   (let\n    [ret (dissoc coll k)]\n    (if ks (recur ret (first ks) (next ks)) ret)))))\n"} {:sym atom, :meta {:doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will be come the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an Error.  If either of these error conditions\n  occur, then the value of the atom will not change.", :arglists [[x] [x & {:keys [meta validator]}]]}, :source "(defn\n atom\n \"Creates and returns an Atom with an initial value of x and zero or\\n  more options (in any order):\\n\\n  :meta metadata-map\\n\\n  :validator validate-fn\\n\\n  If metadata-map is supplied, it will be come the metadata on the\\n  atom. validate-fn must be nil or a side-effect-free fn of one\\n  argument, which will be passed the intended new state on any state\\n  change. If the new state is unacceptable, the validate-fn should\\n  return false or throw an Error.  If either of these error conditions\\n  occur, then the value of the atom will not change.\"\n ([x] (Atom. x nil nil nil))\n ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))\n"} {:sym bit-shift-right, :meta {:doc "Bitwise shift right", :arglists ([x n])}, :source "(defn\n bit-shift-right\n \"Bitwise shift right\"\n [x n]\n (cljs.core/bit-shift-right x n))\n"} {:sym *clojurescript-version*, :meta {}, :source "(def *clojurescript-version* \"1.9.946\")\n"} {:sym -first, :meta {:doc "Returns the first item in the collection coll. Used by cljs.core/first.", :arglists ([coll])}, :protocol ISeq} {:sym peek, :meta {:doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", :arglists ([coll])}, :source "(defn\n peek\n \"For a list or queue, same as first, for a vector, same as, but much\\n  more efficient than, last. If the collection is empty, returns nil.\"\n [coll]\n (when-not (nil? coll) (-peek coll)))\n"} {:sym IKVReduce, :meta {:doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv."}, :methods (-kv-reduce)} {:sym aget, :meta {:doc "Returns the value at the index/indices. Works on JavaScript arrays.", :arglists [[array idx] [array idx & idxs]]}, :source "(defn\n aget\n \"Returns the value at the index/indices. Works on JavaScript arrays.\"\n ([array idx] (cljs.core/aget array idx))\n ([array idx & idxs] (apply aget (aget array idx) idxs)))\n"} {:sym -write, :meta {:doc "Writes s with writer and returns the result.", :arglists ([writer s])}, :protocol IWriter} {:sym iter, :meta {:doc nil, :arglists ([coll])}, :source "(defn\n iter\n [coll]\n (cond\n  (iterable? coll)\n  (-iterator coll)\n  (nil? coll)\n  (nil-iter)\n  (string? coll)\n  (string-iter coll)\n  (array? coll)\n  (array-iter coll)\n  (seqable? coll)\n  (seq-iter coll)\n  :else\n  (throw (js/Error. (str \"Cannot create iterator from \" coll)))))\n"} {:sym last, :meta {:doc "Return the last item in coll, in linear time", :arglists ([s])}, :source "(defn\n last\n \"Return the last item in coll, in linear time\"\n [s]\n (let [sn (next s)] (if-not (nil? sn) (recur sn) (first s))))\n"} {:sym namespace, :meta {:doc "Returns the namespace String of a symbol or keyword, or nil if not present.", :arglists ([x])}, :source "(defn\n namespace\n \"Returns the namespace String of a symbol or keyword, or nil if not present.\"\n [x]\n (if\n  (implements? INamed x)\n  (-namespace x)\n  (throw (js/Error. (str \"Doesn't support namespace: \" x)))))\n"} {:sym -conj, :meta {:doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)", :arglists ([coll o])}, :protocol ICollection} {:sym =, :meta {:doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n =\n \"Equality. Returns true if x equals y, false if not. Compares\\n  numbers and collections in a type-independent manner.  Clojure's immutable data\\n  structures define -equiv (and thus =) as a value, not an identity,\\n  comparison.\"\n ([x] true)\n ([x y] (if (nil? x) (nil? y) (or (identical? x y) (-equiv x y))))\n ([x y & more]\n  (if\n   (= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (= y (first more)))\n   false)))\n"} {:sym ITransientMap, :meta {:doc "Protocol for adding mapping functionality to transient collections."}, :methods (-dissoc!)} {:sym take, :meta {:doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :arglists [[n] [n coll]]}, :source "(defn\n take\n \"Returns a lazy sequence of the first n items in coll, or all items if\\n  there are fewer than n.  Returns a stateful transducer when\\n  no collection is provided.\"\n ([n]\n  {:pre [(number? n)]}\n  (fn\n   [rf]\n   (let\n    [na (volatile! n)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [n\n        @na\n        nn\n        (vswap! na dec)\n        result\n        (if (pos? n) (rf result input) result)]\n       (if (not (pos? nn)) (ensure-reduced result) result)))))))\n ([n coll]\n  {:pre [(number? n)]}\n  (lazy-seq\n   (when\n    (pos? n)\n    (when-let\n     [s (seq coll)]\n     (cons (first s) (take (dec n) (rest s))))))))\n"} {:sym vector?, :meta {:doc "Return true if x satisfies IVector", :arglists ([x])}, :source "(defn\n vector?\n \"Return true if x satisfies IVector\"\n [x]\n (satisfies? IVector x))\n"} {:sym boolean, :meta {:doc "Coerce to boolean", :arglists ([x])}, :source "(defn\n boolean\n \"Coerce to boolean\"\n [x]\n (cond (nil? x) false (false? x) false :else true))\n"} {:sym IChunk, :meta {:doc "Protocol for accessing the items of a chunk."}, :methods (-drop-first)} {:sym bit-shift-left, :meta {:doc "Bitwise shift left", :arglists ([x n])}, :source "(defn\n bit-shift-left\n \"Bitwise shift left\"\n [x n]\n (cljs.core/bit-shift-left x n))\n"} {:sym any?, :meta {:doc "Returns true if given any argument.", :arglists ([x])}, :source "(defn any? \"Returns true if given any argument.\" [x] true)\n"} {:sym aclone, :meta {:doc "Returns a javascript array, cloned from the passed in array", :arglists ([arr])}, :source "(defn\n aclone\n \"Returns a javascript array, cloned from the passed in array\"\n [arr]\n (let\n  [len (alength arr) new-arr (make-array len)]\n  (dotimes [i len] (aset new-arr i (aget arr i)))\n  new-arr))\n"} {:sym vreset!, :meta {:doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", :arglists ([vol newval])}, :source "(defn\n vreset!\n \"Sets the value of volatile to newval without regard for the\\n   current value. Returns newval.\"\n [vol newval]\n (-vreset! vol newval))\n"} {:sym chunk, :meta {:doc nil, :arglists ([b])}, :source "(defn chunk [b] (.chunk b))\n"} {:sym dec, :meta {:doc "Returns a number one less than num.", :arglists ([x])}, :source "(defn dec \"Returns a number one less than num.\" [x] (- x 1))\n"} {:sym APersistentVector, :meta {:doc "Marker protocol"}, :methods ()} {:sym map, :meta {:doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :arglists [[f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]]}, :source "(defn\n map\n \"Returns a lazy sequence consisting of the result of applying f to\\n  the set of first items of each coll, followed by applying f to the\\n  set of second items in each coll, until any one of the colls is\\n  exhausted.  Any remaining items in other colls are ignored. Function\\n  f should accept number-of-colls arguments. Returns a transducer when\\n  no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input] (rf result (f input)))\n    ([result input & inputs] (rf result (apply f input inputs))))))\n ([f coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes [i size] (chunk-append b (f (-nth c i))))\n      (chunk-cons (chunk b) (map f (chunk-rest s))))\n     (cons (f (first s)) (map f (rest s)))))))\n ([f c1 c2]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2)]\n    (when\n     (and s1 s2)\n     (cons (f (first s1) (first s2)) (map f (rest s1) (rest s2)))))))\n ([f c1 c2 c3]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n    (when\n     (and s1 s2 s3)\n     (cons\n      (f (first s1) (first s2) (first s3))\n      (map f (rest s1) (rest s2) (rest s3)))))))\n ([f c1 c2 c3 & colls]\n  (let\n   [step\n    (fn\n     step\n     [cs]\n     (lazy-seq\n      (let\n       [ss (map seq cs)]\n       (when\n        (every? identity ss)\n        (cons (map first ss) (step (map rest ss)))))))]\n   (map\n    (fn* [p1__18468#] (apply f p1__18468#))\n    (step (conj colls c3 c2 c1))))))\n"} {:sym <, :meta {:doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n <\n \"Returns non-nil if nums are in monotonically increasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/< x y))\n ([x y & more]\n  (if\n   (cljs.core/< x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/< y (first more)))\n   false)))\n"} {:sym rest, :meta {:doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", :arglists ([coll])}, :source "(defn\n rest\n \"Returns a possibly empty seq of the items after the first. Calls seq on its\\n  argument.\"\n [coll]\n (if-not\n  (nil? coll)\n  (if\n   (implements? ISeq coll)\n   (-rest coll)\n   (let [s (seq coll)] (if s (-rest s) ())))\n  ()))\n"} {:sym -drop-first, :meta {:doc "Return a new chunk of coll with the first item removed.", :arglists ([coll])}, :protocol IChunk} {:sym boolean?, :meta {:doc "Return true if x is a Boolean", :arglists ([x])}, :source "(defn\n boolean?\n \"Return true if x is a Boolean\"\n [x]\n (or (cljs.core/true? x) (cljs.core/false? x)))\n"} {:sym -clone, :meta {:doc "Creates a clone of value.", :arglists ([value])}, :protocol ICloneable} {:sym char?, :meta {:doc "Returns true if x is a JavaScript string of length one.", :arglists ([x])}, :source "(defn\n char?\n \"Returns true if x is a JavaScript string of length one.\"\n [x]\n (and (string? x) (== 1 (.-length x))))\n"} {:sym -reduce, :meta {:doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.", :arglists ([coll f] [coll f start])}, :protocol IReduce} {:sym -count, :meta {:doc "Calculates the count of coll in constant time. Used by cljs.core/count.", :arglists ([coll])}, :protocol ICounted} {:sym swap-vals!, :meta {:doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", :arglists [[a f] [a f x] [a f x y] [a f x y & more]]}, :source "(defn\n swap-vals!\n \"Atomically swaps the value of atom to be:\\n  (apply f current-value-of-atom args). Note that f may be called\\n  multiple times, and thus should be free of side effects.\\n  Returns [old new], the value of the atom before and after the swap.\"\n {:added \"1.9\"}\n ([a f] (reset-vals! a (f (.-state a))))\n ([a f x] (reset-vals! a (f (.-state a) x)))\n ([a f x y] (reset-vals! a (f (.-state a) x y)))\n ([a f x y & more] (reset-vals! a (apply f (.-state a) x y more))))\n"} {:sym keep, :meta {:doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :arglists [[f] [f coll]]}, :source "(defn\n keep\n \"Returns a lazy sequence of the non-nil results of (f item). Note,\\n  this means false return values will be included.  f must be free of\\n  side-effects.  Returns a transducer when no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input]\n     (let [v (f input)] (if (nil? v) result (rf result v)))))))\n ([f coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes\n       [i size]\n       (let [x (f (-nth c i))] (when-not (nil? x) (chunk-append b x))))\n      (chunk-cons (chunk b) (keep f (chunk-rest s))))\n     (let\n      [x (f (first s))]\n      (if (nil? x) (keep f (rest s)) (cons x (keep f (rest s))))))))))\n"} {:sym char, :meta {:doc "Coerce to char", :arglists ([x])}, :source "(defn\n char\n \"Coerce to char\"\n [x]\n (cond\n  (number? x)\n  (.fromCharCode js/String x)\n  (and (string? x) (== (.-length x) 1))\n  x\n  :else\n  (throw (js/Error. \"Argument to char must be a character or number\"))))\n"} {:sym mapcat, :meta {:doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", :arglists [[f] [f & colls]]}, :source "(defn\n mapcat\n \"Returns the result of applying concat to the result of applying map\\n  to f and colls.  Thus function f should return a collection. Returns\\n  a transducer when no collections are provided\"\n {:added \"1.0\", :static true}\n ([f] (comp (map f) cat))\n ([f & colls] (apply concat (apply map f colls))))\n"} {:sym unchecked-long, :meta {:doc "Coerce to long by stripping decimal places. Identical to `int'.", :arglists ([x])}, :source "(defn\n unchecked-long\n \"Coerce to long by stripping decimal places. Identical to `int'.\"\n [x]\n (fix x))\n"} {:sym m3-seed, :meta {}, :source "(def m3-seed 0)\n"} {:sym some?, :meta {:doc "Returns true if x is not nil, false otherwise.", :arglists ([x])}, :source "(defn\n some?\n \"Returns true if x is not nil, false otherwise.\"\n [x]\n (not (nil? x)))\n"} {:sym unchecked-negate, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-negate [x] (cljs.core/unchecked-negate x))\n"} {:sym symbol-identical?, :meta {:doc "Efficient test to determine that two symbols are identical.", :arglists ([x y])}, :source "(defn\n symbol-identical?\n \"Efficient test to determine that two symbols are identical.\"\n [x y]\n (if\n  (identical? x y)\n  true\n  (if\n   (and (symbol? x) (symbol? y))\n   (identical? (.-str x) (.-str y))\n   false)))\n"} {:sym *command-line-args*, :meta {:doc "A sequence of the supplied command line arguments, or nil if\n  none were supplied"}, :source "(def *command-line-args* nil)\n"} {:sym reverse, :meta {:doc "Returns a seq of the items in coll in reverse order. Not lazy.", :arglists ([coll])}, :source "(defn\n reverse\n \"Returns a seq of the items in coll in reverse order. Not lazy.\"\n [coll]\n (if (reversible? coll) (rseq coll) (reduce conj () coll)))\n"} {:sym inst?, :meta {:doc "Return true if x satisfies Inst", :arglists ([x])}, :source "(defn inst? \"Return true if x satisfies Inst\" [x] (satisfies? Inst x))\n"} {:sym bit-count, :meta {:doc "Counts the number of bits set in n", :arglists ([v])}, :source "(defn\n bit-count\n \"Counts the number of bits set in n\"\n [v]\n (let\n  [v\n   (- v (bit-and (bit-shift-right v 1) 1431655765))\n   v\n   (+ (bit-and v 858993459) (bit-and (bit-shift-right v 2) 858993459))]\n  (bit-shift-right\n   (* (bit-and (+ v (bit-shift-right v 4)) 252645135) 16843009)\n   24)))\n"} {:sym sort, :meta {:doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :arglists [[coll] [comp coll]]}, :source "(defn\n sort\n \"Returns a sorted sequence of the items in coll. Comp can be\\n   boolean-valued comparison function, or a -/0/+ valued comparator.\\n   Comp defaults to compare.\"\n ([coll] (sort compare coll))\n ([comp coll]\n  (if\n   (seq coll)\n   (let\n    [a (to-array coll)]\n    (garray/stableSort a (fn->comparator comp))\n    (seq a))\n   ())))\n"} {:sym unchecked-inc-int, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-inc-int [x] (cljs.core/unchecked-inc-int x))\n"} {:sym -compare, :meta {:doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.", :arglists ([x y])}, :protocol IComparable} {:sym map-indexed, :meta {:doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", :arglists [[f] [f coll]]}, :source "(defn\n map-indexed\n \"Returns a lazy sequence consisting of the result of applying f to 0\\n  and the first item of coll, followed by applying f to 1 and the second\\n  item in coll, etc, until coll is exhausted. Thus function f should\\n  accept 2 arguments, index and item. Returns a stateful transducer when\\n  no collection is provided.\"\n ([f]\n  (fn\n   [rf]\n   (let\n    [i (volatile! -1)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input] (rf result (f (vswap! i inc) input)))))))\n ([f coll]\n  (letfn\n   [(mapi\n     [idx coll]\n     (lazy-seq\n      (when-let\n       [s (seq coll)]\n       (if\n        (chunked-seq? s)\n        (let\n         [c (chunk-first s) size (count c) b (chunk-buffer size)]\n         (dotimes [i size] (chunk-append b (f (+ idx i) (-nth c i))))\n         (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))\n        (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]\n   (mapi 0 coll))))\n"} {:sym comp, :meta {:doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :arglists [[] [f] [f g] [f g h] [f1 f2 f3 & fs]]}, :source "(defn\n comp\n \"Takes a set of functions and returns a fn that is the composition\\n  of those fns.  The returned fn takes a variable number of args,\\n  applies the rightmost of fns to the args, the next\\n  fn (right-to-left) to the result, etc.\"\n ([] identity)\n ([f] f)\n ([f g]\n  (fn\n   ([] (f (g)))\n   ([x] (f (g x)))\n   ([x y] (f (g x y)))\n   ([x y z] (f (g x y z)))\n   ([x y z & args] (f (apply g x y z args)))))\n ([f g h]\n  (fn\n   ([] (f (g (h))))\n   ([x] (f (g (h x))))\n   ([x y] (f (g (h x y))))\n   ([x y z] (f (g (h x y z))))\n   ([x y z & args] (f (g (apply h x y z args))))))\n ([f1 f2 f3 & fs]\n  (let\n   [fs (reverse (list* f1 f2 f3 fs))]\n   (fn\n    [& args]\n    (loop\n     [ret (apply (first fs) args) fs (next fs)]\n     (if fs (recur ((first fs) ret) (next fs)) ret))))))\n"} {:sym array-chunk, :meta {:doc nil, :arglists [[arr] [arr off] [arr off end]]}, :source "(defn\n array-chunk\n ([arr] (ArrayChunk. arr 0 (alength arr)))\n ([arr off] (ArrayChunk. arr off (alength arr)))\n ([arr off end] (ArrayChunk. arr off end)))\n"} {:sym bit-shift-right-zero-fill, :meta {:doc "DEPRECATED: Bitwise shift right with zero fill", :arglists ([x n])}, :source "(defn\n bit-shift-right-zero-fill\n \"DEPRECATED: Bitwise shift right with zero fill\"\n [x n]\n (cljs.core/bit-shift-right-zero-fill x n))\n"} {:sym -as-transient, :meta {:doc "Returns a new, transient version of the collection, in constant time.", :arglists ([coll])}, :protocol IEditableCollection} {:sym simple-symbol?, :meta {:doc "Return true if x is a symbol without a namespace", :arglists ([x])}, :source "(defn\n simple-symbol?\n \"Return true if x is a symbol without a namespace\"\n [x]\n (and (symbol? x) (nil? (namespace x))))\n"} {:sym IIndexed, :meta {:doc "Protocol for collections to provide indexed-based access to their items."}, :methods (-nth)} {:sym disj, :meta {:doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :arglists [[coll] [coll k] [coll k & ks]]}, :source "(defn\n disj\n \"disj[oin]. Returns a new set of the same (hashed/sorted) type, that\\n  does not contain key(s).\"\n ([coll] coll)\n ([coll k] (when-not (nil? coll) (-disjoin coll k)))\n ([coll k & ks]\n  (when-not\n   (nil? coll)\n   (let\n    [ret (disj coll k)]\n    (if ks (recur ret (first ks) (next ks)) ret)))))\n"} {:sym IPrintWithWriter, :meta {:doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append."}, :methods (-pr-writer)} {:sym IVector, :meta {:doc "Protocol for adding vector functionality to collections."}, :methods (-assoc-n)} {:sym IIterable, :meta {:doc "Protocol for iterating over a collection."}, :methods (-iterator)} {:sym cons, :meta {:doc "Returns a new seq where x is the first element and coll is the rest.", :arglists ([x coll])}, :source "(defn\n cons\n \"Returns a new seq where x is the first element and coll is the rest.\"\n [x coll]\n (if\n  (or (nil? coll) (implements? ISeq coll))\n  (Cons. nil x coll nil)\n  (Cons. nil x (seq coll) nil)))\n"} {:sym floats, :meta {:doc nil, :arglists ([x])}, :source "(defn floats [x] x)\n"} {:sym pos?, :meta {:doc "Returns true if num is greater than zero, else false", :arglists ([x])}, :source "(defn\n pos?\n \"Returns true if num is greater than zero, else false\"\n [x]\n (cljs.core/pos? x))\n"} {:sym fnil, :meta {:doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :arglists [[f x] [f x y] [f x y z]]}, :source "(defn\n fnil\n \"Takes a function f, and returns a function that calls f, replacing\\n  a nil first argument to f with the supplied value x. Higher arity\\n  versions can replace arguments in the second and third\\n  positions (y, z). Note that the function f can take any number of\\n  arguments, not just the one(s) being nil-patched.\"\n ([f x]\n  (fn\n   ([a] (f (if (nil? a) x a)))\n   ([a b] (f (if (nil? a) x a) b))\n   ([a b c] (f (if (nil? a) x a) b c))\n   ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n ([f x y]\n  (fn\n   ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n   ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n   ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n ([f x y z]\n  (fn\n   ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n   ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n   ([a b c & ds]\n    (apply\n     f\n     (if (nil? a) x a)\n     (if (nil? b) y b)\n     (if (nil? c) z c)\n     ds)))))\n"} {:sym nthrest, :meta {:doc "Returns the nth rest of coll, coll when n is 0.", :arglists ([coll n])}, :source "(defn\n nthrest\n \"Returns the nth rest of coll, coll when n is 0.\"\n [coll n]\n (loop\n  [n n xs coll]\n  (if (and (pos? n) (seq xs)) (recur (dec n) (rest xs)) xs)))\n"} {:sym *warn-on-infer*, :meta {}, :source "(def *warn-on-infer* false)\n"} {:sym -find, :meta {:doc "Returns the map entry for key, or nil if key not present.", :arglists ([coll k])}, :protocol IFind} {:sym sequential?, :meta {:doc "Returns true if coll satisfies ISequential", :arglists ([x])}, :source "(defn\n sequential?\n \"Returns true if coll satisfies ISequential\"\n [x]\n (satisfies? ISequential x))\n"} {:sym m3-mix-H1, :meta {:doc nil, :arglists ([h1 k1])}, :source "(defn\n m3-mix-H1\n [h1 k1]\n (int\n  (->\n   (int h1)\n   (bit-xor (int k1))\n   (int-rotate-left 13)\n   (imul 5)\n   (+ (int 3864292196)))))\n"} {:sym prim-seq, :meta {:doc "Create seq from a primitive JavaScript Array-like.", :arglists [[prim] [prim i]]}, :source "(defn\n prim-seq\n \"Create seq from a primitive JavaScript Array-like.\"\n ([prim] (prim-seq prim 0))\n ([prim i] (when (< i (alength prim)) (IndexedSeq. prim i nil))))\n"} {:sym *print-level*, :meta {:doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit."}, :source "(def *print-level* nil)\n"} {:sym shuffle, :meta {:doc "Return a random permutation of coll", :arglists ([coll])}, :source "(defn\n shuffle\n \"Return a random permutation of coll\"\n [coll]\n (let [a (to-array coll)] (garray/shuffle a) (vec a)))\n"} {:sym hash-keyword, :meta {:doc nil, :arglists ([k])}, :source "(defn hash-keyword [k] (int (+ (hash-symbol k) 2654435769)))\n"} {:sym find, :meta {:doc "Returns the map entry for key, or nil if key not present.", :arglists ([coll k])}, :source "(defn\n find\n \"Returns the map entry for key, or nil if key not present.\"\n [coll k]\n (if\n  (ifind? coll)\n  (-find coll k)\n  (when\n   (and (not (nil? coll)) (associative? coll) (contains? coll k))\n   [k (get coll k)])))\n"} {:sym alength, :meta {:doc "Returns the length of the array. Works on arrays of all types.", :arglists ([array])}, :source "(defn\n alength\n \"Returns the length of the array. Works on arrays of all types.\"\n [array]\n (cljs.core/alength array))\n"} {:sym bit-xor, :meta {:doc "Bitwise exclusive or", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-xor\n \"Bitwise exclusive or\"\n ([x y] (cljs.core/bit-xor x y))\n ([x y & more] (reduce bit-xor (cljs.core/bit-xor x y) more)))\n"} {:sym unsigned-bit-shift-right, :meta {:doc "Bitwise shift right with zero fill", :arglists ([x n])}, :source "(defn\n unsigned-bit-shift-right\n \"Bitwise shift right with zero fill\"\n [x n]\n (cljs.core/unsigned-bit-shift-right x n))\n"} {:sym neg?, :meta {:doc "Returns true if num is less than zero, else false", :arglists ([x])}, :source "(defn\n neg?\n \"Returns true if num is less than zero, else false\"\n [x]\n (cljs.core/neg? x))\n"} {:sym js-invoke, :meta {:doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :arglists ([obj s & args])}, :source "(defn\n js-invoke\n \"Invoke JavaScript object method via string. Needed when the\\n  string is not a valid unquoted property name.\"\n [obj s & args]\n (.apply (unchecked-get obj s) obj (into-array args)))\n"} {:sym m3-mix-K1, :meta {:doc nil, :arglists ([k1])}, :source "(defn\n m3-mix-K1\n [k1]\n (-> (int k1) (imul m3-C1) (int-rotate-left 15) (imul m3-C2)))\n"} {:sym unchecked-float, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-float [x] x)\n"} {:sym undefined?, :meta {:doc "Returns true if x identical to the JavaScript undefined value.", :arglists ([x])}, :source "(defn\n undefined?\n \"Returns true if x identical to the JavaScript undefined value.\"\n [x]\n (cljs.core/undefined? x))\n"} {:sym IMeta, :meta {:doc "Protocol for accessing the metadata of an object."}, :methods (-meta)} {:sym reduced?, :meta {:doc "Returns true if x is the result of a call to reduced", :arglists ([r])}, :source "(defn\n reduced?\n \"Returns true if x is the result of a call to reduced\"\n [r]\n (instance? Reduced r))\n"} {:sym disj!, :meta {:doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :arglists [[tcoll val] [tcoll val & vals]]}, :source "(defn\n disj!\n \"disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\\n  does not contain key(s).\"\n ([tcoll val] (-disjoin! tcoll val))\n ([tcoll val & vals]\n  (let\n   [ntcoll (-disjoin! tcoll val)]\n   (if vals (recur ntcoll (first vals) (next vals)) ntcoll))))\n"} {:sym -lookup, :meta {:doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.", :arglists ([o k] [o k not-found])}, :protocol ILookup} {:sym float?, :meta {:doc "Returns true for JavaScript numbers, false otherwise.", :arglists ([x])}, :source "(defn\n float?\n \"Returns true for JavaScript numbers, false otherwise.\"\n [x]\n (number? x))\n"} {:sym ICloneable, :meta {:doc "Protocol for cloning a value."}, :methods (-clone)} {:sym booleans, :meta {:doc nil, :arglists ([x])}, :source "(defn booleans [x] x)\n"} {:sym int-array, :meta {:doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n int-array\n \"Creates an array of ints. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (int-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym set?, :meta {:doc "Returns true if x satisfies ISet", :arglists ([x])}, :source "(defn\n set?\n \"Returns true if x satisfies ISet\"\n [x]\n (if (nil? x) false (satisfies? ISet x)))\n"} {:sym iterable?, :meta {:doc "Return true if x implements IIterable protocol.", :arglists ([x])}, :source "(defn\n iterable?\n \"Return true if x implements IIterable protocol.\"\n [x]\n (satisfies? IIterable x))\n"} {:sym -pr-writer, :meta {:doc nil, :arglists ([o writer opts])}, :protocol IPrintWithWriter} {:sym vary-meta, :meta {:doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :arglists [[obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]]}, :source "(defn\n vary-meta\n \"Returns an object of the same type and value as obj, with\\n  (apply f (meta obj) args) as its metadata.\"\n ([obj f] (with-meta obj (f (meta obj))))\n ([obj f a] (with-meta obj (f (meta obj) a)))\n ([obj f a b] (with-meta obj (f (meta obj) a b)))\n ([obj f a b c] (with-meta obj (f (meta obj) a b c)))\n ([obj f a b c d] (with-meta obj (f (meta obj) a b c d)))\n ([obj f a b c d & args]\n  (with-meta obj (apply f (meta obj) a b c d args))))\n"} {:sym INext, :meta {:doc "Protocol for accessing the next items of a collection."}, :methods (-next)} {:sym is_proto_, :meta {:doc nil, :arglists ([x])}, :source "(defn is_proto_ [x] (identical? (.-prototype (.-constructor x)) x))\n"} {:sym ICounted, :meta {:doc "Protocol for adding the ability to count a collection in constant time."}, :methods (-count)} {:sym IMapEntry, :meta {:doc "Protocol for examining a map entry."}, :methods (-key -val)} {:sym <=, :meta {:doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n <=\n \"Returns non-nil if nums are in monotonically non-decreasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/<= x y))\n ([x y & more]\n  (if\n   (cljs.core/<= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/<= y (first more)))\n   false)))\n"} {:sym MODULE_INFOS, :meta {}, :source "(def MODULE_INFOS nil)\n"} {:sym conj!, :meta {:doc "Adds val to the transient collection, and return tcoll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :arglists [[] [tcoll] [tcoll val] [tcoll val & vals]]}, :source "(defn\n conj!\n \"Adds val to the transient collection, and return tcoll. The 'addition'\\n  may happen at different 'places' depending on the concrete type.\"\n ([] (transient []))\n ([tcoll] tcoll)\n ([tcoll val] (-conj! tcoll val))\n ([tcoll val & vals]\n  (let\n   [ntcoll (-conj! tcoll val)]\n   (if vals (recur ntcoll (first vals) (next vals)) ntcoll))))\n"} {:sym -pop, :meta {:doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.", :arglists ([coll])}, :protocol IStack} {:sym repeatedly, :meta {:doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :arglists [[f] [n f]]}, :source "(defn\n repeatedly\n \"Takes a function of no args, presumably with side effects, and\\n  returns an infinite (or length n if supplied) lazy sequence of calls\\n  to it\"\n ([f] (lazy-seq (cons (f) (repeatedly f))))\n ([n f] (take n (repeatedly f))))\n"} {:sym reset-vals!, :meta {:doc "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", :arglists ([a new-value])}, :source "(defn\n reset-vals!\n \"Sets the value of atom to newval. Returns [old new], the value of the\\n   atom before and after the reset.\"\n {:added \"1.9\"}\n [a new-value]\n (let\n  [validate (.-validator a)]\n  (when-not\n   (nil? validate)\n   (when-not\n    (validate new-value)\n    (throw (js/Error. \"Validator rejected reference state\"))))\n  (let\n   [old-value (.-state a)]\n   (set! (.-state a) new-value)\n   (when-not\n    (nil? (.-watches a))\n    (-notify-watches a old-value new-value))\n   [old-value new-value])))\n"} {:sym IStack, :meta {:doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures."}, :methods (-peek -pop)} {:sym -remove-watch, :meta {:doc "Removes watcher that corresponds to key from this.", :arglists ([this key])}, :protocol IWatchable} {:sym IVolatile, :meta {:doc "Protocol for adding volatile functionality."}, :methods (-vreset!)} {:sym remove, :meta {:doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n remove\n \"Returns a lazy sequence of the items in coll for which\\n  (pred item) returns false. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\"\n ([pred] (filter (complement pred)))\n ([pred coll] (filter (complement pred) coll)))\n"} {:sym *, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n *\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/* x y))\n ([x y & more] (reduce * (cljs.core/* x y) more)))\n"} {:sym min, :meta {:doc "Returns the least of the nums.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n min\n \"Returns the least of the nums.\"\n ([x] x)\n ([x y] (cljs.core/min x y))\n ([x y & more] (reduce min (cljs.core/min x y) more)))\n"} {:sym -persistent!, :meta {:doc "Creates a persistent data structure from tcoll and returns it.", :arglists ([tcoll])}, :protocol ITransientCollection} {:sym -nth, :meta {:doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.", :arglists ([coll n] [coll n not-found])}, :protocol IIndexed} {:sym pop!, :meta {:doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll", :arglists ([tcoll])}, :source "(defn\n pop!\n \"Removes the last item from a transient vector. If\\n  the collection is empty, throws an exception. Returns tcoll\"\n [tcoll]\n (-pop! tcoll))\n"} {:sym chunk-append, :meta {:doc nil, :arglists ([b x])}, :source "(defn chunk-append [b x] (.add b x))\n"} {:sym *unchecked-arrays*, :meta {}, :source "(def *unchecked-arrays* false)\n"} {:sym IReversible, :meta {:doc "Protocol for reversing a seq."}, :methods (-rseq)} {:sym reversible?, :meta {:doc "Returns true if coll satisfies? IReversible.", :arglists ([coll])}, :source "(defn\n reversible?\n \"Returns true if coll satisfies? IReversible.\"\n [coll]\n (satisfies? IReversible coll))\n"} {:sym -realized?, :meta {:doc "Returns true if a value for x has been produced, false otherwise.", :arglists ([x])}, :protocol IPending} {:sym -add-watch, :meta {:doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.", :arglists ([this key f])}, :protocol IWatchable} {:sym -deref-with-timeout, :meta {:doc nil, :arglists ([o msec timeout-val])}, :protocol IDerefWithTimeout} {:sym conj, :meta {:doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.", :arglists [[] [coll] [coll x] [coll x & xs]]}, :source "(defn\n conj\n \"conj[oin]. Returns a new collection with the xs\\n  'added'. (conj nil item) returns (item).  The 'addition' may\\n  happen at different 'places' depending on the concrete type.\"\n ([] [])\n ([coll] coll)\n ([coll x] (if-not (nil? coll) (-conj coll x) (list x)))\n ([coll x & xs]\n  (if xs (recur (conj coll x) (first xs) (next xs)) (conj coll x))))\n"} {:sym -sorted-seq, :meta {:doc "Returns a sorted seq from coll in either ascending or descending order.", :arglists ([coll ascending?])}, :protocol ISorted} {:sym transduce, :meta {:doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :arglists [[xform f coll] [xform f init coll]]}, :source "(defn\n transduce\n \"reduce with a transformation of f (xf). If init is not\\n  supplied, (f) will be called to produce it. f should be a reducing\\n  step function that accepts both 1 and 2 arguments, if it accepts\\n  only 2 you can add the arity-1 with 'completing'. Returns the result\\n  of applying (the transformed) xf to init and the first item in coll,\\n  then applying xf to that result and the 2nd item, etc. If coll\\n  contains no items, returns init and f is not called. Note that\\n  certain transforms may inject or skip items.\"\n ([xform f coll] (transduce xform f (f) coll))\n ([xform f init coll]\n  (let [f (xform f) ret (reduce f init coll)] (f ret))))\n"} {:sym -swap!, :meta {:doc "Swaps the value of o to be (apply f current-value-of-atom args).", :arglists ([o f] [o f a] [o f a b] [o f a b xs])}, :protocol ISwap} {:sym *print-length*, :meta {:doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit."}, :source "(def *print-length* nil)\n"} {:sym js-delete, :meta {:doc "Delete a property from a JavaScript object.", :arglists ([obj key])}, :source "(defn\n js-delete\n \"Delete a property from a JavaScript object.\"\n [obj key]\n (cljs.core/js-delete obj key))\n"} {:sym truth_, :meta {:doc "Internal - do not use!", :arglists ([x])}, :source "(defn truth_ \"Internal - do not use!\" [x] (cljs.core/truth_ x))\n"} {:sym compare-and-set!, :meta {:doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false.", :arglists ([a oldval newval])}, :source "(defn\n compare-and-set!\n \"Atomically sets the value of atom to newval if and only if the\\n  current value of the atom is equal to oldval. Returns true if\\n  set happened, else false.\"\n [a oldval newval]\n (if (= (-deref a) oldval) (do (reset! a newval) true) false))\n"} {:sym array-seq, :meta {:doc "Create a seq from a JavaScript array.", :arglists [[array] [array i]]}, :source "(defn\n array-seq\n \"Create a seq from a JavaScript array.\"\n ([array] (prim-seq array 0))\n ([array i] (prim-seq array i)))\n"} {:sym interleave, :meta {:doc "Returns a lazy seq of the first item in each coll, then the second etc.", :arglists [[] [c1] [c1 c2] [c1 c2 & colls]]}, :source "(defn\n interleave\n \"Returns a lazy seq of the first item in each coll, then the second etc.\"\n ([] ())\n ([c1] (lazy-seq c1))\n ([c1 c2]\n  (lazy-seq\n   (let\n    [s1 (seq c1) s2 (seq c2)]\n    (when\n     (and s1 s2)\n     (cons\n      (first s1)\n      (cons (first s2) (interleave (rest s1) (rest s2))))))))\n ([c1 c2 & colls]\n  (lazy-seq\n   (let\n    [ss (map seq (conj colls c2 c1))]\n    (when\n     (every? identity ss)\n     (concat (map first ss) (apply interleave (map rest ss))))))))\n"} {:sym map?, :meta {:doc "Return true if x satisfies IMap", :arglists ([x])}, :source "(defn\n map?\n \"Return true if x satisfies IMap\"\n [x]\n (if (nil? x) false (satisfies? IMap x)))\n"} {:sym m3-C1, :meta {}, :source "(def m3-C1 (int 3432918353))\n"} {:sym get, :meta {:doc "Returns the value mapped to key, not-found or nil if key not present.", :arglists [[o k] [o k not-found]]}, :source "(defn\n get\n \"Returns the value mapped to key, not-found or nil if key not present.\"\n ([o k]\n  (when-not\n   (nil? o)\n   (cond\n    (implements? ILookup o)\n    (-lookup o k)\n    (array? o)\n    (when (and (some? k) (< k (.-length o))) (aget o (int k)))\n    (string? o)\n    (when (and (some? k) (< k (.-length o))) (.charAt o (int k)))\n    (native-satisfies? ILookup o)\n    (-lookup o k)\n    :else\n    nil)))\n ([o k not-found]\n  (if-not\n   (nil? o)\n   (cond\n    (implements? ILookup o)\n    (-lookup o k not-found)\n    (array? o)\n    (if\n     (and (some? k) (>= k 0) (< k (.-length o)))\n     (aget o (int k))\n     not-found)\n    (string? o)\n    (if\n     (and (some? k) (>= k 0) (< k (.-length o)))\n     (.charAt o (int k))\n     not-found)\n    (native-satisfies? ILookup o)\n    (-lookup o k not-found)\n    :else\n    not-found)\n   not-found)))\n"} {:sym identity, :meta {:doc "Returns its argument.", :arglists ([x])}, :source "(defn identity \"Returns its argument.\" [x] x)\n"} {:sym into, :meta {:doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :arglists [[] [to] [to from] [to xform from]]}, :source "(defn\n into\n \"Returns a new coll consisting of to-coll with all of the items of\\n  from-coll conjoined. A transducer may be supplied.\"\n ([] [])\n ([to] to)\n ([to from]\n  (if-not\n   (nil? to)\n   (if\n    (implements? IEditableCollection to)\n    (-with-meta\n     (persistent! (reduce -conj! (transient to) from))\n     (meta to))\n    (reduce -conj to from))\n   (reduce conj () from)))\n ([to xform from]\n  (if\n   (implements? IEditableCollection to)\n   (-with-meta\n    (persistent! (transduce xform conj! (transient to) from))\n    (meta to))\n   (transduce xform conj to from))))\n"} {:sym long, :meta {:doc "Coerce to long by stripping decimal places. Identical to `int'.", :arglists ([x])}, :source "(defn\n long\n \"Coerce to long by stripping decimal places. Identical to `int'.\"\n [x]\n (fix x))\n"} {:sym double, :meta {:doc nil, :arglists ([x])}, :source "(defn double [x] x)\n"} {:sym volatile?, :meta {:doc "Returns true if x is a volatile.", :arglists ([x])}, :source "(defn\n volatile?\n \"Returns true if x is a volatile.\"\n [x]\n (instance? Volatile x))\n"} {:sym -key, :meta {:doc "Returns the key of the map entry.", :arglists ([coll])}, :protocol IMapEntry} {:sym nfirst, :meta {:doc "Same as (next (first x))", :arglists ([coll])}, :source "(defn nfirst \"Same as (next (first x))\" [coll] (next (first coll)))\n"} {:sym meta, :meta {:doc "Returns the metadata of obj, returns nil if there is no metadata.", :arglists ([o])}, :source "(defn\n meta\n \"Returns the metadata of obj, returns nil if there is no metadata.\"\n [o]\n (when (and (not (nil? o)) (satisfies? IMeta o)) (-meta o)))\n"} {:sym -kv-reduce, :meta {:doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.", :arglists ([coll f init])}, :protocol IKVReduce} {:sym IHash, :meta {:doc "Protocol for adding hashing functionality to a type."}, :methods (-hash)} {:sym bit-and-not, :meta {:doc "Bitwise and with complement", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-and-not\n \"Bitwise and with complement\"\n ([x y] (cljs.core/bit-and-not x y))\n ([x y & more] (reduce bit-and-not (cljs.core/bit-and-not x y) more)))\n"} {:sym var?, :meta {:doc "Returns true if v is of type cljs.core.Var", :arglists ([v])}, :source "(defn\n var?\n \"Returns true if v is of type cljs.core.Var\"\n [v]\n (instance? cljs.core.Var v))\n"} {:sym -comparator, :meta {:doc "Returns the comparator for coll.", :arglists ([coll])}, :protocol ISorted} {:sym unchecked-add-int, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-add-int\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/unchecked-add-int x y))\n ([x y & more]\n  (reduce unchecked-add-int (cljs.core/unchecked-add-int x y) more)))\n"} {:sym hash-ordered-coll, :meta {:doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([coll])}, :source "(defn\n hash-ordered-coll\n \"Returns the hash code, consistent with =, for an external ordered\\n   collection implementing Iterable.\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [coll]\n (loop\n  [n 0 hash-code 1 coll (seq coll)]\n  (if-not\n   (nil? coll)\n   (recur\n    (inc n)\n    (bit-or (+ (imul 31 hash-code) (hash (first coll))) 0)\n    (next coll))\n   (mix-collection-hash hash-code n))))\n"} {:sym IEquiv, :meta {:doc "Protocol for adding value comparison functionality to a type."}, :methods (-equiv)} {:sym cycle, :meta {:doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", :arglists ([coll])}, :source "(defn\n cycle\n \"Returns a lazy (infinite!) sequence of repetitions of the items in coll.\"\n [coll]\n (lazy-seq (when-let [s (seq coll)] (concat s (cycle s)))))\n"} {:sym -deref, :meta {:doc "Returns the value of the reference o.", :arglists ([o])}, :protocol IDeref} {:sym empty?, :meta {:doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", :arglists ([coll])}, :source "(defn\n empty?\n \"Returns true if coll has no items - same as (not (seq coll)).\\n  Please use the idiom (seq x) rather than (not (empty? x))\"\n [coll]\n (or (nil? coll) (not (seq coll))))\n"} {:sym short, :meta {:doc nil, :arglists ([x])}, :source "(defn short [x] x)\n"} {:sym -chunked-first, :meta {:doc "Returns the first chunk in coll.", :arglists ([coll])}, :protocol IChunkedSeq} {:sym filterv, :meta {:doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.", :arglists ([pred coll])}, :source "(defn\n filterv\n \"Returns a vector of the items in coll for which\\n  (pred item) returns true. pred must be free of side-effects.\"\n [pred coll]\n (->\n  (reduce (fn [v o] (if (pred o) (conj! v o) v)) (transient []) coll)\n  persistent!))\n"} {:sym hash, :meta {:doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =.", :arglists ([o])}, :source "(defn\n hash\n \"Returns the hash code of its argument. Note this is the hash code\\n   consistent with =.\"\n [o]\n (cond\n  (implements? IHash o)\n  (bit-xor (-hash o) 0)\n  (number? o)\n  (if\n   (js/isFinite o)\n   (js-mod (Math/floor o) 2147483647)\n   (case o ##Inf 2146435072 ##-Inf -1048576 2146959360))\n  (true? o)\n  1231\n  (false? o)\n  1237\n  (string? o)\n  (m3-hash-int (hash-string o))\n  (instance? js/Date o)\n  (bit-xor (.valueOf o) 0)\n  (nil? o)\n  0\n  :else\n  (bit-xor (-hash o) 0)))\n"} {:sym quot, :meta {:doc "quot[ient] of dividing numerator by denominator.", :arglists ([n d])}, :source "(defn\n quot\n \"quot[ient] of dividing numerator by denominator.\"\n [n d]\n (let [rem (js-mod n d)] (fix (/ (- n rem) d))))\n"} {:sym unchecked-double, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-double [x] x)\n"} {:sym ranged-iterator, :meta {:doc nil, :arglists ([v start end])}, :source "(defn\n ranged-iterator\n [v start end]\n (let\n  [i start]\n  (RangedIterator.\n   i\n   (- i (js-mod i 32))\n   (when (< start (count v)) (unchecked-array-for v i))\n   v\n   start\n   end)))\n"} {:sym ITransientVector, :meta {:doc "Protocol for adding vector functionality to transient collections."}, :methods (-assoc-n! -pop!)} {:sym longs, :meta {:doc nil, :arglists ([x])}, :source "(defn longs [x] x)\n"} {:sym not=, :meta {:doc "Same as (not (= obj1 obj2))", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n not=\n \"Same as (not (= obj1 obj2))\"\n ([x] false)\n ([x y] (not (= x y)))\n ([x y & more] (not (apply = x y more))))\n"} {:sym set-print-err-fn!, :meta {:doc "Set *print-err-fn* to f.", :arglists ([f])}, :source "(defn\n set-print-err-fn!\n \"Set *print-err-fn* to f.\"\n [f]\n (set! *print-err-fn* f))\n"} {:sym string?, :meta {:doc "Returns true if x is a JavaScript string.", :arglists ([x])}, :source "(defn\n string?\n \"Returns true if x is a JavaScript string.\"\n [x]\n (goog/isString x))\n"} {:sym es6-iterator, :meta {:doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll.", :arglists ([coll])}, :source "(defn\n es6-iterator\n \"EXPERIMENTAL: Return a ES2015 compatible iterator for coll.\"\n [coll]\n (ES6Iterator. (seq coll)))\n"} {:sym m3-C2, :meta {}, :source "(def m3-C2 (int 461845907))\n"} {:sym *print-newline*, :meta {:doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects."}, :source "(def *print-newline* true)\n"} {:sym unchecked-multiply-int, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-multiply-int\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/unchecked-multiply-int x y))\n ([x y & more]\n  (reduce\n   unchecked-multiply-int\n   (cljs.core/unchecked-multiply-int x y)\n   more)))\n"} {:sym chunk-rest, :meta {:doc nil, :arglists ([s])}, :source "(defn chunk-rest [s] (-chunked-rest s))\n"} {:sym double?, :meta {:doc "Returns true for JavaScript numbers, false otherwise.", :arglists ([x])}, :source "(defn\n double?\n \"Returns true for JavaScript numbers, false otherwise.\"\n [x]\n (number? x))\n"} {:sym vec, :meta {:doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified.", :arglists ([coll])}, :source "(defn\n vec\n \"Creates a new vector containing the contents of coll. JavaScript arrays\\n  will be aliased and should not be modified.\"\n [coll]\n (if\n  (array? coll)\n  (.fromArray PersistentVector coll true)\n  (-persistent!\n   (reduce -conj! (-as-transient (.-EMPTY PersistentVector)) coll))))\n"} {:sym *print-meta*, :meta {:doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false."}, :source "(def *print-meta* false)\n"} {:sym -notify-watches, :meta {:doc "Calls all watchers with this, oldval and newval.", :arglists ([this oldval newval])}, :protocol IWatchable} {:sym int, :meta {:doc "Coerce to int by stripping decimal places.", :arglists ([x])}, :source "(defn int \"Coerce to int by stripping decimal places.\" [x] (bit-or x 0))\n"} {:sym second, :meta {:doc "Same as (first (next x))", :arglists ([coll])}, :source "(defn second \"Same as (first (next x))\" [coll] (first (next coll)))\n"} {:sym IEditableCollection, :meta {:doc "Protocol for collections which can transformed to transients."}, :methods (-as-transient)} {:sym hash-combine, :meta {:doc nil, :arglists ([seed hash])}, :source "(defn\n hash-combine\n [seed hash]\n (bit-xor\n  seed\n  (+ hash 2654435769 (bit-shift-left seed 6) (bit-shift-right seed 2))))\n"} {:sym >, :meta {:doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n >\n \"Returns non-nil if nums are in monotonically decreasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/> x y))\n ([x y & more]\n  (if\n   (cljs.core/> x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/> y (first more)))\n   false)))\n"} {:sym -name, :meta {:doc "Returns the name String of x.", :arglists ([x])}, :protocol INamed} {:sym int?, :meta {:doc "Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long.", :arglists ([x])}, :source "(defn\n int?\n \"Return true if x satisfies integer? or is an instance of goog.math.Integer\\n   or goog.math.Long.\"\n [x]\n (or\n  (integer? x)\n  (instance? goog.math.Integer x)\n  (instance? goog.math.Long x)))\n"} {:sym associative?, :meta {:doc "Returns true if coll implements Associative", :arglists ([x])}, :source "(defn\n associative?\n \"Returns true if coll implements Associative\"\n [x]\n (satisfies? IAssociative x))\n"} {:sym unchecked-int, :meta {:doc "Coerce to int by stripping decimal places.", :arglists ([x])}, :source "(defn\n unchecked-int\n \"Coerce to int by stripping decimal places.\"\n [x]\n (fix x))\n"} {:sym js-keys, :meta {:doc "Return the JavaScript keys for an object.", :arglists ([obj])}, :source "(defn\n js-keys\n \"Return the JavaScript keys for an object.\"\n [obj]\n (gobject/getKeys obj))\n"} {:sym inst-ms*, :meta {:doc nil, :arglists ([inst])}, :protocol Inst} {:sym keyword?, :meta {:doc "Return true if x is a Keyword", :arglists ([x])}, :source "(defn\n keyword?\n \"Return true if x is a Keyword\"\n [x]\n (instance? Keyword x))\n"} {:sym array-iter, :meta {:doc nil, :arglists ([x])}, :source "(defn array-iter [x] (ArrayIter. x 0))\n"} {:sym -rseq, :meta {:doc "Returns a seq of the items in coll in reversed order.", :arglists ([coll])}, :protocol IReversible} {:sym unchecked-multiply, :meta {:doc "Returns the product of nums. (*) returns 1.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-multiply\n \"Returns the product of nums. (*) returns 1.\"\n ([] 1)\n ([x] x)\n ([x y] (cljs.core/unchecked-multiply x y))\n ([x y & more]\n  (reduce unchecked-multiply (cljs.core/unchecked-multiply x y) more)))\n"} {:sym even?, :meta {:doc "Returns true if n is even, throws an exception if n is not an integer", :arglists ([n])}, :source "(defn\n even?\n \"Returns true if n is even, throws an exception if n is not an integer\"\n [n]\n (if\n  (integer? n)\n  (zero? (bit-and n 1))\n  (throw (js/Error. (str \"Argument must be an integer: \" n)))))\n"} {:sym es6-iterator-seq, :meta {:doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.", :arglists ([iter])}, :source "(defn\n es6-iterator-seq\n \"EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.\"\n [iter]\n (let\n  [v (.next iter)]\n  (if (.-done v) () (ES6IteratorSeq. (.-value v) iter nil))))\n"} {:sym unchecked-dec, :meta {:doc "Returns a number one less than x, an int.", :arglists ([x])}, :source "(defn\n unchecked-dec\n \"Returns a number one less than x, an int.\"\n [x]\n (cljs.core/unchecked-dec x))\n"} {:sym Inst, :meta {:doc nil}, :methods (inst-ms*)} {:sym double-array, :meta {:doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n double-array\n \"Creates an array of doubles. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (double-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym spread, :meta {:doc nil, :arglists ([arglist])}, :source "(defn\n spread\n [arglist]\n (when-not\n  (nil? arglist)\n  (let\n   [n (next arglist)]\n   (if\n    (nil? n)\n    (seq (first arglist))\n    (cons (first arglist) (spread n))))))\n"} {:sym rseq, :meta {:doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", :arglists ([rev])}, :source "(defn\n rseq\n \"Returns, in constant time, a seq of the items in rev (which\\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil\"\n [rev]\n (-rseq rev))\n"} {:sym IReset, :meta {:doc "Protocol for adding resetting functionality."}, :methods (-reset!)} {:sym IEmptyableCollection, :meta {:doc "Protocol for creating an empty collection."}, :methods (-empty)} {:sym *print-fn-bodies*, :meta {:doc "*print-fns-bodies* controls whether functions print their source or\n    only their names."}, :source "(def *print-fn-bodies* false)\n"} {:sym float, :meta {:doc nil, :arglists ([x])}, :source "(defn float [x] x)\n"} {:sym IRecord, :meta {:doc "Marker interface indicating a record object"}, :methods ()} {:sym concat, :meta {:doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :arglists [[] [x] [x y] [x y & zs]]}, :source "(defn\n concat\n \"Returns a lazy seq representing the concatenation of the elements in the supplied colls.\"\n ([] (lazy-seq nil))\n ([x] (lazy-seq x))\n ([x y]\n  (lazy-seq\n   (let\n    [s (seq x)]\n    (if\n     s\n     (if\n      (chunked-seq? s)\n      (chunk-cons (chunk-first s) (concat (chunk-rest s) y))\n      (cons (first s) (concat (rest s) y)))\n     y))))\n ([x y & zs]\n  (let\n   [cat\n    (fn\n     cat\n     [xys zs]\n     (lazy-seq\n      (let\n       [xys (seq xys)]\n       (if\n        xys\n        (if\n         (chunked-seq? xys)\n         (chunk-cons (chunk-first xys) (cat (chunk-rest xys) zs))\n         (cons (first xys) (cat (rest xys) zs)))\n        (when zs (cat (first zs) (next zs)))))))]\n   (cat (concat x y) zs))))\n"} {:sym IDerefWithTimeout, :meta {:doc nil}, :methods (-deref-with-timeout)} {:sym symbol, :meta {:doc "Returns a Symbol with the given namespace and name.", :arglists [[name] [ns name]]}, :source "(defn\n symbol\n \"Returns a Symbol with the given namespace and name.\"\n ([name]\n  (if\n   (symbol? name)\n   name\n   (let\n    [idx (.indexOf name \"/\")]\n    (if\n     (< idx 1)\n     (symbol nil name)\n     (symbol\n      (.substring name 0 idx)\n      (.substring name (inc idx) (. name -length)))))))\n ([ns name]\n  (let\n   [sym-str (if-not (nil? ns) (str ns \"/\" name) name)]\n   (Symbol. ns name sym-str nil nil))))\n"} {:sym to-array-2d, :meta {:doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll.", :arglists ([coll])}, :source "(defn\n to-array-2d\n \"Returns a (potentially-ragged) 2-dimensional array\\n  containing the contents of coll.\"\n [coll]\n (let\n  [ret (make-array (count coll))]\n  (loop\n   [i 0 xs (seq coll)]\n   (when-not\n    (nil? xs)\n    (aset ret i (to-array (first xs)))\n    (recur (inc i) (next xs))))\n  ret))\n"} {:sym mod, :meta {:doc "Modulus of num and div. Truncates toward negative infinity.", :arglists ([n d])}, :source "(defn\n mod\n \"Modulus of num and div. Truncates toward negative infinity.\"\n [n d]\n (js-mod (+ (js-mod n d) d) d))\n"} {:sym ISet, :meta {:doc "Protocol for adding set functionality to a collection."}, :methods (-disjoin)} {:sym pop, :meta {:doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast.", :arglists ([coll])}, :source "(defn\n pop\n \"For a list or queue, returns a new list/queue without the first\\n  item, for a vector, returns a new vector without the last item.\\n  Note - not the same as next/butlast.\"\n [coll]\n (when-not (nil? coll) (-pop coll)))\n"} {:sym IPending, :meta {:doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq."}, :methods (-realized?)} {:sym -entry-key, :meta {:doc "Returns the key for entry.", :arglists ([coll entry])}, :protocol ISorted} {:sym dissoc!, :meta {:doc "Returns a transient map that doesn't contain a mapping for key(s).", :arglists [[tcoll key] [tcoll key & ks]]}, :source "(defn\n dissoc!\n \"Returns a transient map that doesn't contain a mapping for key(s).\"\n ([tcoll key] (-dissoc! tcoll key))\n ([tcoll key & ks]\n  (let\n   [ntcoll (-dissoc! tcoll key)]\n   (if ks (recur ntcoll (first ks) (next ks)) ntcoll))))\n"} {:sym indexed?, :meta {:doc "Returns true if coll implements nth in constant time", :arglists ([x])}, :source "(defn\n indexed?\n \"Returns true if coll implements nth in constant time\"\n [x]\n (satisfies? IIndexed x))\n"} {:sym -, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n -\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/- x))\n ([x y] (cljs.core/- x y))\n ([x y & more] (reduce - (cljs.core/- x y) more)))\n"} {:sym -equiv, :meta {:doc "Returns true if o and other are equal, false otherwise.", :arglists ([o other])}, :protocol IEquiv} {:sym assoc!, :meta {:doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :arglists [[tcoll key val] [tcoll key val & kvs]]}, :source "(defn\n assoc!\n \"When applied to a transient map, adds mapping of key(s) to\\n  val(s). When applied to a transient vector, sets the val at index.\\n  Note - index must be <= (count vector). Returns coll.\"\n ([tcoll key val] (-assoc! tcoll key val))\n ([tcoll key val & kvs]\n  (let\n   [ntcoll (-assoc! tcoll key val)]\n   (if\n    kvs\n    (recur ntcoll (first kvs) (second kvs) (nnext kvs))\n    ntcoll))))\n"} {:sym reduce-kv, :meta {:doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", :arglists [[f init coll]]}, :source "(defn\n reduce-kv\n \"Reduces an associative collection. f should be a function of 3\\n  arguments. Returns the result of applying f to init, the first key\\n  and the first value in coll, then applying f to that result and the\\n  2nd key and value, etc. If coll contains no entries, returns init\\n  and f is not called. Note that reduce-kv is supported on vectors,\\n  where the keys will be the ordinals.\"\n ([f init coll] (if-not (nil? coll) (-kv-reduce coll f init) init)))\n"} {:sym reset!, :meta {:doc "Sets the value of atom to newval without regard for the\n  current value. Returns new-value.", :arglists ([a new-value])}, :source "(defn\n reset!\n \"Sets the value of atom to newval without regard for the\\n  current value. Returns new-value.\"\n [a new-value]\n (if\n  (instance? Atom a)\n  (let\n   [validate (.-validator a)]\n   (when-not\n    (nil? validate)\n    (when-not\n     (validate new-value)\n     (throw (js/Error. \"Validator rejected reference state\"))))\n   (let\n    [old-value (.-state a)]\n    (set! (.-state a) new-value)\n    (when-not\n     (nil? (.-watches a))\n     (-notify-watches a old-value new-value))\n    new-value))\n  (-reset! a new-value)))\n"} {:sym Fn, :meta {:doc "Marker protocol"}, :methods ()} {:sym ffirst, :meta {:doc "Same as (first (first x))", :arglists ([coll])}, :source "(defn ffirst \"Same as (first (first x))\" [coll] (first (first coll)))\n"} {:sym counted?, :meta {:doc "Returns true if coll implements count in constant time", :arglists ([x])}, :source "(defn\n counted?\n \"Returns true if coll implements count in constant time\"\n [x]\n (satisfies? ICounted x))\n"} {:sym assoc-in, :meta {:doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", :arglists ([m [k & ks] v])}, :source "(defn\n assoc-in\n \"Associates a value in a nested associative structure, where ks is a\\n  sequence of keys and v is the new value and returns a new nested structure.\\n  If any levels do not exist, hash-maps will be created.\"\n [m [k & ks] v]\n (if ks (assoc m k (assoc-in (get m k) ks v)) (assoc m k v)))\n"} {:sym bit-test, :meta {:doc "Test bit at index n", :arglists ([x n])}, :source "(defn bit-test \"Test bit at index n\" [x n] (cljs.core/bit-test x n))\n"} {:sym ISwap, :meta {:doc "Protocol for adding swapping functionality."}, :methods (-swap!)} {:sym zero?, :meta {:doc "Returns true if num is zero, else false", :arglists ([x])}, :source "(defn\n zero?\n \"Returns true if num is zero, else false\"\n [x]\n (cljs.core/zero? x))\n"} {:sym simple-keyword?, :meta {:doc "Return true if x is a keyword without a namespace", :arglists ([x])}, :source "(defn\n simple-keyword?\n \"Return true if x is a keyword without a namespace\"\n [x]\n (and (keyword? x) (nil? (namespace x))))\n"} {:sym *main-cli-fn*, :meta {:doc "When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments"}, :source "(def *main-cli-fn* nil)\n"} {:sym -assoc-n, :meta {:doc "Returns a new vector with value val added at position n.", :arglists ([coll n val])}, :protocol IVector} {:sym unchecked-dec-int, :meta {:doc "Returns a number one less than x, an int.", :arglists ([x])}, :source "(defn\n unchecked-dec-int\n \"Returns a number one less than x, an int.\"\n [x]\n (cljs.core/unchecked-dec-int x))\n"} {:sym persistent!, :meta {:doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", :arglists ([tcoll])}, :source "(defn\n persistent!\n \"Returns a new, persistent version of the transient collection, in\\n  constant time. The transient collection cannot be used after this\\n  call, any such use will throw an exception.\"\n [tcoll]\n (-persistent! tcoll))\n"} {:sym set-print-fn!, :meta {:doc "Set *print-fn* to f.", :arglists ([f])}, :source "(defn set-print-fn! \"Set *print-fn* to f.\" [f] (set! *print-fn* f))\n"} {:sym nnext, :meta {:doc "Same as (next (next x))", :arglists ([coll])}, :source "(defn nnext \"Same as (next (next x))\" [coll] (next (next coll)))\n"} {:sym not-every?, :meta {:doc "Returns false if (pred x) is logical true for every x in\n  coll, else true.", :arglists ([pred coll])}, :source "(defn\n not-every?\n \"Returns false if (pred x) is logical true for every x in\\n  coll, else true.\"\n [pred coll]\n (not (every? pred coll)))\n"} {:sym rem, :meta {:doc "remainder of dividing numerator by denominator.", :arglists ([n d])}, :source "(defn\n rem\n \"remainder of dividing numerator by denominator.\"\n [n d]\n (let [q (quot n d)] (- n (* d q))))\n"} {:sym ifind?, :meta {:doc "Returns true if coll implements IFind", :arglists ([x])}, :source "(defn\n ifind?\n \"Returns true if coll implements IFind\"\n [x]\n (satisfies? IFind x))\n"} {:sym some, :meta {:doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", :arglists ([pred coll])}, :source "(defn\n some\n \"Returns the first logical true value of (pred x) for any x in coll,\\n  else nil.  One common idiom is to use a set as pred, for example\\n  this will return :fred if :fred is in the sequence, otherwise nil:\\n  (some #{:fred} coll)\"\n [pred coll]\n (when (seq coll) (or (pred (first coll)) (recur pred (next coll)))))\n"} {:sym INamed, :meta {:doc "Protocol for adding a name."}, :methods (-name -namespace)} {:sym IReduce, :meta {:doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce."}, :methods (-reduce)} {:sym neg-int?, :meta {:doc "Return true if x satisfies int? and is negative.", :arglists ([x])}, :source "(defn\n neg-int?\n \"Return true if x satisfies int? and is negative.\"\n [x]\n (cond\n  (integer? x)\n  (neg? x)\n  (instance? goog.math.Integer x)\n  (.isNegative x)\n  (instance? goog.math.Long x)\n  (.isNegative x)\n  :else\n  false))\n"} {:sym drop, :meta {:doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :arglists [[n] [n coll]]}, :source "(defn\n drop\n \"Returns a lazy sequence of all but the first n items in coll.\\n  Returns a stateful transducer when no collection is provided.\"\n ([n]\n  {:pre [(number? n)]}\n  (fn\n   [rf]\n   (let\n    [na (volatile! n)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [n @na]\n       (vswap! na dec)\n       (if (pos? n) result (rf result input))))))))\n ([n coll]\n  {:pre [(number? n)]}\n  (let\n   [step\n    (fn\n     [n coll]\n     (let\n      [s (seq coll)]\n      (if (and (pos? n) s) (recur (dec n) (rest s)) s)))]\n   (lazy-seq (step n coll)))))\n"} {:sym js-obj, :meta {:doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values.", :arglists [[] [& keyvals]]}, :source "(defn\n js-obj\n \"Create JavaSript object from an even number arguments representing\\n  interleaved keys and values.\"\n ([] (cljs.core/js-obj))\n ([& keyvals] (apply gobject/create keyvals)))\n"} {:sym ITransientCollection, :meta {:doc "Protocol for adding basic functionality to transient collections."}, :methods (-conj! -persistent!)} {:sym nth, :meta {:doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :arglists [[coll n] [coll n not-found]]}, :source "(defn\n nth\n \"Returns the value at the index. get returns nil if index out of\\n  bounds, nth throws an exception unless not-found is supplied.  nth\\n  also works for strings, arrays, regex Matchers and Lists, and,\\n  in O(n) time, for sequences.\"\n ([coll n]\n  (cond\n   (not (number? n))\n   (throw (js/Error. \"Index argument to nth must be a number\"))\n   (nil? coll)\n   coll\n   (implements? IIndexed coll)\n   (-nth coll n)\n   (array? coll)\n   (if\n    (and (>= n 0) (< n (.-length coll)))\n    (aget coll n)\n    (throw (js/Error. \"Index out of bounds\")))\n   (string? coll)\n   (if\n    (and (>= n 0) (< n (.-length coll)))\n    (.charAt coll n)\n    (throw (js/Error. \"Index out of bounds\")))\n   (implements? ISeq coll)\n   (linear-traversal-nth coll n)\n   (native-satisfies? IIndexed coll)\n   (-nth coll n)\n   :else\n   (throw\n    (js/Error.\n     (str\n      \"nth not supported on this type \"\n      (type->str (type coll)))))))\n ([coll n not-found]\n  (cond\n   (not (number? n))\n   (throw (js/Error. \"Index argument to nth must be a number.\"))\n   (nil? coll)\n   not-found\n   (implements? IIndexed coll)\n   (-nth coll n not-found)\n   (array? coll)\n   (if (and (>= n 0) (< n (.-length coll))) (aget coll n) not-found)\n   (string? coll)\n   (if (and (>= n 0) (< n (.-length coll))) (.charAt coll n) not-found)\n   (implements? ISeq coll)\n   (linear-traversal-nth coll n not-found)\n   (native-satisfies? IIndexed coll)\n   (-nth coll n not-found)\n   :else\n   (throw\n    (js/Error.\n     (str\n      \"nth not supported on this type \"\n      (type->str (type coll))))))))\n"} {:sym sorted?, :meta {:doc "Returns true if coll satisfies ISorted", :arglists ([x])}, :source "(defn\n sorted?\n \"Returns true if coll satisfies ISorted\"\n [x]\n (satisfies? ISorted x))\n"} {:sym nil?, :meta {:doc "Returns true if x is nil, false otherwise.", :arglists ([x])}, :source "(defn\n nil?\n \"Returns true if x is nil, false otherwise.\"\n [x]\n (coercive-= x nil))\n"} {:sym split-at, :meta {:doc "Returns a vector of [(take n coll) (drop n coll)]", :arglists ([n coll])}, :source "(defn\n split-at\n \"Returns a vector of [(take n coll) (drop n coll)]\"\n [n coll]\n [(take n coll) (drop n coll)])\n"} {:sym not-native, :meta {}, :source "(def not-native nil)\n"} {:sym bit-and, :meta {:doc "Bitwise and", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-and\n \"Bitwise and\"\n ([x y] (cljs.core/bit-and x y))\n ([x y & more] (reduce bit-and (cljs.core/bit-and x y) more)))\n"} {:sym bounded-count, :meta {:doc "If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq", :arglists ([n coll])}, :source "(defn\n bounded-count\n \"If coll is counted? returns its count, else will count at most the first n\\n   elements of coll using its seq\"\n {:added \"1.9\"}\n [n coll]\n (if\n  (counted? coll)\n  (count coll)\n  (loop\n   [i 0 s (seq coll)]\n   (if (and (not (nil? s)) (< i n)) (recur (inc i) (next s)) i))))\n"} {:sym update, :meta {:doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :arglists [[m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]]}, :source "(defn\n update\n \"'Updates' a value in an associative structure, where k is a\\n  key and f is a function that will take the old value\\n  and any supplied args and return the new value, and returns a new\\n  structure.  If the key does not exist, nil is passed as the old value.\"\n ([m k f] (assoc m k (f (get m k))))\n ([m k f x] (assoc m k (f (get m k) x)))\n ([m k f x y] (assoc m k (f (get m k) x y)))\n ([m k f x y z] (assoc m k (f (get m k) x y z)))\n ([m k f x y z & more] (assoc m k (apply f (get m k) x y z more))))\n"} {:sym list*, :meta {:doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :arglists [[args] [a args] [a b args] [a b c args] [a b c d & more]]}, :source "(defn\n list*\n \"Creates a new list containing the items prepended to the rest, the\\n  last of which will be treated as a sequence.\"\n ([args] (seq args))\n ([a args] (cons a args))\n ([a b args] (cons a (cons b args)))\n ([a b c args] (cons a (cons b (cons c args))))\n ([a b c d & more] (cons a (cons b (cons c (cons d (spread more)))))))\n"} {:sym update-in, :meta {:doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :arglists [[m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]]}, :source "(defn\n update-in\n \"'Updates' a value in a nested associative structure, where ks is a\\n  sequence of keys and f is a function that will take the old value\\n  and any supplied args and return the new value, and returns a new\\n  nested structure.  If any levels do not exist, hash-maps will be\\n  created.\"\n ([m [k & ks] f]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f))\n   (assoc m k (f (get m k)))))\n ([m [k & ks] f a]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a))\n   (assoc m k (f (get m k) a))))\n ([m [k & ks] f a b]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a b))\n   (assoc m k (f (get m k) a b))))\n ([m [k & ks] f a b c]\n  (if\n   ks\n   (assoc m k (update-in (get m k) ks f a b c))\n   (assoc m k (f (get m k) a b c))))\n ([m [k & ks] f a b c & args]\n  (if\n   ks\n   (assoc m k (apply update-in (get m k) ks f a b c args))\n   (assoc m k (apply f (get m k) a b c args)))))\n"} {:sym ensure-reduced, :meta {:doc "If x is already reduced?, returns it, else returns (reduced x)", :arglists ([x])}, :source "(defn\n ensure-reduced\n \"If x is already reduced?, returns it, else returns (reduced x)\"\n [x]\n (if (reduced? x) x (reduced x)))\n"} {:sym instance?, :meta {:doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false", :arglists ([c x])}, :source "(defn\n instance?\n \"Evaluates x and tests if it is an instance of the type\\n  c. Returns true or false\"\n [c x]\n (cljs.core/instance? c x))\n"} {:sym mix-collection-hash, :meta {:doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([hash-basis count])}, :source "(defn\n mix-collection-hash\n \"Mix final collection hash for ordered or unordered collections.\\n   hash-basis is the combined collection hash, count is the number\\n   of elements included in the basis. Note this is the hash code\\n   consistent with =, different from .hashCode.\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [hash-basis count]\n (let\n  [h1 m3-seed k1 (m3-mix-K1 hash-basis) h1 (m3-mix-H1 h1 k1)]\n  (m3-fmix h1 count)))\n"} {:sym unchecked-add, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n unchecked-add\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/unchecked-add x y))\n ([x y & more]\n  (reduce unchecked-add (cljs.core/unchecked-add x y) more)))\n"} {:sym transformer-iterator, :meta {:doc nil, :arglists ([xform sourceIter multi])}, :source "(defn\n transformer-iterator\n [xform sourceIter multi]\n (let\n  [iterator\n   (TransformerIterator. EMPTY NONE false nil sourceIter multi)]\n  (set!\n   (.-xf iterator)\n   (xform\n    (fn\n     ([] nil)\n     ([acc] acc)\n     ([acc o]\n      (set! (.-buffer iterator) (.add (.-buffer iterator) o))\n      acc))))\n  iterator))\n"} {:sym not, :meta {:doc "Returns true if x is logical false, false otherwise.", :arglists ([x])}, :source "(defn\n not\n \"Returns true if x is logical false, false otherwise.\"\n [x]\n (cond (nil? x) true (false? x) true :else false))\n"} {:sym -vreset!, :meta {:doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.", :arglists ([o new-value])}, :protocol IVolatile} {:sym with-meta, :meta {:doc "Returns an object of the same type and value as obj, with\n  map m as its metadata.", :arglists ([o meta])}, :source "(defn\n with-meta\n \"Returns an object of the same type and value as obj, with\\n  map m as its metadata.\"\n [o meta]\n (if\n  (goog/isFunction o)\n  (MetaFn. o meta)\n  (when-not (nil? o) (-with-meta o meta))))\n"} {:sym unreduced, :meta {:doc "If x is reduced?, returns (deref x), else returns x", :arglists ([x])}, :source "(defn\n unreduced\n \"If x is reduced?, returns (deref x), else returns x\"\n [x]\n (if (reduced? x) (deref x) x))\n"} {:sym record?, :meta {:doc "Return true if x satisfies IRecord", :arglists ([x])}, :source "(defn\n record?\n \"Return true if x satisfies IRecord\"\n [x]\n (satisfies? IRecord x))\n"} {:sym type, :meta {:doc "Return x's constructor.", :arglists ([x])}, :source "(defn\n type\n \"Return x's constructor.\"\n [x]\n (when-not (nil? x) (.-constructor x)))\n"} {:sym identical?, :meta {:doc "Tests if 2 arguments are the same object", :arglists ([x y])}, :source "(defn\n identical?\n \"Tests if 2 arguments are the same object\"\n [x y]\n (cljs.core/identical? x y))\n"} {:sym -namespace, :meta {:doc "Returns the namespace String of x.", :arglists ([x])}, :protocol INamed} {:sym unchecked-divide-int, :meta {:doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-divide-int\n \"If no denominators are supplied, returns 1/numerator,\\n  else returns numerator divided by all of the denominators.\"\n ([x] (unchecked-divide-int 1 x))\n ([x y] (cljs.core/divide x y))\n ([x y & more]\n  (reduce unchecked-divide-int (unchecked-divide-int x y) more)))\n"} {:sym *out*, :meta {}, :source "(def *out* nil)\n"} {:sym hash-string, :meta {:doc nil, :arglists ([k])}, :source "(defn\n hash-string\n [k]\n (when\n  (> string-hash-cache-count 255)\n  (set! string-hash-cache (js-obj))\n  (set! string-hash-cache-count 0))\n (if\n  (nil? k)\n  0\n  (let\n   [h (unchecked-get string-hash-cache k)]\n   (if (number? h) h (add-to-string-hash-cache k)))))\n"} {:sym set-validator!, :meta {:doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed.", :arglists ([iref val])}, :source "(defn\n set-validator!\n \"Sets the validator-fn for an atom. validator-fn must be nil or a\\n  side-effect-free fn of one argument, which will be passed the intended\\n  new state on any state change. If the new state is unacceptable, the\\n  validator-fn should return false or throw an Error. If the current state\\n  is not acceptable to the new validator, an Error will be thrown and the\\n  validator will not be changed.\"\n [iref val]\n (when\n  (and (some? val) (not (val (-deref iref))))\n  (throw (js/Error. \"Validator rejected reference state\")))\n (set! (.-validator iref) val))\n"} {:sym ident?, :meta {:doc "Return true if x is a symbol or keyword", :arglists ([x])}, :source "(defn\n ident?\n \"Return true if x is a symbol or keyword\"\n [x]\n (or (keyword? x) (symbol? x)))\n"} {:sym -meta, :meta {:doc "Returns the metadata of object o.", :arglists ([o])}, :protocol IMeta} {:sym swap!, :meta {:doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :arglists [[a f] [a f x] [a f x y] [a f x y & more]]}, :source "(defn\n swap!\n \"Atomically swaps the value of atom to be:\\n  (apply f current-value-of-atom args). Note that f may be called\\n  multiple times, and thus should be free of side effects.  Returns\\n  the value that was swapped in.\"\n ([a f]\n  (if (instance? Atom a) (reset! a (f (.-state a))) (-swap! a f)))\n ([a f x]\n  (if (instance? Atom a) (reset! a (f (.-state a) x)) (-swap! a f x)))\n ([a f x y]\n  (if\n   (instance? Atom a)\n   (reset! a (f (.-state a) x y))\n   (-swap! a f x y)))\n ([a f x y & more]\n  (if\n   (instance? Atom a)\n   (reset! a (apply f (.-state a) x y more))\n   (-swap! a f x y more))))\n"} {:sym -chunked-next, :meta {:doc "Returns a new collection of coll without the first chunk.", :arglists ([coll])}, :protocol IChunkedNext} {:sym unchecked-subtract, :meta {:doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n unchecked-subtract\n \"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"\n ([x] (cljs.core/unchecked-subtract x))\n ([x y] (cljs.core/unchecked-subtract x y))\n ([x y & more]\n  (reduce unchecked-subtract (cljs.core/unchecked-subtract x y) more)))\n"} {:sym IMap, :meta {:doc "Protocol for adding mapping functionality to collections."}, :methods (-dissoc)} {:sym cloneable?, :meta {:doc "Return true if x implements ICloneable protocol.", :arglists ([value])}, :source "(defn\n cloneable?\n \"Return true if x implements ICloneable protocol.\"\n [value]\n (satisfies? ICloneable value))\n"} {:sym qualified-ident?, :meta {:doc "Return true if x is a symbol or keyword with a namespace", :arglists ([x])}, :source "(defn\n qualified-ident?\n \"Return true if x is a symbol or keyword with a namespace\"\n [x]\n (boolean (and (ident? x) (namespace x) true)))\n"} {:sym hash-string*, :meta {:doc nil, :arglists ([s])}, :source "(defn\n hash-string*\n [s]\n (if-not\n  (nil? s)\n  (let\n   [len (.-length s)]\n   (if\n    (pos? len)\n    (loop\n     [i 0 hash 0]\n     (if\n      (< i len)\n      (recur (inc i) (+ (imul 31 hash) (.charCodeAt s i)))\n      hash))\n    0))\n  0))\n"} {:sym true?, :meta {:doc "Returns true if x is the value true, false otherwise.", :arglists ([x])}, :source "(defn\n true?\n \"Returns true if x is the value true, false otherwise.\"\n [x]\n (cljs.core/true? x))\n"} {:sym array, :meta {:doc "Creates a new javascript array.\n@param {...*} var_args", :arglists ([var-args])}, :source "(defn\n array\n \"Creates a new javascript array.\\n@param {...*} var_args\"\n [var-args]\n (let\n  [a (js/Array. (alength (cljs.core/js-arguments)))]\n  (loop\n   [i 0]\n   (if\n    (< i (alength a))\n    (do (aset a i (aget (cljs.core/js-arguments) i)) (recur (inc i)))\n    a))))\n"} {:sym -peek, :meta {:doc "Returns the item from the top of the stack. Is used by cljs.core/peek.", :arglists ([coll])}, :protocol IStack} {:sym ISeq, :meta {:doc "Protocol for collections to provide access to their items as sequences."}, :methods (-first -rest)} {:sym empty, :meta {:doc "Returns an empty collection of the same category as coll, or nil", :arglists ([coll])}, :source "(defn\n empty\n \"Returns an empty collection of the same category as coll, or nil\"\n [coll]\n (when-not (nil? coll) (-empty coll)))\n"} {:sym volatile!, :meta {:doc "Creates and returns a Volatile with an initial value of val.", :arglists ([val])}, :source "(defn\n volatile!\n \"Creates and returns a Volatile with an initial value of val.\"\n [val]\n (Volatile. val))\n"} {:sym /, :meta {:doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n /\n \"If no denominators are supplied, returns 1/numerator,\\n  else returns numerator divided by all of the denominators.\"\n ([x] (/ 1 x))\n ([x y] (cljs.core/divide x y))\n ([x y & more] (reduce / (/ x y) more)))\n"} {:sym bit-or, :meta {:doc "Bitwise or", :arglists [[x y] [x y & more]]}, :source "(defn\n bit-or\n \"Bitwise or\"\n ([x y] (cljs.core/bit-or x y))\n ([x y & more] (reduce bit-or (cljs.core/bit-or x y) more)))\n"} {:sym m3-fmix, :meta {:doc nil, :arglists ([h1 len])}, :source "(defn\n m3-fmix\n [h1 len]\n (as->\n  (int h1)\n  h1\n  (bit-xor h1 len)\n  (bit-xor h1 (unsigned-bit-shift-right h1 16))\n  (imul h1 (int 2246822507))\n  (bit-xor h1 (unsigned-bit-shift-right h1 13))\n  (imul h1 (int 3266489909))\n  (bit-xor h1 (unsigned-bit-shift-right h1 16))))\n"} {:sym vector, :meta {:doc "Creates a new vector containing the args.", :arglists ([& args])}, :source "(defn\n vector\n \"Creates a new vector containing the args.\"\n [& args]\n (if\n  (and (instance? IndexedSeq args) (zero? (.-i args)))\n  (.fromArray PersistentVector (.-arr args) true)\n  (vec args)))\n"} {:sym >=, :meta {:doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n >=\n \"Returns non-nil if nums are in monotonically non-increasing order,\\n  otherwise false.\"\n ([x] true)\n ([x y] (cljs.core/>= x y))\n ([x y & more]\n  (if\n   (cljs.core/>= x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (cljs.core/>= y (first more)))\n   false)))\n"} {:sym drop-last, :meta {:doc "Return a lazy sequence of all but the last n (default 1) items in coll", :arglists [[s] [n s]]}, :source "(defn\n drop-last\n \"Return a lazy sequence of all but the last n (default 1) items in coll\"\n ([s] (drop-last 1 s))\n ([n s] (map (fn [x _] x) s (drop n s))))\n"} {:sym object?, :meta {:doc "Returns true if x's constructor is Object", :arglists ([x])}, :source "(defn\n object?\n \"Returns true if x's constructor is Object\"\n [x]\n (if-not (nil? x) (identical? (.-constructor x) js/Object) false))\n"} {:sym not-empty, :meta {:doc "If coll is empty, returns nil, else coll", :arglists ([coll])}, :source "(defn\n not-empty\n \"If coll is empty, returns nil, else coll\"\n [coll]\n (when (seq coll) coll))\n"} {:sym partition, :meta {:doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :arglists [[n coll] [n step coll] [n step pad coll]]}, :source "(defn\n partition\n \"Returns a lazy sequence of lists of n items each, at offsets step\\n  apart. If step is not supplied, defaults to n, i.e. the partitions\\n  do not overlap. If a pad collection is supplied, use its elements as\\n  necessary to complete last partition up to n items. In case there are\\n  not enough padding elements, return a partition with less than n items.\"\n ([n coll] (partition n n coll))\n ([n step coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (let\n     [p (take n s)]\n     (when\n      (== n (count p))\n      (cons p (partition n step (drop step s))))))))\n ([n step pad coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (let\n     [p (take n s)]\n     (if\n      (== n (count p))\n      (cons p (partition n step pad (drop step s)))\n      (list (take n (concat p pad)))))))))\n"} {:sym DEMUNGE_PATTERN, :meta {}, :source "(def DEMUNGE_PATTERN nil)\n"} {:sym IAssociative, :meta {:doc "Protocol for adding associativity to collections."}, :methods (-assoc -contains-key?)} {:sym bit-flip, :meta {:doc "Flip bit at index n", :arglists ([x n])}, :source "(defn bit-flip \"Flip bit at index n\" [x n] (cljs.core/bit-flip x n))\n"} {:sym long-array, :meta {:doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n long-array\n \"Creates an array of longs. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (long-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym ISeqable, :meta {:doc "Protocol for adding the ability to a type to be transformed into a sequence."}, :methods (-seq)} {:sym js-mod, :meta {:doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers", :arglists ([n d])}, :source "(defn\n js-mod\n \"Modulus of num and div with original javascript behavior. i.e. bug for negative numbers\"\n [n d]\n (cljs.core/js-mod n d))\n"} {:sym integer?, :meta {:doc "Returns true if n is a JavaScript number with no decimal part.", :arglists ([n])}, :source "(defn\n integer?\n \"Returns true if n is a JavaScript number with no decimal part.\"\n [n]\n (and\n  (number? n)\n  (not (js/isNaN n))\n  (not (identical? n js/Infinity))\n  (== (js/parseFloat n) (js/parseInt n 10))))\n"} {:sym mapv, :meta {:doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :arglists [[f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]]}, :source "(defn\n mapv\n \"Returns a vector consisting of the result of applying f to the\\n  set of first items of each coll, followed by applying f to the set\\n  of second items in each coll, until any one of the colls is\\n  exhausted.  Any remaining items in other colls are ignored. Function\\n  f should accept number-of-colls arguments.\"\n ([f coll]\n  (->\n   (reduce (fn [v o] (conj! v (f o))) (transient []) coll)\n   persistent!))\n ([f c1 c2] (into [] (map f c1 c2)))\n ([f c1 c2 c3] (into [] (map f c1 c2 c3)))\n ([f c1 c2 c3 & colls] (into [] (apply map f c1 c2 c3 colls))))\n"} {:sym infinite?, :meta {:doc "Returns true for Infinity and -Infinity values.", :arglists ([x])}, :source "(defn\n infinite?\n \"Returns true for Infinity and -Infinity values.\"\n [x]\n (or\n  (identical? x js/Number.POSITIVE_INFINITY)\n  (identical? x js/Number.NEGATIVE_INFINITY)))\n"} {:sym ISequential, :meta {:doc "Marker interface indicating a persistent collection of sequential items"}, :methods ()} {:sym equiv-map, :meta {:doc "Test map equivalence. Returns true if x equals y, otherwise returns false.", :arglists ([x y])}, :source "(defn\n equiv-map\n \"Test map equivalence. Returns true if x equals y, otherwise returns false.\"\n [x y]\n (boolean\n  (when\n   (and (map? y) (not (record? y)))\n   (when\n    (== (count x) (count y))\n    (if\n     (satisfies? IKVReduce x)\n     (reduce-kv\n      (fn\n       [_ k v]\n       (if (= (get y k never-equiv) v) true (reduced false)))\n      true\n      x)\n     (every?\n      (fn [xkv] (= (get y (first xkv) never-equiv) (second xkv)))\n      x))))))\n"} {:sym object-array, :meta {:doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.", :arglists [[size-or-seq] [size init-val-or-seq]]}, :source "(defn\n object-array\n \"Creates an array of objects. Does not coerce array, provided for compatibility\\n  with Clojure.\"\n ([size-or-seq]\n  (if\n   (number? size-or-seq)\n   (object-array size-or-seq nil)\n   (into-array size-or-seq)))\n ([size init-val-or-seq]\n  (let\n   [a (make-array size)]\n   (if\n    (seq? init-val-or-seq)\n    (let\n     [s (seq init-val-or-seq)]\n     (loop\n      [i 0 s s]\n      (if\n       (and s (< i size))\n       (do (aset a i (first s)) (recur (inc i) (next s)))\n       a)))\n    (do (dotimes [i size] (aset a i init-val-or-seq)) a)))))\n"} {:sym seq-iter, :meta {:doc nil, :arglists ([coll])}, :source "(defn seq-iter [coll] (SeqIter. INIT coll))\n"} {:sym IChunkedSeq, :meta {:doc "Protocol for accessing a collection as sequential chunks."}, :methods (-chunked-first -chunked-rest)} {:sym -next, :meta {:doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil", :arglists ([coll])}, :protocol INext} {:sym flatten, :meta {:doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil.", :arglists ([x])}, :source "(defn\n flatten\n \"Takes any nested combination of sequential things (lists, vectors,\\n  etc.) and returns their contents as a single, flat sequence.\\n  (flatten nil) returns nil.\"\n [x]\n (filter\n  (fn* [p1__18469#] (not (sequential? p1__18469#)))\n  (rest (tree-seq sequential? seq x))))\n"} {:sym -dissoc, :meta {:doc "Returns a new collection of coll without the mapping for key k.", :arglists ([coll k])}, :protocol IMap} {:sym doubles, :meta {:doc nil, :arglists ([x])}, :source "(defn doubles [x] x)\n"} {:sym -contains-key?, :meta {:doc "Returns true if k is a key in coll.", :arglists ([coll k])}, :protocol IAssociative} {:sym ifn?, :meta {:doc "Returns true if f returns true for fn? or satisfies IFn.", :arglists ([f])}, :source "(defn\n ifn?\n \"Returns true if f returns true for fn? or satisfies IFn.\"\n [f]\n (or (fn? f) (satisfies? IFn f)))\n"} {:sym IAtom, :meta {:doc "Marker protocol indicating an atom."}, :methods ()} {:sym nat-int?, :meta {:doc "Return true if x satisfies int? and is a natural integer value.", :arglists ([x])}, :source "(defn\n nat-int?\n \"Return true if x satisfies int? and is a natural integer value.\"\n [x]\n (cond\n  (integer? x)\n  (or (not (neg? x)) (zero? x))\n  (instance? goog.math.Integer x)\n  (or (not (.isNegative x)) (.isZero x))\n  (instance? goog.math.Long x)\n  (or (not (.isNegative x)) (.isZero x))\n  :else\n  false))\n"} {:sym IWatchable, :meta {:doc "Protocol for types that can be watched. Currently only implemented by Atom."}, :methods (-add-watch -notify-watches -remove-watch)} {:sym subvec, :meta {:doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :arglists [[v start] [v start end]]}, :source "(defn\n subvec\n \"Returns a persistent vector of the items in vector from\\n  start (inclusive) to end (exclusive).  If end is not supplied,\\n  defaults to (count vector). This operation is O(1) and very fast, as\\n  the resulting vector shares structure with the original and no\\n  trimming is done.\"\n ([v start] (subvec v start (count v)))\n ([v start end]\n  (assert (and (not (nil? start)) (not (nil? end))))\n  (build-subvec nil v start end nil)))\n"} {:sym -pop!, :meta {:doc "Returns tcoll with the last item removed from it.", :arglists ([tcoll])}, :protocol ITransientVector} {:sym partial, :meta {:doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :arglists [[f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]]}, :source "(defn\n partial\n \"Takes a function f and fewer than the normal arguments to f, and\\n  returns a fn that takes a variable number of additional args. When\\n  called, the returned function calls f with args + additional args.\"\n ([f] f)\n ([f arg1]\n  (fn\n   ([] (f arg1))\n   ([x] (f arg1 x))\n   ([x y] (f arg1 x y))\n   ([x y z] (f arg1 x y z))\n   ([x y z & args] (apply f arg1 x y z args))))\n ([f arg1 arg2]\n  (fn\n   ([] (f arg1 arg2))\n   ([x] (f arg1 arg2 x))\n   ([x y] (f arg1 arg2 x y))\n   ([x y z] (f arg1 arg2 x y z))\n   ([x y z & args] (apply f arg1 arg2 x y z args))))\n ([f arg1 arg2 arg3]\n  (fn\n   ([] (f arg1 arg2 arg3))\n   ([x] (f arg1 arg2 arg3 x))\n   ([x y] (f arg1 arg2 arg3 x y))\n   ([x y z] (f arg1 arg2 arg3 x y z))\n   ([x y z & args] (apply f arg1 arg2 arg3 x y z args))))\n ([f arg1 arg2 arg3 & more]\n  (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))\n"} {:sym chunked-seq?, :meta {:doc "Return true if x is satisfies IChunkedSeq.", :arglists ([x])}, :source "(defn\n chunked-seq?\n \"Return true if x is satisfies IChunkedSeq.\"\n [x]\n (implements? IChunkedSeq x))\n"} {:sym replicate, :meta {:doc "DEPRECATED: Use 'repeat' instead.\n  Returns a lazy seq of n xs.", :arglists ([n x])}, :source "(defn\n replicate\n \"DEPRECATED: Use 'repeat' instead.\\n  Returns a lazy seq of n xs.\"\n [n x]\n (take n (repeat x)))\n"} {:sym reduced, :meta {:doc "Wraps x in a way such that a reduce will terminate with the value x", :arglists ([x])}, :source "(defn\n reduced\n \"Wraps x in a way such that a reduce will terminate with the value x\"\n [x]\n (Reduced. x))\n"} {:sym ITransientSet, :meta {:doc "Protocol for adding set functionality to a transient collection."}, :methods (-disjoin!)} {:sym unchecked-byte, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-byte [x] x)\n"} {:sym every-pred, :meta {:doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :arglists [[p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]]}, :source "(defn\n every-pred\n \"Takes a set of predicates and returns a function f that returns true if all of its\\n  composing predicates return a logical true value against all of its arguments, else it returns\\n  false. Note that f is short-circuiting in that it will stop execution on the first\\n  argument that triggers a logical false result against the original predicates.\"\n ([p]\n  (fn\n   ep1\n   ([] true)\n   ([x] (boolean (p x)))\n   ([x y] (boolean (and (p x) (p y))))\n   ([x y z] (boolean (and (p x) (p y) (p z))))\n   ([x y z & args] (boolean (and (ep1 x y z) (every? p args))))))\n ([p1 p2]\n  (fn\n   ep2\n   ([] true)\n   ([x] (boolean (and (p1 x) (p2 x))))\n   ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n   ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n   ([x y z & args]\n    (boolean\n     (and\n      (ep2 x y z)\n      (every?\n       (fn* [p1__18456#] (and (p1 p1__18456#) (p2 p1__18456#)))\n       args))))))\n ([p1 p2 p3]\n  (fn\n   ep3\n   ([] true)\n   ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n   ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n   ([x y z]\n    (boolean\n     (and\n      (p1 x)\n      (p2 x)\n      (p3 x)\n      (p1 y)\n      (p2 y)\n      (p3 y)\n      (p1 z)\n      (p2 z)\n      (p3 z))))\n   ([x y z & args]\n    (boolean\n     (and\n      (ep3 x y z)\n      (every?\n       (fn*\n        [p1__18457#]\n        (and (p1 p1__18457#) (p2 p1__18457#) (p3 p1__18457#)))\n       args))))))\n ([p1 p2 p3 & ps]\n  (let\n   [ps (list* p1 p2 p3 ps)]\n   (fn\n    epn\n    ([] true)\n    ([x] (every? (fn* [p1__18458#] (p1__18458# x)) ps))\n    ([x y]\n     (every?\n      (fn* [p1__18459#] (and (p1__18459# x) (p1__18459# y)))\n      ps))\n    ([x y z]\n     (every?\n      (fn*\n       [p1__18460#]\n       (and (p1__18460# x) (p1__18460# y) (p1__18460# z)))\n      ps))\n    ([x y z & args]\n     (boolean\n      (and\n       (epn x y z)\n       (every? (fn* [p1__18461#] (every? p1__18461# args)) ps))))))))\n"} {:sym missing-protocol, :meta {:doc nil, :arglists ([proto obj])}, :source "(defn\n missing-protocol\n [proto obj]\n (let\n  [ty\n   (type obj)\n   ty\n   (if\n    (and ty (.-cljs$lang$type ty))\n    (.-cljs$lang$ctorStr ty)\n    (goog/typeOf obj))]\n  (js/Error.\n   (.join\n    (array\n     \"No protocol method \"\n     proto\n     \" defined for type \"\n     ty\n     \": \"\n     obj)\n    \"\"))))\n"} {:sym load-file, :meta {:doc nil, :arglists ([file])}, :source "(defn\n load-file\n [file]\n (when-not js/COMPILED (cljs.core/load-file* file)))\n"} {:sym distinct?, :meta {:doc "Returns true if no two of the arguments are =", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n distinct?\n \"Returns true if no two of the arguments are =\"\n ([x] true)\n ([x y] (not (= x y)))\n ([x y & more]\n  (if\n   (not (= x y))\n   (loop\n    [s #{x y} xs more]\n    (let\n     [x (first xs) etc (next xs)]\n     (if xs (if (contains? s x) false (recur (conj s x) etc)) true)))\n   false)))\n"} {:sym pos-int?, :meta {:doc "Return true if x satisfies int? and is positive.", :arglists ([x])}, :source "(defn\n pos-int?\n \"Return true if x satisfies int? and is positive.\"\n [x]\n (cond\n  (integer? x)\n  (pos? x)\n  (instance? goog.math.Integer x)\n  (and (not (.isNegative x)) (not (.isZero x)))\n  (instance? goog.math.Long x)\n  (and (not (.isNegative x)) (not (.isZero x)))\n  :else\n  false))\n"} {:sym unchecked-short, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-short [x] x)\n"} {:sym odd?, :meta {:doc "Returns true if n is odd, throws an exception if n is not an integer", :arglists ([n])}, :source "(defn\n odd?\n \"Returns true if n is odd, throws an exception if n is not an integer\"\n [n]\n (not (even? n)))\n"} {:sym reduceable?, :meta {:doc "Returns true if coll satisfies IReduce", :arglists ([x])}, :source "(defn\n reduceable?\n \"Returns true if coll satisfies IReduce\"\n [x]\n (satisfies? IReduce x))\n"} {:sym string-hash-cache, :meta {}, :source "(def string-hash-cache (js-obj))\n"} {:sym inc, :meta {:doc "Returns a number one greater than num.", :arglists ([x])}, :source "(defn\n inc\n \"Returns a number one greater than num.\"\n [x]\n (cljs.core/+ x 1))\n"} {:sym type->str, :meta {:doc nil, :arglists ([ty])}, :source "(defn type->str [ty] (if-let [s (.-cljs$lang$ctorStr ty)] s (str ty)))\n"} {:sym bit-clear, :meta {:doc "Clear bit at index n", :arglists ([x n])}, :source "(defn bit-clear \"Clear bit at index n\" [x n] (cljs.core/bit-clear x n))\n"} {:sym filter, :meta {:doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n filter\n \"Returns a lazy sequence of the items in coll for which\\n  (pred item) returns true. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\"\n ([pred]\n  (fn\n   [rf]\n   (fn\n    ([] (rf))\n    ([result] (rf result))\n    ([result input] (if (pred input) (rf result input) result)))))\n ([pred coll]\n  (lazy-seq\n   (when-let\n    [s (seq coll)]\n    (if\n     (chunked-seq? s)\n     (let\n      [c (chunk-first s) size (count c) b (chunk-buffer size)]\n      (dotimes\n       [i size]\n       (when (pred (-nth c i)) (chunk-append b (-nth c i))))\n      (chunk-cons (chunk b) (filter pred (chunk-rest s))))\n     (let\n      [f (first s) r (rest s)]\n      (if (pred f) (cons f (filter pred r)) (filter pred r))))))))\n"} {:sym -assoc-n!, :meta {:doc "Returns tcoll with value val added at position n.", :arglists ([tcoll n val])}, :protocol ITransientVector} {:sym IWithMeta, :meta {:doc "Protocol for adding metadata to an object."}, :methods (-with-meta)} {:sym list, :meta {:doc "Creates a new list containing the items.", :arglists ([& xs])}, :source "(defn\n list\n \"Creates a new list containing the items.\"\n [& xs]\n (let\n  [arr\n   (if\n    (and (instance? IndexedSeq xs) (zero? (.-i xs)))\n    (.-arr xs)\n    (let\n     [arr (array)]\n     (loop\n      [xs xs]\n      (if-not\n       (nil? xs)\n       (do (.push arr (-first xs)) (recur (-next xs)))\n       arr))))]\n  (loop\n   [i (alength arr) r ()]\n   (if (> i 0) (recur (dec i) (-conj r (aget arr (dec i)))) r))))\n"} {:sym +, :meta {:doc "Returns the sum of nums. (+) returns 0.", :arglists [[] [x] [x y] [x y & more]]}, :source "(defn\n +\n \"Returns the sum of nums. (+) returns 0.\"\n ([] 0)\n ([x] x)\n ([x y] (cljs.core/+ x y))\n ([x y & more] (reduce + (cljs.core/+ x y) more)))\n"} {:sym aset, :meta {:doc "Sets the value at the index/indices. Works on JavaScript arrays.\n  Returns val.", :arglists [[array idx val] [array idx idx2 & idxv]]}, :source "(defn\n aset\n \"Sets the value at the index/indices. Works on JavaScript arrays.\\n  Returns val.\"\n ([array idx val] (cljs.core/aset array idx val))\n ([array idx idx2 & idxv] (apply aset (aget array idx) idx2 idxv)))\n"} {:sym int-rotate-left, :meta {:doc nil, :arglists ([x n])}, :source "(defn\n int-rotate-left\n [x n]\n (bit-or (bit-shift-left x n) (unsigned-bit-shift-right x (- n))))\n"} {:sym keyword, :meta {:doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :arglists [[name] [ns name]]}, :source "(defn\n keyword\n \"Returns a Keyword with the given namespace and name.  Do not use :\\n  in the keyword strings, it will be added automatically.\"\n ([name]\n  (cond\n   (keyword? name)\n   name\n   (symbol? name)\n   (Keyword.\n    (cljs.core/namespace name)\n    (cljs.core/name name)\n    (.-str name)\n    nil)\n   (string? name)\n   (let\n    [parts (.split name \"/\")]\n    (if\n     (== (alength parts) 2)\n     (Keyword. (aget parts 0) (aget parts 1) name nil)\n     (Keyword. nil (aget parts 0) name nil)))))\n ([ns name]\n  (let\n   [ns\n    (cond\n     (keyword? ns)\n     (cljs.core/name ns)\n     (symbol? ns)\n     (cljs.core/name ns)\n     :else\n     ns)\n    name\n    (cond\n     (keyword? name)\n     (cljs.core/name name)\n     (symbol? name)\n     (cljs.core/name name)\n     :else\n     name)]\n   (Keyword. ns name (str (when ns (str ns \"/\")) name) nil))))\n"} {:sym *ns*, :meta {:doc "Var bound to the current namespace. Only used for bootstrapping."}, :source "(def *ns* nil)\n"} {:sym *assert*, :meta {}, :source "(def *assert* true)\n"} {:sym ICollection, :meta {:doc "Protocol for adding to a collection."}, :methods (-conj)} {:sym chars, :meta {:doc nil, :arglists ([x])}, :source "(defn chars [x] x)\n"} {:sym next, :meta {:doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil", :arglists ([coll])}, :source "(defn\n next\n \"Returns a seq of the items after the first. Calls seq on its\\n  argument.  If there are no more items, returns nil\"\n [coll]\n (when-not\n  (nil? coll)\n  (if (implements? INext coll) (-next coll) (seq (rest coll)))))\n"} {:sym ASeq, :meta {:doc "Marker protocol indicating an array sequence."}, :methods ()} {:sym IFn, :meta {:doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2"}, :methods (-invoke)} {:sym -reset!, :meta {:doc "Sets the value of o to new-value.", :arglists ([o new-value])}, :protocol IReset} {:sym -rest, :meta {:doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()", :arglists ([coll])}, :protocol ISeq} {:sym nil-iter, :meta {:doc nil, :arglists ([])}, :source "(defn\n nil-iter\n []\n (reify\n  Object\n  (hasNext [_] false)\n  (next [_] (js/Error. \"No such element\"))\n  (remove [_] (js/Error. \"Unsupported operation\"))))\n"} {:sym false?, :meta {:doc "Returns true if x is the value false, false otherwise.", :arglists ([x])}, :source "(defn\n false?\n \"Returns true if x is the value false, false otherwise.\"\n [x]\n (cljs.core/false? x))\n"} {:sym *print-readably*, :meta {:doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true"}, :source "(def *print-readably* true)\n"} {:sym ints, :meta {:doc nil, :arglists ([x])}, :source "(defn ints [x] x)\n"} {:sym some-fn, :meta {:doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :arglists [[p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]]}, :source "(defn\n some-fn\n \"Takes a set of predicates and returns a function f that returns the first logical true value\\n  returned by one of its composing predicates against any of its arguments, else it returns\\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\\n  argument that triggers a logical true result against the original predicates.\"\n ([p]\n  (fn\n   sp1\n   ([] nil)\n   ([x] (p x))\n   ([x y] (or (p x) (p y)))\n   ([x y z] (or (p x) (p y) (p z)))\n   ([x y z & args] (or (sp1 x y z) (some p args)))))\n ([p1 p2]\n  (fn\n   sp2\n   ([] nil)\n   ([x] (or (p1 x) (p2 x)))\n   ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n   ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n   ([x y z & args]\n    (or\n     (sp2 x y z)\n     (some\n      (fn* [p1__18462#] (or (p1 p1__18462#) (p2 p1__18462#)))\n      args)))))\n ([p1 p2 p3]\n  (fn\n   sp3\n   ([] nil)\n   ([x] (or (p1 x) (p2 x) (p3 x)))\n   ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n   ([x y z]\n    (or\n     (p1 x)\n     (p2 x)\n     (p3 x)\n     (p1 y)\n     (p2 y)\n     (p3 y)\n     (p1 z)\n     (p2 z)\n     (p3 z)))\n   ([x y z & args]\n    (or\n     (sp3 x y z)\n     (some\n      (fn*\n       [p1__18463#]\n       (or (p1 p1__18463#) (p2 p1__18463#) (p3 p1__18463#)))\n      args)))))\n ([p1 p2 p3 & ps]\n  (let\n   [ps (list* p1 p2 p3 ps)]\n   (fn\n    spn\n    ([] nil)\n    ([x] (some (fn* [p1__18464#] (p1__18464# x)) ps))\n    ([x y]\n     (some (fn* [p1__18465#] (or (p1__18465# x) (p1__18465# y))) ps))\n    ([x y z]\n     (some\n      (fn*\n       [p1__18466#]\n       (or (p1__18466# x) (p1__18466# y) (p1__18466# z)))\n      ps))\n    ([x y z & args]\n     (or\n      (spn x y z)\n      (some (fn* [p1__18467#] (some p1__18467# args)) ps)))))))\n"} {:sym *flush-on-newline*, :meta {:doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true."}, :source "(def *flush-on-newline* true)\n"} {:sym to-array, :meta {:doc "Naive impl of to-array as a start.", :arglists ([s])}, :source "(defn\n to-array\n \"Naive impl of to-array as a start.\"\n [s]\n (let\n  [ary (array)]\n  (loop\n   [s (seq s)]\n   (if-not (nil? s) (do (. ary push (first s)) (recur (next s))) ary))))\n"} {:sym list?, :meta {:doc "Returns true if x implements IList", :arglists ([x])}, :source "(defn\n list?\n \"Returns true if x implements IList\"\n [x]\n (satisfies? IList x))\n"} {:sym array?, :meta {:doc "Returns true if x is a JavaScript array.", :arglists ([x])}, :source "(defn\n array?\n \"Returns true if x is a JavaScript array.\"\n [x]\n (if\n  (identical? *target* \"nodejs\")\n  (.isArray js/Array x)\n  (instance? js/Array x)))\n"} {:sym simple-ident?, :meta {:doc "Return true if x is a symbol or keyword without a namespace", :arglists ([x])}, :source "(defn\n simple-ident?\n \"Return true if x is a symbol or keyword without a namespace\"\n [x]\n (and (ident? x) (nil? (namespace x))))\n"} {:sym clone, :meta {:doc "Clone the supplied value which must implement ICloneable.", :arglists ([value])}, :source "(defn\n clone\n \"Clone the supplied value which must implement ICloneable.\"\n [value]\n (-clone value))\n"} {:sym bit-not, :meta {:doc "Bitwise complement", :arglists ([x])}, :source "(defn bit-not \"Bitwise complement\" [x] (cljs.core/bit-not x))\n"} {:sym byte, :meta {:doc nil, :arglists ([x])}, :source "(defn byte [x] x)\n"} {:sym max, :meta {:doc "Returns the greatest of the nums.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n max\n \"Returns the greatest of the nums.\"\n ([x] x)\n ([x y] (cljs.core/max x y))\n ([x y & more] (reduce max (cljs.core/max x y) more)))\n"} {:sym IComparable, :meta {:doc "Protocol for values that can be compared."}, :methods (-compare)} {:sym ==, :meta {:doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :arglists [[x] [x y] [x y & more]]}, :source "(defn\n ==\n \"Returns non-nil if nums all have the equivalent\\n  value, otherwise false. Behavior on non nums is\\n  undefined.\"\n ([x] true)\n ([x y] (-equiv x y))\n ([x y & more]\n  (if\n   (== x y)\n   (if\n    (next more)\n    (recur y (first more) (next more))\n    (== y (first more)))\n   false)))\n"} {:sym count, :meta {:doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps", :arglists ([coll])}, :source "(defn\n count\n \"Returns the number of items in the collection. (count nil) returns\\n  0.  Also works on strings, arrays, and Maps\"\n [coll]\n (if-not\n  (nil? coll)\n  (cond\n   (implements? ICounted coll)\n   (-count coll)\n   (array? coll)\n   (alength coll)\n   (string? coll)\n   (.-length coll)\n   (implements? ISeqable coll)\n   (accumulating-seq-count coll)\n   :else\n   (-count coll))\n  0))\n"} {:sym -disjoin!, :meta {:doc "Returns tcoll without v.", :arglists ([tcoll v])}, :protocol ITransientSet} {:sym *loaded-libs*, :meta {}, :source "(defonce *loaded-libs* nil)\n"} {:sym apply, :meta {:doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :arglists [[f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]]}, :source "(defn\n apply\n \"Applies fn f to the argument list formed by prepending intervening arguments to args.\"\n ([f args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (bounded-count (inc fixed-arity) args)]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc args)\n     (.cljs$lang$applyTo f args)))\n   (apply-to-simple f (seq args))))\n ([f x args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (inc (bounded-count fixed-arity args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x (seq args))))\n ([f x y args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x y args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 2 (bounded-count (dec fixed-arity) args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x y (seq args))))\n ([f x y z args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [arglist\n     (list* x y z args)\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 3 (bounded-count (- fixed-arity 2) args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f x y z (seq args))))\n ([f a b c d & args]\n  (if\n   (.-cljs$lang$applyTo f)\n   (let\n    [spread-args\n     (spread args)\n     arglist\n     (cons a (cons b (cons c (cons d spread-args))))\n     fixed-arity\n     (.-cljs$lang$maxFixedArity f)\n     bc\n     (+ 4 (bounded-count (- fixed-arity 3) spread-args))]\n    (if\n     (<= bc fixed-arity)\n     (apply-to f bc arglist)\n     (.cljs$lang$applyTo f arglist)))\n   (apply-to-simple f a b c d (spread args)))))\n"} {:sym add-to-string-hash-cache, :meta {:doc nil, :arglists ([k])}, :source "(defn\n add-to-string-hash-cache\n [k]\n (let\n  [h (hash-string* k)]\n  (gobject/set string-hash-cache k h)\n  (set! string-hash-cache-count (inc string-hash-cache-count))\n  h))\n"} {:sym IChunkedNext, :meta {:doc "Protocol for accessing the chunks of a collection."}, :methods (-chunked-next)} {:sym interpose, :meta {:doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", :arglists [[sep] [sep coll]]}, :source "(defn\n interpose\n \"Returns a lazy seq of the elements of coll separated by sep.\\n  Returns a stateful transducer when no collection is provided.\"\n ([sep]\n  (fn\n   [rf]\n   (let\n    [started (volatile! false)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (if\n       @started\n       (let\n        [sepr (rf result sep)]\n        (if (reduced? sepr) sepr (rf sepr input)))\n       (do (vreset! started true) (rf result input))))))))\n ([sep coll] (drop 1 (interleave (repeat sep) coll))))\n"} {:sym deref, :meta {:doc "Also reader macro: @var/@atom/@delay. Returns the\n   most-recently-committed value of ref. When applied to a var\n   or atom, returns its current state. When applied to a delay, forces\n   it if not already forced. See also - realized?.", :arglists ([o])}, :source "(defn\n deref\n \"Also reader macro: @var/@atom/@delay. Returns the\\n   most-recently-committed value of ref. When applied to a var\\n   or atom, returns its current state. When applied to a delay, forces\\n   it if not already forced. See also - realized?.\"\n [o]\n (-deref o))\n"} {:sym assoc, :meta {:doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index.", :arglists [[coll k v] [coll k v & kvs]]}, :source "(defn\n assoc\n \"assoc[iate]. When applied to a map, returns a new map of the\\n   same (hashed/sorted) type, that contains the mapping of key(s) to\\n   val(s). When applied to a vector, returns a new vector that\\n   contains val at index.\"\n ([coll k v] (if-not (nil? coll) (-assoc coll k v) (array-map k v)))\n ([coll k v & kvs]\n  (let\n   [ret (assoc coll k v)]\n   (if kvs (recur ret (first kvs) (second kvs) (nnext kvs)) ret))))\n"} {:sym transient, :meta {:doc "Returns a new, transient version of the collection, in constant time.", :arglists ([coll])}, :source "(defn\n transient\n \"Returns a new, transient version of the collection, in constant time.\"\n [coll]\n (-as-transient coll))\n"} {:sym -disjoin, :meta {:doc "Returns a new collection of coll that does not contain v.", :arglists ([coll v])}, :protocol ISet} {:sym chunk-cons, :meta {:doc nil, :arglists ([chunk rest])}, :source "(defn\n chunk-cons\n [chunk rest]\n (if (zero? (-count chunk)) rest (ChunkedCons. chunk rest nil nil)))\n"} {:sym drop-while, :meta {:doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :arglists [[pred] [pred coll]]}, :source "(defn\n drop-while\n \"Returns a lazy sequence of the items in coll starting from the\\n  first item for which (pred item) returns logical false.  Returns a\\n  stateful transducer when no collection is provided.\"\n ([pred]\n  (fn\n   [rf]\n   (let\n    [da (volatile! true)]\n    (fn\n     ([] (rf))\n     ([result] (rf result))\n     ([result input]\n      (let\n       [drop? @da]\n       (if\n        (and drop? (pred input))\n        result\n        (do (vreset! da nil) (rf result input)))))))))\n ([pred coll]\n  (let\n   [step\n    (fn\n     [pred coll]\n     (let\n      [s (seq coll)]\n      (if (and s (pred (first s))) (recur pred (rest s)) s)))]\n   (lazy-seq (step pred coll)))))\n"} {:sym IWriter, :meta {:doc "Protocol for writing. Currently only implemented by StringBufferWriter."}, :methods (-flush -write)} {:sym *print-fn*, :meta {:doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed."}, :source "(defonce *print-fn* nil)\n"} {:sym compare, :meta {:doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object.", :arglists ([x y])}, :source "(defn\n compare\n \"Comparator. Returns a negative number, zero, or a positive number\\n  when x is logically 'less than', 'equal to', or 'greater than'\\n  y. Uses IComparable if available and google.array.defaultCompare for objects\\n of the same type and special-cases nil to be less than any other object.\"\n [x y]\n (cond\n  (identical? x y)\n  0\n  (nil? x)\n  -1\n  (nil? y)\n  1\n  (number? x)\n  (if\n   (number? y)\n   (garray/defaultCompare x y)\n   (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))\n  (satisfies? IComparable x)\n  (-compare x y)\n  :else\n  (if\n   (and\n    (or (string? x) (array? x) (true? x) (false? x))\n    (identical? (type x) (type y)))\n   (garray/defaultCompare x y)\n   (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))))\n"} {:sym complement, :meta {:doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", :arglists ([f])}, :source "(defn\n complement\n \"Takes a fn f and returns a fn that takes the same arguments as f,\\n  has the same effects, if any, and returns the opposite truth value.\"\n [f]\n (fn\n  ([] (not (f)))\n  ([x] (not (f x)))\n  ([x y] (not (f x y)))\n  ([x y & zs] (not (apply f x y zs)))))\n"} {:sym -assoc!, :meta {:doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.", :arglists ([tcoll key val])}, :protocol ITransientAssociative} {:sym *print-dup*, :meta {:doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false."}, :source "(def *print-dup* false)\n"} {:sym string-iter, :meta {:doc nil, :arglists ([x])}, :source "(defn string-iter [x] (StringIter. x 0))\n"} {:sym IDeref, :meta {:doc "Protocol for adding dereference functionality to a reference."}, :methods (-deref)} {:sym sequence, :meta {:doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :arglists [[coll] [xform coll] [xform coll & colls]]}, :source "(defn\n sequence\n \"Coerces coll to a (possibly empty) sequence, if it is not already\\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\\n  transducer is supplied, returns a lazy sequence of applications of\\n  the transform to the items in coll(s), i.e. to the set of first\\n  items of each coll, followed by the set of second\\n  items in each coll, until any one of the colls is exhausted.  Any\\n  remaining items in other colls are ignored. The transform should accept\\n  number-of-colls arguments\"\n ([coll] (if (seq? coll) coll (or (seq coll) ())))\n ([xform coll]\n  (or\n   (chunkIteratorSeq (.create TransformerIterator xform (iter coll)))\n   ()))\n ([xform coll & colls]\n  (or\n   (chunkIteratorSeq\n    (.createMulti\n     TransformerIterator\n     xform\n     (map iter (cons coll colls))))\n   ())))\n"} {:sym constantly, :meta {:doc "Returns a function that takes any number of arguments and returns x.", :arglists ([x])}, :source "(defn\n constantly\n \"Returns a function that takes any number of arguments and returns x.\"\n [x]\n (fn [& args] x))\n"} {:sym chunked-seq, :meta {:doc nil, :arglists [[vec i off] [vec node i off] [vec node i off meta]]}, :source "(defn\n chunked-seq\n ([vec i off] (ChunkedSeq. vec (array-for vec i) i off nil nil))\n ([vec node i off] (ChunkedSeq. vec node i off nil nil))\n ([vec node i off meta] (ChunkedSeq. vec node i off meta nil)))\n"} {:sym ISorted, :meta {:doc "Protocol for a collection which can represent their items\n  in a sorted manner. "}, :methods (-comparator -entry-key -sorted-seq -sorted-seq-from)} {:sym make-array, :meta {:doc "Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments.", :arglists [[size] [type size] [type size & more-sizes]]}, :source "(defn\n make-array\n \"Construct a JavaScript array of the specified dimensions. Accepts ignored\\n  type argument for compatibility with Clojure. Note that there is no efficient\\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\\n  will run in polynomial time when called with 3 or more arguments.\"\n ([size] (js/Array. size))\n ([type size] (make-array size))\n ([type size & more-sizes]\n  (let\n   [dims more-sizes dimarray (make-array size)]\n   (dotimes\n    [i (alength dimarray)]\n    (aset dimarray i (apply make-array nil dims)))\n   dimarray)))\n"} {:sym shorts, :meta {:doc nil, :arglists ([x])}, :source "(defn shorts [x] x)\n"} {:sym *unchecked-if*, :meta {}, :source "(def *unchecked-if* false)\n"} {:sym enable-console-print!, :meta {:doc "Set *print-fn* to console.log", :arglists ([])}, :source "(defn\n enable-console-print!\n \"Set *print-fn* to console.log\"\n []\n (set! *print-newline* false)\n (set!\n  *print-fn*\n  (fn\n   [& args]\n   (.apply (.-log js/console) js/console (into-array args))))\n (set!\n  *print-err-fn*\n  (fn\n   [& args]\n   (.apply (.-error js/console) js/console (into-array args))))\n nil)\n"} {:sym -flush, :meta {:doc "Flush writer.", :arglists ([writer])}, :protocol IWriter} {:sym completing, :meta {:doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :arglists [[f] [f cf]]}, :source "(defn\n completing\n \"Takes a reducing function f of 2 args and returns a fn suitable for\\n  transduce by adding an arity-1 signature that calls cf (default -\\n  identity) on the result argument.\"\n ([f] (completing f identity))\n ([f cf] (fn ([] (f)) ([x] (cf x)) ([x y] (f x y)))))\n"} {:sym unchecked-negate-int, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-negate-int [x] (cljs.core/unchecked-negate-int x))\n"} {:sym hash-unordered-coll, :meta {:doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.", :arglists ([coll])}, :source "(defn\n hash-unordered-coll\n \"Returns the hash code, consistent with =, for an external unordered\\n   collection implementing Iterable. For maps, the iterator should\\n   return map entries whose hash is computed as\\n     (hash-ordered-coll [k v]).\\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n [coll]\n (loop\n  [n 0 hash-code 0 coll (seq coll)]\n  (if-not\n   (nil? coll)\n   (recur\n    (inc n)\n    (bit-or (+ hash-code (hash (first coll))) 0)\n    (next coll))\n   (mix-collection-hash hash-code n))))\n"} {:sym repeat, :meta {:doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :arglists [[x] [n x]]}, :source "(defn\n repeat\n \"Returns a lazy (infinite!, or length n if supplied) sequence of xs.\"\n ([x] (lazy-seq (cons x (repeat x))))\n ([n x] (take n (repeat x))))\n"} {:sym unchecked-inc, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-inc [x] (cljs.core/unchecked-inc x))\n"} {:sym nthnext, :meta {:doc "Returns the nth next of coll, (seq coll) when n is 0.", :arglists ([coll n])}, :source "(defn\n nthnext\n \"Returns the nth next of coll, (seq coll) when n is 0.\"\n [coll n]\n (loop\n  [n n xs (seq coll)]\n  (if (and xs (pos? n)) (recur (dec n) (next xs)) xs)))\n"} {:sym get-validator, :meta {:doc "Gets the validator-fn for a var/ref/agent/atom.", :arglists ([iref])}, :source "(defn\n get-validator\n \"Gets the validator-fn for a var/ref/agent/atom.\"\n [iref]\n (.-validator iref))\n"} {:sym number?, :meta {:doc "Returns true if x is a JavaScript number.", :arglists ([x])}, :source "(defn\n number?\n \"Returns true if x is a JavaScript number.\"\n [x]\n (cljs.core/number? x))\n"} {:sym -conj!, :meta {:doc "Adds value val to tcoll and returns tcoll.", :arglists ([tcoll val])}, :protocol ITransientCollection} {:sym chunk-next, :meta {:doc nil, :arglists ([s])}, :source "(defn\n chunk-next\n [s]\n (if\n  (implements? IChunkedNext s)\n  (-chunked-next s)\n  (seq (-chunked-rest s))))\n"} {:sym not-any?, :meta {:doc "Returns false if (pred x) is logical true for any x in coll,\n  else true.", :arglists ([pred coll])}, :source "(defn\n not-any?\n \"Returns false if (pred x) is logical true for any x in coll,\\n  else true.\"\n [pred coll]\n (not (some pred coll)))\n"} {:sym into-array, :meta {:doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.", :arglists [[aseq] [type aseq]]}, :source "(defn\n into-array\n \"Returns an array with components set to the values in aseq. Optional type\\n  argument accepted for compatibility with Clojure.\"\n ([aseq] (into-array nil aseq))\n ([type aseq] (reduce (fn [a x] (.push a x) a) (array) aseq)))\n"} {:sym -hash, :meta {:doc "Returns the hash code of o.", :arglists ([o])}, :protocol IHash} {:sym qualified-symbol?, :meta {:doc "Return true if x is a symbol with a namespace", :arglists ([x])}, :source "(defn\n qualified-symbol?\n \"Return true if x is a symbol with a namespace\"\n [x]\n (boolean (and (symbol? x) (namespace x) true)))\n"} {:sym -dissoc!, :meta {:doc "Returns a new transient collection of tcoll without the mapping for key.", :arglists ([tcoll key])}, :protocol ITransientMap} {:sym chunk-buffer, :meta {:doc nil, :arglists ([capacity])}, :source "(defn chunk-buffer [capacity] (ChunkBuffer. (make-array capacity) 0))\n"} {:sym seqable?, :meta {:doc "Return true if the seq function is supported for s", :arglists ([s])}, :source "(defn\n seqable?\n \"Return true if the seq function is supported for s\"\n [s]\n (or (satisfies? ISeqable s) (array? s) (string? s)))\n"} {:sym symbol?, :meta {:doc "Return true if x is a Symbol", :arglists ([x])}, :source "(defn symbol? \"Return true if x is a Symbol\" [x] (instance? Symbol x))\n"} {:sym m3-hash-unencoded-chars, :meta {:doc nil, :arglists ([in])}, :source "(defn\n m3-hash-unencoded-chars\n [in]\n (let\n  [h1\n   (loop\n    [i 1 h1 m3-seed]\n    (if\n     (< i (.-length in))\n     (recur\n      (+ i 2)\n      (m3-mix-H1\n       h1\n       (m3-mix-K1\n        (bit-or\n         (.charCodeAt in (dec i))\n         (bit-shift-left (.charCodeAt in i) 16)))))\n     h1))\n   h1\n   (if\n    (== (bit-and (.-length in) 1) 1)\n    (bit-xor h1 (m3-mix-K1 (.charCodeAt in (dec (.-length in)))))\n    h1)]\n  (m3-fmix h1 (imul 2 (.-length in)))))\n"} {:sym unchecked-char, :meta {:doc nil, :arglists ([x])}, :source "(defn unchecked-char [x] x)\n"} {:sym system-time, :meta {:doc "Returns highest resolution time offered by host in milliseconds.", :arglists ([])}, :source "(defn\n system-time\n \"Returns highest resolution time offered by host in milliseconds.\"\n []\n (cond\n  (and (exists? js/performance) (not (nil? (. js/performance -now))))\n  (.now js/performance)\n  (and (exists? js/process) (not (nil? (. js/process -hrtime))))\n  (let\n   [t (.hrtime js/process)]\n   (/ (+ (* (aget t 0) 1.0E9) (aget t 1)) 1000000.0))\n  :else\n  (.getTime (js/Date.))))\n"} {:sym -invoke, :meta {:doc nil, :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest])}, :protocol IFn} {:sym coll?, :meta {:doc "Returns true if x satisfies ICollection", :arglists ([x])}, :source "(defn\n coll?\n \"Returns true if x satisfies ICollection\"\n [x]\n (if (nil? x) false (satisfies? ICollection x)))\n"} {:sym get-in, :meta {:doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied.", :arglists [[m ks] [m ks not-found]]}, :source "(defn\n get-in\n \"Returns the value in a nested associative structure,\\n  where ks is a sequence of keys. Returns nil if the key is not present,\\n  or the not-found value if supplied.\"\n {:added \"1.2\", :static true}\n ([m ks] (reduce get m ks))\n ([m ks not-found]\n  (loop\n   [sentinel lookup-sentinel m m ks (seq ks)]\n   (if-not\n    (nil? ks)\n    (let\n     [m (get m (first ks) sentinel)]\n     (if\n      (identical? sentinel m)\n      not-found\n      (recur sentinel m (next ks))))\n    m))))\n"} {:sym fnext, :meta {:doc "Same as (first (next x))", :arglists ([coll])}, :source "(defn fnext \"Same as (first (next x))\" [coll] (first (next coll)))\n"} {:sym IList, :meta {:doc "Marker interface indicating a persistent list"}, :methods ()} {:sym -val, :meta {:doc "Returns the value of the map entry.", :arglists ([coll])}, :protocol IMapEntry} {:sym bytes, :meta {:doc nil, :arglists ([x])}, :source "(defn bytes [x] x)\n"} {:sym -seq, :meta {:doc "Returns a seq of o, or nil if o is empty.", :arglists ([o])}, :protocol ISeqable}), cljs.core.async ({:sym Pub, :meta {:doc nil}, :methods (sub* unsub* unsub-all*)} {:sym reduce, :meta {:doc "f should be a function of 2 arguments. Returns a channel containing\n  the single result of applying f to init and the first item from the\n  channel, then applying f to that result and the 2nd item, etc. If\n  the channel closes without yielding items, returns init and f is not\n  called. ch must close before reduce produces a result.", :arglists ([f init ch])}, :source "(defn\n reduce\n \"f should be a function of 2 arguments. Returns a channel containing\\n  the single result of applying f to init and the first item from the\\n  channel, then applying f to that result and the 2nd item, etc. If\\n  the channel closes without yielding items, returns init and f is not\\n  called. ch must close before reduce produces a result.\"\n [f init ch]\n (go-loop\n  [ret init]\n  (let\n   [v (<! ch)]\n   (if\n    (nil? v)\n    ret\n    (let [ret' (f ret v)] (if (reduced? ret') @ret' (recur ret')))))))\n"} {:sym remove>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([p ch])}, :source "(defn\n remove>\n \"Deprecated - this function will be removed. Use transducer instead\"\n [p ch]\n (filter> (complement p) ch))\n"} {:sym timeout, :meta {:doc "Returns a channel that will close after msecs", :arglists ([msecs])}, :source "(defn\n timeout\n \"Returns a channel that will close after msecs\"\n [msecs]\n (timers/timeout msecs))\n"} {:sym unsub*, :meta {:doc nil, :arglists ([p v ch])}, :protocol Pub} {:sym admix*, :meta {:doc nil, :arglists ([m ch])}, :protocol Mix} {:sym unmix*, :meta {:doc nil, :arglists ([m ch])}, :protocol Mix} {:sym mix, :meta {:doc "Creates and returns a mix of one or more input channels which will\n  be put on the supplied out channel. Input sources can be added to\n  the mix with 'admix', and removed with 'unmix'. A mix supports\n  soloing, muting and pausing multiple inputs atomically using\n  'toggle', and can solo using either muting or pausing as determined\n  by 'solo-mode'.\n\n  Each channel can have zero or more boolean modes set via 'toggle':\n\n  :solo - when true, only this (ond other soloed) channel(s) will appear\n          in the mix output channel. :mute and :pause states of soloed\n          channels are ignored. If solo-mode is :mute, non-soloed\n          channels are muted, if :pause, non-soloed channels are\n          paused.\n\n  :mute - muted channels will have their contents consumed but not included in the mix\n  :pause - paused channels will not have their contents consumed (and thus also not included in the mix)\n", :arglists ([out])}, :source "(defn\n mix\n \"Creates and returns a mix of one or more input channels which will\\n  be put on the supplied out channel. Input sources can be added to\\n  the mix with 'admix', and removed with 'unmix'. A mix supports\\n  soloing, muting and pausing multiple inputs atomically using\\n  'toggle', and can solo using either muting or pausing as determined\\n  by 'solo-mode'.\\n\\n  Each channel can have zero or more boolean modes set via 'toggle':\\n\\n  :solo - when true, only this (ond other soloed) channel(s) will appear\\n          in the mix output channel. :mute and :pause states of soloed\\n          channels are ignored. If solo-mode is :mute, non-soloed\\n          channels are muted, if :pause, non-soloed channels are\\n          paused.\\n\\n  :mute - muted channels will have their contents consumed but not included in the mix\\n  :pause - paused channels will not have their contents consumed (and thus also not included in the mix)\\n\"\n [out]\n (let\n  [cs\n   (atom {})\n   solo-modes\n   #{:pause :mute}\n   attrs\n   (conj solo-modes :solo)\n   solo-mode\n   (atom :mute)\n   change\n   (chan)\n   changed\n   (fn* [] (put! change true))\n   pick\n   (fn\n    [attr chs]\n    (reduce-kv (fn [ret c v] (if (attr v) (conj ret c) ret)) #{} chs))\n   calc-state\n   (fn\n    []\n    (let\n     [chs\n      @cs\n      mode\n      @solo-mode\n      solos\n      (pick :solo chs)\n      pauses\n      (pick :pause chs)]\n     {:solos solos,\n      :mutes (pick :mute chs),\n      :reads\n      (conj\n       (if\n        (and (= mode :pause) (not (empty? solos)))\n        (vec solos)\n        (vec (remove pauses (keys chs))))\n       change)}))\n   m\n   (reify\n    Mux\n    (muxch* [_] out)\n    Mix\n    (admix* [_ ch] (swap! cs assoc ch {}) (changed))\n    (unmix* [_ ch] (swap! cs dissoc ch) (changed))\n    (unmix-all* [_] (reset! cs {}) (changed))\n    (toggle*\n     [_ state-map]\n     (swap! cs (partial merge-with cljs.core/merge) state-map)\n     (changed))\n    (solo-mode*\n     [_ mode]\n     (assert\n      (solo-modes mode)\n      (str \"mode must be one of: \" solo-modes))\n     (reset! solo-mode mode)\n     (changed)))]\n  (go-loop\n   [{:keys [solos mutes reads], :as state} (calc-state)]\n   (let\n    [[v c] (alts! reads)]\n    (if\n     (or (nil? v) (= c change))\n     (do (when (nil? v) (swap! cs dissoc c)) (recur (calc-state)))\n     (if\n      (or (solos c) (and (empty? solos) (not (mutes c))))\n      (when (>! out v) (recur state))\n      (recur state)))))\n  m))\n"} {:sym pub, :meta {:doc "Creates and returns a pub(lication) of the supplied channel,\n  partitioned into topics by the topic-fn. topic-fn will be applied to\n  each value on the channel and the result will determine the 'topic'\n  on which that value will be put. Channels can be subscribed to\n  receive copies of topics using 'sub', and unsubscribed using\n  'unsub'. Each topic will be handled by an internal mult on a\n  dedicated channel. By default these internal channels are\n  unbuffered, but a buf-fn can be supplied which, given a topic,\n  creates a buffer with desired properties.\n\n  Each item is distributed to all subs in parallel and synchronously,\n  i.e. each sub must accept before the next item is distributed. Use\n  buffering/windowing to prevent slow subs from holding up the pub.\n\n  Items received when there are no matching subs get dropped.\n\n  Note that if buf-fns are used then each topic is handled\n  asynchronously, i.e. if a channel is subscribed to more than one\n  topic it should not expect them to be interleaved identically with\n  the source.", :arglists [[ch topic-fn] [ch topic-fn buf-fn]]}, :source "(defn\n pub\n \"Creates and returns a pub(lication) of the supplied channel,\\n  partitioned into topics by the topic-fn. topic-fn will be applied to\\n  each value on the channel and the result will determine the 'topic'\\n  on which that value will be put. Channels can be subscribed to\\n  receive copies of topics using 'sub', and unsubscribed using\\n  'unsub'. Each topic will be handled by an internal mult on a\\n  dedicated channel. By default these internal channels are\\n  unbuffered, but a buf-fn can be supplied which, given a topic,\\n  creates a buffer with desired properties.\\n\\n  Each item is distributed to all subs in parallel and synchronously,\\n  i.e. each sub must accept before the next item is distributed. Use\\n  buffering/windowing to prevent slow subs from holding up the pub.\\n\\n  Items received when there are no matching subs get dropped.\\n\\n  Note that if buf-fns are used then each topic is handled\\n  asynchronously, i.e. if a channel is subscribed to more than one\\n  topic it should not expect them to be interleaved identically with\\n  the source.\"\n ([ch topic-fn] (pub ch topic-fn (constantly nil)))\n ([ch topic-fn buf-fn]\n  (let\n   [mults\n    (atom {})\n    ensure-mult\n    (fn\n     [topic]\n     (or\n      (get @mults topic)\n      (get\n       (swap!\n        mults\n        (fn*\n         [p1__18453#]\n         (if\n          (p1__18453# topic)\n          p1__18453#\n          (assoc p1__18453# topic (mult (chan (buf-fn topic)))))))\n       topic)))\n    p\n    (reify\n     Mux\n     (muxch* [_] ch)\n     Pub\n     (sub*\n      [p topic ch close?]\n      (let [m (ensure-mult topic)] (tap m ch close?)))\n     (unsub*\n      [p topic ch]\n      (when-let [m (get @mults topic)] (untap m ch)))\n     (unsub-all* [_] (reset! mults {}))\n     (unsub-all* [_ topic] (swap! mults dissoc topic)))]\n   (go-loop\n    []\n    (let\n     [val (<! ch)]\n     (if\n      (nil? val)\n      (doseq [m (vals @mults)] (close! (muxch* m)))\n      (let\n       [topic (topic-fn val) m (get @mults topic)]\n       (when\n        m\n        (when-not (>! (muxch* m) val) (swap! mults dissoc topic)))\n       (recur)))))\n   p)))\n"} {:sym take, :meta {:doc "Returns a channel that will return, at most, n items from ch. After n items\n   have been returned, or ch has been closed, the return chanel will close.\n\n  The output channel is unbuffered by default, unless buf-or-n is given.", :arglists [[n ch] [n ch buf-or-n]]}, :source "(defn\n take\n \"Returns a channel that will return, at most, n items from ch. After n items\\n   have been returned, or ch has been closed, the return chanel will close.\\n\\n  The output channel is unbuffered by default, unless buf-or-n is given.\"\n ([n ch] (take n ch nil))\n ([n ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go\n    (loop\n     [x 0]\n     (when\n      (< x n)\n      (let\n       [v (<! ch)]\n       (when (not (nil? v)) (>! out v) (recur (inc x))))))\n    (close! out))\n   out)))\n"} {:sym unsub-all*, :meta {:doc nil, :arglists ([p] [p v])}, :protocol Pub} {:sym <!, :meta {:doc "takes a val from port. Must be called inside a (go ...) block. Will\n  return nil if closed. Will park if nothing is available.\n  Returns true unless port is already closed", :arglists ([port])}, :source "(defn\n <!\n \"takes a val from port. Must be called inside a (go ...) block. Will\\n  return nil if closed. Will park if nothing is available.\\n  Returns true unless port is already closed\"\n [port]\n (throw (js/Error. \"<! used not in (go ...) block\")))\n"} {:sym map, :meta {:doc "Takes a function and a collection of source channels, and returns a\n  channel which contains the values produced by applying f to the set\n  of first items taken from each source channel, followed by applying\n  f to the set of second items from each channel, until any one of the\n  channels is closed, at which point the output channel will be\n  closed. The returned channel will be unbuffered by default, or a\n  buf-or-n can be supplied", :arglists [[f chs] [f chs buf-or-n]]}, :source "(defn\n map\n \"Takes a function and a collection of source channels, and returns a\\n  channel which contains the values produced by applying f to the set\\n  of first items taken from each source channel, followed by applying\\n  f to the set of second items from each channel, until any one of the\\n  channels is closed, at which point the output channel will be\\n  closed. The returned channel will be unbuffered by default, or a\\n  buf-or-n can be supplied\"\n ([f chs] (map f chs nil))\n ([f chs buf-or-n]\n  (let\n   [chs\n    (vec chs)\n    out\n    (chan buf-or-n)\n    cnt\n    (count chs)\n    rets\n    (object-array cnt)\n    dchan\n    (chan 1)\n    dctr\n    (atom nil)\n    done\n    (mapv\n     (fn\n      [i]\n      (fn\n       [ret]\n       (aset rets i ret)\n       (when (zero? (swap! dctr dec)) (put! dchan (.slice rets 0)))))\n     (range cnt))]\n   (go-loop\n    []\n    (reset! dctr cnt)\n    (dotimes\n     [i cnt]\n     (try\n      (take! (chs i) (done i))\n      (catch js/Object e (swap! dctr dec))))\n    (let\n     [rets (<! dchan)]\n     (if\n      (some nil? rets)\n      (close! out)\n      (do (>! out (apply f rets)) (recur)))))\n   out)))\n"} {:sym Mux, :meta {:doc nil}, :methods (muxch*)} {:sym mapcat>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[f out] [f out buf-or-n]]}, :source "(defn\n mapcat>\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([f out] (mapcat> f out nil))\n ([f out buf-or-n] (let [in (chan buf-or-n)] (mapcat* f in out) in)))\n"} {:sym buffer, :meta {:doc "Returns a fixed buffer of size n. When full, puts will block/park.", :arglists ([n])}, :source "(defn\n buffer\n \"Returns a fixed buffer of size n. When full, puts will block/park.\"\n [n]\n (buffers/fixed-buffer n))\n"} {:sym close!, :meta {:doc nil, :arglists [[port]]}, :source "(defn close! ([port] (impl/close! port)))\n"} {:sym offer!, :meta {:doc "Puts a val into port if it's possible to do so immediately.\n  nil values are not allowed. Never blocks. Returns true if offer succeeds.", :arglists ([port val])}, :source "(defn\n offer!\n \"Puts a val into port if it's possible to do so immediately.\\n  nil values are not allowed. Never blocks. Returns true if offer succeeds.\"\n [port val]\n (let\n  [ret (impl/put! port val (fn-handler nop false))]\n  (when ret @ret)))\n"} {:sym chan, :meta {:doc "Creates a channel with an optional buffer, an optional transducer (like (map f),\n  (filter p) etc or a composition thereof), and an optional exception handler.\n  If buf-or-n is a number, will create and use a fixed buffer of that size. If a\n  transducer is supplied a buffer must be specified. ex-handler must be a\n  fn of one argument - if an exception occurs during transformation it will be called\n  with the thrown value as an argument, and any non-nil return value will be placed\n  in the channel.", :arglists [[] [buf-or-n] [buf-or-n xform] [buf-or-n xform ex-handler]]}, :source "(defn\n chan\n \"Creates a channel with an optional buffer, an optional transducer (like (map f),\\n  (filter p) etc or a composition thereof), and an optional exception handler.\\n  If buf-or-n is a number, will create and use a fixed buffer of that size. If a\\n  transducer is supplied a buffer must be specified. ex-handler must be a\\n  fn of one argument - if an exception occurs during transformation it will be called\\n  with the thrown value as an argument, and any non-nil return value will be placed\\n  in the channel.\"\n ([] (chan nil))\n ([buf-or-n] (chan buf-or-n nil nil))\n ([buf-or-n xform] (chan buf-or-n xform nil))\n ([buf-or-n xform ex-handler]\n  (let\n   [buf-or-n (if (= buf-or-n 0) nil buf-or-n)]\n   (when\n    xform\n    (assert buf-or-n \"buffer must be supplied when transducer is\"))\n   (channels/chan\n    (if (number? buf-or-n) (buffer buf-or-n) buf-or-n)\n    xform\n    ex-handler))))\n"} {:sym solo-mode*, :meta {:doc nil, :arglists ([m mode])}, :protocol Mix} {:sym tap, :meta {:doc "Copies the mult source onto the supplied channel.\n\n  By default the channel will be closed when the source closes,\n  but can be determined by the close? parameter.", :arglists [[mult ch] [mult ch close?]]}, :source "(defn\n tap\n \"Copies the mult source onto the supplied channel.\\n\\n  By default the channel will be closed when the source closes,\\n  but can be determined by the close? parameter.\"\n ([mult ch] (tap mult ch true))\n ([mult ch close?] (tap* mult ch close?) ch))\n"} {:sym admix, :meta {:doc "Adds ch as an input to the mix", :arglists ([mix ch])}, :source "(defn admix \"Adds ch as an input to the mix\" [mix ch] (admix* mix ch))\n"} {:sym promise-chan, :meta {:doc "Creates a promise channel with an optional transducer, and an optional\n  exception-handler. A promise channel can take exactly one value that consumers\n  will receive. Once full, puts complete but val is dropped (no transfer).\n  Consumers will block until either a value is placed in the channel or the\n  channel is closed. See chan for the semantics of xform and ex-handler.", :arglists [[] [xform] [xform ex-handler]]}, :source "(defn\n promise-chan\n \"Creates a promise channel with an optional transducer, and an optional\\n  exception-handler. A promise channel can take exactly one value that consumers\\n  will receive. Once full, puts complete but val is dropped (no transfer).\\n  Consumers will block until either a value is placed in the channel or the\\n  channel is closed. See chan for the semantics of xform and ex-handler.\"\n ([] (promise-chan nil))\n ([xform] (promise-chan xform nil))\n ([xform ex-handler] (chan (buffers/promise-buffer) xform ex-handler)))\n"} {:sym unique, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[ch] [ch buf-or-n]]}, :source "(defn\n unique\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([ch] (unique ch nil))\n ([ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go\n    (loop\n     [last nil]\n     (let\n      [v (<! ch)]\n      (when\n       (not (nil? v))\n       (if (= v last) (recur last) (do (>! out v) (recur v))))))\n    (close! out))\n   out)))\n"} {:sym muxch*, :meta {:doc nil, :arglists ([_])}, :protocol Mux} {:sym solo-mode, :meta {:doc "Sets the solo mode of the mix. mode must be one of :mute or :pause", :arglists ([mix mode])}, :source "(defn\n solo-mode\n \"Sets the solo mode of the mix. mode must be one of :mute or :pause\"\n [mix mode]\n (solo-mode* mix mode))\n"} {:sym transduce, :meta {:doc "async/reduces a channel with a transformation (xform f).\n  Returns a channel containing the result.  ch must close before\n  transduce produces a result.", :arglists ([xform f init ch])}, :source "(defn\n transduce\n \"async/reduces a channel with a transformation (xform f).\\n  Returns a channel containing the result.  ch must close before\\n  transduce produces a result.\"\n [xform f init ch]\n (let [f (xform f)] (go (let [ret (<! (reduce f init ch))] (f ret)))))\n"} {:sym onto-chan, :meta {:doc "Puts the contents of coll into the supplied channel.\n\n  By default the channel will be closed after the items are copied,\n  but can be determined by the close? parameter.\n\n  Returns a channel which will close after the items are copied.", :arglists [[ch coll] [ch coll close?]]}, :source "(defn\n onto-chan\n \"Puts the contents of coll into the supplied channel.\\n\\n  By default the channel will be closed after the items are copied,\\n  but can be determined by the close? parameter.\\n\\n  Returns a channel which will close after the items are copied.\"\n ([ch coll] (onto-chan ch coll true))\n ([ch coll close?]\n  (go-loop\n   [vs (seq coll)]\n   (if\n    (and vs (>! ch (first vs)))\n    (recur (next vs))\n    (when close? (close! ch))))))\n"} {:sym to-chan, :meta {:doc "Creates and returns a channel which contains the contents of coll,\n  closing when exhausted.", :arglists ([coll])}, :source "(defn\n to-chan\n \"Creates and returns a channel which contains the contents of coll,\\n  closing when exhausted.\"\n [coll]\n (let [ch (chan (bounded-count 100 coll))] (onto-chan ch coll) ch))\n"} {:sym dropping-buffer, :meta {:doc "Returns a buffer of size n. When full, puts will complete but\n  val will be dropped (no transfer).", :arglists ([n])}, :source "(defn\n dropping-buffer\n \"Returns a buffer of size n. When full, puts will complete but\\n  val will be dropped (no transfer).\"\n [n]\n (buffers/dropping-buffer n))\n"} {:sym untap-all, :meta {:doc "Disconnects all target channels from a mult", :arglists ([mult])}, :source "(defn\n untap-all\n \"Disconnects all target channels from a mult\"\n [mult]\n (untap-all* mult))\n"} {:sym into, :meta {:doc "Returns a channel containing the single (collection) result of the\n  items taken from the channel conjoined to the supplied\n  collection. ch must close before into produces a result.", :arglists ([coll ch])}, :source "(defn\n into\n \"Returns a channel containing the single (collection) result of the\\n  items taken from the channel conjoined to the supplied\\n  collection. ch must close before into produces a result.\"\n [coll ch]\n (reduce conj coll ch))\n"} {:sym pipeline, :meta {:doc "Takes elements from the from channel and supplies them to the to\n  channel, subject to the transducer xf, with parallelism n. Because\n  it is parallel, the transducer will be applied independently to each\n  element, not across elements, and may produce zero or more outputs\n  per input.  Outputs will be returned in order relative to the\n  inputs. By default, the to channel will be closed when the from\n  channel closes, but can be determined by the close?  parameter. Will\n  stop consuming the from channel if the to channel closes.\n\n  Note this is supplied for API compatibility with the Clojure version.\n  Values of N > 1 will not result in actual concurrency in a\n  single-threaded runtime.", :arglists [[n to xf from] [n to xf from close?] [n to xf from close? ex-handler]]}, :source "(defn\n pipeline\n \"Takes elements from the from channel and supplies them to the to\\n  channel, subject to the transducer xf, with parallelism n. Because\\n  it is parallel, the transducer will be applied independently to each\\n  element, not across elements, and may produce zero or more outputs\\n  per input.  Outputs will be returned in order relative to the\\n  inputs. By default, the to channel will be closed when the from\\n  channel closes, but can be determined by the close?  parameter. Will\\n  stop consuming the from channel if the to channel closes.\\n\\n  Note this is supplied for API compatibility with the Clojure version.\\n  Values of N > 1 will not result in actual concurrency in a\\n  single-threaded runtime.\"\n ([n to xf from] (pipeline n to xf from true))\n ([n to xf from close?] (pipeline n to xf from close? nil))\n ([n to xf from close? ex-handler]\n  (pipeline* n to xf from close? ex-handler :compute)))\n"} {:sym sub, :meta {:doc "Subscribes a channel to a topic of a pub.\n\n  By default the channel will be closed when the source closes,\n  but can be determined by the close? parameter.", :arglists [[p topic ch] [p topic ch close?]]}, :source "(defn\n sub\n \"Subscribes a channel to a topic of a pub.\\n\\n  By default the channel will be closed when the source closes,\\n  but can be determined by the close? parameter.\"\n ([p topic ch] (sub p topic ch true))\n ([p topic ch close?] (sub* p topic ch close?)))\n"} {:sym map>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([f ch])}, :source "(defn\n map>\n \"Deprecated - this function will be removed. Use transducer instead\"\n [f ch]\n (reify\n  impl/Channel\n  (close! [_] (impl/close! ch))\n  impl/ReadPort\n  (take! [_ fn1] (impl/take! ch fn1))\n  impl/WritePort\n  (put! [_ val fn1] (impl/put! ch (f val) fn1))))\n"} {:sym pipe, :meta {:doc "Takes elements from the from channel and supplies them to the to\n   channel. By default, the to channel will be closed when the from\n   channel closes, but can be determined by the close?  parameter. Will\n   stop consuming the from channel if the to channel closes", :arglists [[from to] [from to close?]]}, :source "(defn\n pipe\n \"Takes elements from the from channel and supplies them to the to\\n   channel. By default, the to channel will be closed when the from\\n   channel closes, but can be determined by the close?  parameter. Will\\n   stop consuming the from channel if the to channel closes\"\n ([from to] (pipe from to true))\n ([from to close?]\n  (go-loop\n   []\n   (let\n    [v (<! from)]\n    (if (nil? v) (when close? (close! to)) (when (>! to v) (recur)))))\n  to))\n"} {:sym unmix, :meta {:doc "Removes ch as an input to the mix", :arglists ([mix ch])}, :source "(defn\n unmix\n \"Removes ch as an input to the mix\"\n [mix ch]\n (unmix* mix ch))\n"} {:sym filter<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[p ch] [p ch buf-or-n]]}, :source "(defn\n filter<\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([p ch] (filter< p ch nil))\n ([p ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go-loop\n    []\n    (let\n     [val (<! ch)]\n     (if\n      (nil? val)\n      (close! out)\n      (do (when (p val) (>! out val)) (recur)))))\n   out)))\n"} {:sym sub*, :meta {:doc nil, :arglists ([p v ch close?])}, :protocol Pub} {:sym remove<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[p ch] [p ch buf-or-n]]}, :source "(defn\n remove<\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([p ch] (remove< p ch nil))\n ([p ch buf-or-n] (filter< (complement p) ch buf-or-n)))\n"} {:sym untap*, :meta {:doc nil, :arglists ([m ch])}, :protocol Mult} {:sym toggle, :meta {:doc "Atomically sets the state(s) of one or more channels in a mix. The\n  state map is a map of channels -> channel-state-map. A\n  channel-state-map is a map of attrs -> boolean, where attr is one or\n  more of :mute, :pause or :solo. Any states supplied are merged with\n  the current state.\n\n  Note that channels can be added to a mix via toggle, which can be\n  used to add channels in a particular (e.g. paused) state.", :arglists ([mix state-map])}, :source "(defn\n toggle\n \"Atomically sets the state(s) of one or more channels in a mix. The\\n  state map is a map of channels -> channel-state-map. A\\n  channel-state-map is a map of attrs -> boolean, where attr is one or\\n  more of :mute, :pause or :solo. Any states supplied are merged with\\n  the current state.\\n\\n  Note that channels can be added to a mix via toggle, which can be\\n  used to add channels in a particular (e.g. paused) state.\"\n [mix state-map]\n (toggle* mix state-map))\n"} {:sym untap-all*, :meta {:doc nil, :arglists ([m])}, :protocol Mult} {:sym sliding-buffer, :meta {:doc "Returns a buffer of size n. When full, puts will complete, and be\n  buffered, but oldest elements in buffer will be dropped (not\n  transferred).", :arglists ([n])}, :source "(defn\n sliding-buffer\n \"Returns a buffer of size n. When full, puts will complete, and be\\n  buffered, but oldest elements in buffer will be dropped (not\\n  transferred).\"\n [n]\n (buffers/sliding-buffer n))\n"} {:sym partition, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[n ch] [n ch buf-or-n]]}, :source "(defn\n partition\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([n ch] (partition n ch nil))\n ([n ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go\n    (loop\n     [arr (make-array n) idx 0]\n     (let\n      [v (<! ch)]\n      (if\n       (not (nil? v))\n       (do\n        (aset arr idx v)\n        (let\n         [new-idx (inc idx)]\n         (if\n          (< new-idx n)\n          (recur arr new-idx)\n          (do (>! out (vec arr)) (recur (make-array n) 0)))))\n       (do (when (> idx 0) (>! out (vec arr))) (close! out))))))\n   out)))\n"} {:sym Mult, :meta {:doc nil}, :methods (tap* untap* untap-all*)} {:sym merge, :meta {:doc "Takes a collection of source channels and returns a channel which\n  contains all values taken from them. The returned channel will be\n  unbuffered by default, or a buf-or-n can be supplied. The channel\n  will close after all the source channels have closed.", :arglists [[chs] [chs buf-or-n]]}, :source "(defn\n merge\n \"Takes a collection of source channels and returns a channel which\\n  contains all values taken from them. The returned channel will be\\n  unbuffered by default, or a buf-or-n can be supplied. The channel\\n  will close after all the source channels have closed.\"\n ([chs] (merge chs nil))\n ([chs buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go-loop\n    [cs (vec chs)]\n    (if\n     (pos? (count cs))\n     (let\n      [[v c] (alts! cs)]\n      (if\n       (nil? v)\n       (recur (filterv (fn* [p1__18454#] (not= c p1__18454#)) cs))\n       (do (>! out v) (recur cs))))\n     (close! out)))\n   out)))\n"} {:sym partition-by, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[f ch] [f ch buf-or-n]]}, :source "(defn\n partition-by\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([f ch] (partition-by f ch nil))\n ([f ch buf-or-n]\n  (let\n   [out (chan buf-or-n)]\n   (go\n    (loop\n     [lst (make-array 0) last :clojure.core/nothing]\n     (let\n      [v (<! ch)]\n      (if\n       (not (nil? v))\n       (let\n        [new-itm (f v)]\n        (if\n         (or\n          (= new-itm last)\n          (keyword-identical? last :clojure.core/nothing))\n         (do (.push lst v) (recur lst new-itm))\n         (do\n          (>! out (vec lst))\n          (let\n           [new-lst (make-array 0)]\n           (.push new-lst v)\n           (recur new-lst new-itm)))))\n       (do\n        (when (> (alength lst) 0) (>! out (vec lst)))\n        (close! out))))))\n   out)))\n"} {:sym unsub-all, :meta {:doc "Unsubscribes all channels from a pub, or a topic of a pub", :arglists [[p] [p topic]]}, :source "(defn\n unsub-all\n \"Unsubscribes all channels from a pub, or a topic of a pub\"\n ([p] (unsub-all* p))\n ([p topic] (unsub-all* p topic)))\n"} {:sym >!, :meta {:doc "puts a val into port. nil values are not allowed. Must be called\n  inside a (go ...) block. Will park if no buffer space is available.\n  Returns true unless port is already closed.", :arglists ([port val])}, :source "(defn\n >!\n \"puts a val into port. nil values are not allowed. Must be called\\n  inside a (go ...) block. Will park if no buffer space is available.\\n  Returns true unless port is already closed.\"\n [port val]\n (throw (js/Error. \">! used not in (go ...) block\")))\n"} {:sym unmix-all*, :meta {:doc nil, :arglists ([m])}, :protocol Mix} {:sym split, :meta {:doc "Takes a predicate and a source channel and returns a vector of two\n  channels, the first of which will contain the values for which the\n  predicate returned true, the second those for which it returned\n  false.\n\n  The out channels will be unbuffered by default, or two buf-or-ns can\n  be supplied. The channels will close after the source channel has\n  closed.", :arglists [[p ch] [p ch t-buf-or-n f-buf-or-n]]}, :source "(defn\n split\n \"Takes a predicate and a source channel and returns a vector of two\\n  channels, the first of which will contain the values for which the\\n  predicate returned true, the second those for which it returned\\n  false.\\n\\n  The out channels will be unbuffered by default, or two buf-or-ns can\\n  be supplied. The channels will close after the source channel has\\n  closed.\"\n ([p ch] (split p ch nil nil))\n ([p ch t-buf-or-n f-buf-or-n]\n  (let\n   [tc (chan t-buf-or-n) fc (chan f-buf-or-n)]\n   (go-loop\n    []\n    (let\n     [v (<! ch)]\n     (if\n      (nil? v)\n      (do (close! tc) (close! fc))\n      (when (>! (if (p v) tc fc) v) (recur)))))\n   [tc fc])))\n"} {:sym unmix-all, :meta {:doc "removes all inputs from the mix", :arglists ([mix])}, :source "(defn\n unmix-all\n \"removes all inputs from the mix\"\n [mix]\n (unmix-all* mix))\n"} {:sym filter>, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([p ch])}, :source "(defn\n filter>\n \"Deprecated - this function will be removed. Use transducer instead\"\n [p ch]\n (reify\n  impl/Channel\n  (close! [_] (impl/close! ch))\n  (closed? [_] (impl/closed? ch))\n  impl/ReadPort\n  (take! [_ fn1] (impl/take! ch fn1))\n  impl/WritePort\n  (put!\n   [_ val fn1]\n   (if\n    (p val)\n    (impl/put! ch val fn1)\n    (channels/box (not (impl/closed? ch)))))))\n"} {:sym tap*, :meta {:doc nil, :arglists ([m ch close?])}, :protocol Mult} {:sym untap, :meta {:doc "Disconnects a target channel from a mult", :arglists ([mult ch])}, :source "(defn\n untap\n \"Disconnects a target channel from a mult\"\n [mult ch]\n (untap* mult ch))\n"} {:sym alts!, :meta {:doc "Completes at most one of several channel operations. Must be called\n   inside a (go ...) block. ports is a vector of channel endpoints,\n   which can be either a channel to take from or a vector of\n  [channel-to-put-to val-to-put], in any combination. Takes will be\n  made as if by <!, and puts will be made as if by >!. Unless\n  the :priority option is true, if more than one port operation is\n  ready a non-deterministic choice will be made. If no operation is\n  ready and a :default value is supplied, [default-val :default] will\n  be returned, otherwise alts! will park until the first operation to\n  become ready completes. Returns [val port] of the completed\n  operation, where val is the value taken for takes, and a\n  boolean (true unless already closed, as per put!) for puts.\n\n  opts are passed as :key val ... Supported options:\n\n  :default val - the value to use if none of the operations are immediately ready\n  :priority true - (default nil) when true, the operations will be tried in order.\n\n  Note: there is no guarantee that the port exps or val exprs will be\n  used, nor in what order should they be, so they should not be\n  depended upon for side effects.", :arglists ([ports & {:as opts}])}, :source "(defn\n alts!\n \"Completes at most one of several channel operations. Must be called\\n   inside a (go ...) block. ports is a vector of channel endpoints,\\n   which can be either a channel to take from or a vector of\\n  [channel-to-put-to val-to-put], in any combination. Takes will be\\n  made as if by <!, and puts will be made as if by >!. Unless\\n  the :priority option is true, if more than one port operation is\\n  ready a non-deterministic choice will be made. If no operation is\\n  ready and a :default value is supplied, [default-val :default] will\\n  be returned, otherwise alts! will park until the first operation to\\n  become ready completes. Returns [val port] of the completed\\n  operation, where val is the value taken for takes, and a\\n  boolean (true unless already closed, as per put!) for puts.\\n\\n  opts are passed as :key val ... Supported options:\\n\\n  :default val - the value to use if none of the operations are immediately ready\\n  :priority true - (default nil) when true, the operations will be tried in order.\\n\\n  Note: there is no guarantee that the port exps or val exprs will be\\n  used, nor in what order should they be, so they should not be\\n  depended upon for side effects.\"\n [ports & {:as opts}]\n (throw (js/Error. \"alts! used not in (go ...) block\")))\n"} {:sym unsub, :meta {:doc "Unsubscribes a channel from a topic of a pub", :arglists ([p topic ch])}, :source "(defn\n unsub\n \"Unsubscribes a channel from a topic of a pub\"\n [p topic ch]\n (unsub* p topic ch))\n"} {:sym poll!, :meta {:doc "Takes a val from port if it's possible to do so immediately.\n  Never blocks. Returns value if successful, nil otherwise.", :arglists ([port])}, :source "(defn\n poll!\n \"Takes a val from port if it's possible to do so immediately.\\n  Never blocks. Returns value if successful, nil otherwise.\"\n [port]\n (let [ret (impl/take! port (fn-handler nop false))] (when ret @ret)))\n"} {:sym map<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists ([f ch])}, :source "(defn\n map<\n \"Deprecated - this function will be removed. Use transducer instead\"\n [f ch]\n (reify\n  impl/Channel\n  (close! [_] (impl/close! ch))\n  (closed? [_] (impl/closed? ch))\n  impl/ReadPort\n  (take!\n   [_ fn1]\n   (let\n    [ret\n     (impl/take!\n      ch\n      (reify\n       impl/Handler\n       (active? [_] (impl/active? fn1))\n       (blockable? [_] true)\n       (commit\n        [_]\n        (let\n         [f1 (impl/commit fn1)]\n         (fn*\n          [p1__18455#]\n          (f1 (if (nil? p1__18455#) nil (f p1__18455#))))))))]\n    (if (and ret (not (nil? @ret))) (channels/box (f @ret)) ret)))\n  impl/WritePort\n  (put! [_ val fn1] (impl/put! ch val fn1))))\n"} {:sym do-alts, :meta {:doc "returns derefable [val port] if immediate, nil if enqueued", :arglists ([fret ports opts])}, :source "(defn\n do-alts\n \"returns derefable [val port] if immediate, nil if enqueued\"\n [fret ports opts]\n (let\n  [flag\n   (alt-flag)\n   n\n   (count ports)\n   idxs\n   (random-array n)\n   priority\n   (:priority opts)\n   ret\n   (loop\n    [i 0]\n    (when\n     (< i n)\n     (let\n      [idx\n       (if priority i (aget idxs i))\n       port\n       (nth ports idx)\n       wport\n       (when (vector? port) (port 0))\n       vbox\n       (if\n        wport\n        (let\n         [val (port 1)]\n         (impl/put!\n          wport\n          val\n          (alt-handler\n           flag\n           (fn* [p1__18451#] (fret [p1__18451# wport])))))\n        (impl/take!\n         port\n         (alt-handler\n          flag\n          (fn* [p1__18452#] (fret [p1__18452# port])))))]\n      (if\n       vbox\n       (channels/box [@vbox (or wport port)])\n       (recur (inc i))))))]\n  (or\n   ret\n   (when\n    (contains? opts :default)\n    (when-let\n     [got (and (impl/active? flag) (impl/commit flag))]\n     (channels/box [(:default opts) :default]))))))\n"} {:sym pipeline-async, :meta {:doc "Takes elements from the from channel and supplies them to the to\n  channel, subject to the async function af, with parallelism n. af\n  must be a function of two arguments, the first an input value and\n  the second a channel on which to place the result(s). af must close!\n  the channel before returning.  The presumption is that af will\n  return immediately, having launched some asynchronous operation\n  whose completion/callback will manipulate the result channel. Outputs\n  will be returned in order relative to  the inputs. By default, the to\n  channel will be closed when the from channel closes, but can be\n  determined by the close?  parameter. Will stop consuming the from\n  channel if the to channel closes.", :arglists [[n to af from] [n to af from close?]]}, :source "(defn\n pipeline-async\n \"Takes elements from the from channel and supplies them to the to\\n  channel, subject to the async function af, with parallelism n. af\\n  must be a function of two arguments, the first an input value and\\n  the second a channel on which to place the result(s). af must close!\\n  the channel before returning.  The presumption is that af will\\n  return immediately, having launched some asynchronous operation\\n  whose completion/callback will manipulate the result channel. Outputs\\n  will be returned in order relative to  the inputs. By default, the to\\n  channel will be closed when the from channel closes, but can be\\n  determined by the close?  parameter. Will stop consuming the from\\n  channel if the to channel closes.\"\n ([n to af from] (pipeline-async n to af from true))\n ([n to af from close?] (pipeline* n to af from close? nil :async)))\n"} {:sym Mix, :meta {:doc nil}, :methods (admix* solo-mode* toggle* unmix* unmix-all*)} {:sym toggle*, :meta {:doc nil, :arglists ([m state-map])}, :protocol Mix} {:sym mult, :meta {:doc "Creates and returns a mult(iple) of the supplied channel. Channels\n  containing copies of the channel can be created with 'tap', and\n  detached with 'untap'.\n\n  Each item is distributed to all taps in parallel and synchronously,\n  i.e. each tap must accept before the next item is distributed. Use\n  buffering/windowing to prevent slow taps from holding up the mult.\n\n  Items received when there are no taps get dropped.\n\n  If a tap puts to a closed channel, it will be removed from the mult.", :arglists ([ch])}, :source "(defn\n mult\n \"Creates and returns a mult(iple) of the supplied channel. Channels\\n  containing copies of the channel can be created with 'tap', and\\n  detached with 'untap'.\\n\\n  Each item is distributed to all taps in parallel and synchronously,\\n  i.e. each tap must accept before the next item is distributed. Use\\n  buffering/windowing to prevent slow taps from holding up the mult.\\n\\n  Items received when there are no taps get dropped.\\n\\n  If a tap puts to a closed channel, it will be removed from the mult.\"\n [ch]\n (let\n  [cs\n   (atom {})\n   m\n   (reify\n    Mux\n    (muxch* [_] ch)\n    Mult\n    (tap* [_ ch close?] (swap! cs assoc ch close?) nil)\n    (untap* [_ ch] (swap! cs dissoc ch) nil)\n    (untap-all* [_] (reset! cs {}) nil))\n   dchan\n   (chan 1)\n   dctr\n   (atom nil)\n   done\n   (fn [_] (when (zero? (swap! dctr dec)) (put! dchan true)))]\n  (go-loop\n   []\n   (let\n    [val (<! ch)]\n    (if\n     (nil? val)\n     (doseq [[c close?] @cs] (when close? (close! c)))\n     (let\n      [chs (keys @cs)]\n      (reset! dctr (count chs))\n      (doseq\n       [c chs]\n       (when-not (put! c val done) (done nil) (untap* m c)))\n      (when (seq chs) (<! dchan))\n      (recur)))))\n  m))\n"} {:sym mapcat<, :meta {:doc "Deprecated - this function will be removed. Use transducer instead", :arglists [[f in] [f in buf-or-n]]}, :source "(defn\n mapcat<\n \"Deprecated - this function will be removed. Use transducer instead\"\n ([f in] (mapcat< f in nil))\n ([f in buf-or-n] (let [out (chan buf-or-n)] (mapcat* f in out) out)))\n"} {:sym ioc-alts!, :meta {:doc nil, :arglists ([state cont-block ports & {:as opts}])}, :source "(defn\n ioc-alts!\n [state cont-block ports & {:as opts}]\n (ioc/aset-all! state helpers/STATE-IDX cont-block)\n (when-let\n  [cb\n   (cljs.core.async/do-alts\n    (fn\n     [val]\n     (ioc/aset-all! state helpers/VALUE-IDX val)\n     (helpers/run-state-machine-wrapped state))\n    ports\n    opts)]\n  (ioc/aset-all! state helpers/VALUE-IDX @cb)\n  :recur))\n"} {:sym unblocking-buffer?, :meta {:doc "Returns true if a channel created with buff will never block. That is to say,\n   puts into this buffer will never cause the buffer to be full. ", :arglists ([buff])}, :source "(defn\n unblocking-buffer?\n \"Returns true if a channel created with buff will never block. That is to say,\\n   puts into this buffer will never cause the buffer to be full. \"\n [buff]\n (satisfies? impl/UnblockingBuffer buff))\n"} {:sym put!, :meta {:doc "Asynchronously puts a val into port, calling fn0 (if supplied) when\n   complete. nil values are not allowed. Will throw if closed. If\n   on-caller? (default true) is true, and the put is immediately\n   accepted, will call fn0 on calling thread.  Returns nil.", :arglists [[port val] [port val fn1] [port val fn1 on-caller?]]}, :source "(defn\n put!\n \"Asynchronously puts a val into port, calling fn0 (if supplied) when\\n   complete. nil values are not allowed. Will throw if closed. If\\n   on-caller? (default true) is true, and the put is immediately\\n   accepted, will call fn0 on calling thread.  Returns nil.\"\n ([port val] (if-let [ret (impl/put! port val fhnop)] @ret true))\n ([port val fn1] (put! port val fn1 true))\n ([port val fn1 on-caller?]\n  (if-let\n   [retb (impl/put! port val (fn-handler fn1))]\n   (let\n    [ret @retb]\n    (if on-caller? (fn1 ret) (dispatch/run (fn* [] (fn1 ret))))\n    ret)\n   true)))\n"} {:sym take!, :meta {:doc "Asynchronously takes a val from port, passing to fn1. Will pass nil\n   if closed. If on-caller? (default true) is true, and value is\n   immediately available, will call fn1 on calling thread.\n   Returns nil.", :arglists [[port fn1] [port fn1 on-caller?]]}, :source "(defn\n take!\n \"Asynchronously takes a val from port, passing to fn1. Will pass nil\\n   if closed. If on-caller? (default true) is true, and value is\\n   immediately available, will call fn1 on calling thread.\\n   Returns nil.\"\n ([port fn1] (take! port fn1 true))\n ([port fn1 on-caller?]\n  (let\n   [ret (impl/take! port (fn-handler fn1))]\n   (when\n    ret\n    (let\n     [val @ret]\n     (if on-caller? (fn1 val) (dispatch/run (fn* [] (fn1 val))))))\n   nil)))\n"}), cljs.core.async.impl.buffers ({:sym acopy, :meta {:doc nil, :arglists ([src src-start dest dest-start len])}, :source "(defn\n acopy\n [src src-start dest dest-start len]\n (loop\n  [cnt 0]\n  (when\n   (< cnt len)\n   (aset dest (+ dest-start cnt) (aget src (+ src-start cnt)))\n   (recur (inc cnt)))))\n"} {:sym ring-buffer, :meta {:doc nil, :arglists ([n])}, :source "(defn\n ring-buffer\n [n]\n (assert (> n 0) \"Can't create a ring buffer of size 0\")\n (RingBuffer. 0 0 0 (make-array n)))\n"} {:sym fixed-buffer, :meta {:doc nil, :arglists ([n])}, :source "(defn fixed-buffer [n] (FixedBuffer. (ring-buffer n) n))\n"} {:sym dropping-buffer, :meta {:doc nil, :arglists ([n])}, :source "(defn dropping-buffer [n] (DroppingBuffer. (ring-buffer n) n))\n"} {:sym sliding-buffer, :meta {:doc nil, :arglists ([n])}, :source "(defn sliding-buffer [n] (SlidingBuffer. (ring-buffer n) n))\n"} {:sym promise-buffer, :meta {:doc nil, :arglists ([])}, :source "(defn promise-buffer [] (PromiseBuffer. NO-VAL))\n"}), cljs.core.async.impl.protocols ({:sym remove!, :meta {:doc "remove and return next item from buffer, called under chan mutex", :arglists ([b])}, :protocol Buffer} {:sym close-buf!, :meta {:doc "called on chan closed under chan mutex, return ignored", :arglists ([b])}, :protocol Buffer} {:sym close!, :meta {:doc nil, :arglists ([chan])}, :protocol Channel} {:sym Handler, :meta {:doc nil}, :methods (active? blockable? commit)} {:sym blockable?, :meta {:doc "returns true if this handler may be blocked, otherwise it must not block", :arglists ([h])}, :protocol Handler} {:sym active?, :meta {:doc "returns true if has callback. Must work w/o lock", :arglists ([h])}, :protocol Handler} {:sym Buffer, :meta {:doc nil}, :methods (add!* close-buf! full? remove!)} {:sym full?, :meta {:doc "returns true if buffer cannot accept put", :arglists ([b])}, :protocol Buffer} {:sym add!, :meta {:doc nil, :arglists [[b] [b itm]]}, :source "(defn add! ([b] b) ([b itm] (assert (not (nil? itm))) (add!* b itm)))\n"} {:sym add!*, :meta {:doc "if room, add item to the buffer, returns b, called under chan mutex", :arglists ([b itm])}, :protocol Buffer} {:sym ReadPort, :meta {:doc nil}, :methods (take!)} {:sym Channel, :meta {:doc nil}, :methods (close! closed?)} {:sym closed?, :meta {:doc nil, :arglists ([chan])}, :protocol Channel} {:sym UnblockingBuffer, :meta {:doc nil}, :methods ()} {:sym MAX-QUEUE-SIZE, :meta {}, :source "(def MAX-QUEUE-SIZE 1024)\n"} {:sym commit, :meta {:doc "commit to fulfilling its end of the transfer, returns cb. Must be called within lock", :arglists ([h])}, :protocol Handler} {:sym put!, :meta {:doc "derefable boolean (false if already closed) if handled, nil if put was enqueued.\n                               Must throw on nil val.", :arglists ([port val fn1-handler])}, :protocol WritePort} {:sym take!, :meta {:doc "derefable val if taken, nil if take was enqueued", :arglists ([port fn1-handler])}, :protocol ReadPort} {:sym WritePort, :meta {:doc nil}, :methods (put!)}), cljs.pprint ({:sym pprint, :meta {:doc nil, :arglists [[object] [object writer]]}, :source "(defn\n pprint\n ([object]\n  (let\n   [sb (StringBuffer.)]\n   (binding\n    [*out* (StringBufferWriter. sb)]\n    (pprint object *out*)\n    (string-print (str sb)))))\n ([object writer]\n  (with-pretty-writer\n   writer\n   (binding [*print-pretty* true] (write-out object))\n   (if (not (= 0 (get-column *out*))) (-write *out* \\newline)))))\n"} {:sym get-pretty-writer, :meta {:doc "Returns the IWriter passed in wrapped in a pretty writer proxy, unless it's\nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\nwrite, and cl-format all call it if they need to. However if you want the state to be\npreserved across calls, you will want to wrap them with this.\n\nFor example, when you want to generate column-aware output with multiple calls to cl-format,\ndo it like in this example:\n\n    (defn print-table [aseq column-width]\n      (binding [*out* (get-pretty-writer *out*)]\n        (doseq [row aseq]\n          (doseq [col row]\n            (cl-format true \"~4D~7,vT\" col column-width))\n          (prn))))\n\nNow when you run:\n\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\n\nIt prints a table of squares and cubes for the numbers from 1 to 10:\n\n       1      1       1\n       2      4       8\n       3      9      27\n       4     16      64\n       5     25     125\n       6     36     216\n       7     49     343\n       8     64     512\n       9     81     729\n      10    100    1000", :arglists ([writer])}, :source "(defn\n get-pretty-writer\n \"Returns the IWriter passed in wrapped in a pretty writer proxy, unless it's\\nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\\nwrite, and cl-format all call it if they need to. However if you want the state to be\\npreserved across calls, you will want to wrap them with this.\\n\\nFor example, when you want to generate column-aware output with multiple calls to cl-format,\\ndo it like in this example:\\n\\n    (defn print-table [aseq column-width]\\n      (binding [*out* (get-pretty-writer *out*)]\\n        (doseq [row aseq]\\n          (doseq [col row]\\n            (cl-format true \\\"~4D~7,vT\\\" col column-width))\\n          (prn))))\\n\\nNow when you run:\\n\\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\\n\\nIt prints a table of squares and cubes for the numbers from 1 to 10:\\n\\n       1      1       1\\n       2      4       8\\n       3      9      27\\n       4     16      64\\n       5     25     125\\n       6     36     216\\n       7     49     343\\n       8     64     512\\n       9     81     729\\n      10    100    1000\"\n [writer]\n (if\n  (pretty-writer? writer)\n  writer\n  (pretty-writer writer *print-right-margin* *print-miser-width*)))\n"} {:sym *print-suppress-namespaces*, :meta {:doc "Don't print namespaces with symbols. This is particularly useful when\npretty printing the results of macro expansions"}, :source "(def *print-suppress-namespaces* nil)\n"} {:sym char-code, :meta {:doc "Convert char to int", :arglists ([c])}, :source "(defn\n char-code\n \"Convert char to int\"\n [c]\n (cond\n  (number? c)\n  c\n  (and (string? c) (== (.-length c) 1))\n  (.charCodeAt c 0)\n  :else\n  (throw (js/Error. \"Argument to char must be a character or number\"))))\n"} {:sym *print-pretty*, :meta {:doc "Bind to true if you want write to use pretty printing"}, :source "(def *print-pretty* true)\n"} {:sym *print-pprint-dispatch*, :meta {:doc "The pretty print dispatch function. Use with-pprint-dispatch or\nset-pprint-dispatch to modify."}, :source "(defonce *print-pprint-dispatch* nil)\n"} {:sym pprint-newline, :meta {:doc "Print a conditional newline to a pretty printing stream. kind specifies if the\n  newline is :linear, :miser, :fill, or :mandatory.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Output is sent to *out* which must be a pretty printing writer.", :arglists ([kind])}, :source "(defn\n pprint-newline\n \"Print a conditional newline to a pretty printing stream. kind specifies if the\\n  newline is :linear, :miser, :fill, or :mandatory.\\n\\n  This function is intended for use when writing custom dispatch functions.\\n\\n  Output is sent to *out* which must be a pretty printing writer.\"\n [kind]\n (check-enumerated-arg kind #{:mandatory :miser :fill :linear})\n (nl *out* kind))\n"} {:sym float?, :meta {:doc "Returns true if n is an float.", :arglists ([n])}, :source "(defn\n float?\n \"Returns true if n is an float.\"\n [n]\n (and\n  (number? n)\n  (not (js/isNaN n))\n  (not (identical? n js/Infinity))\n  (not (== (js/parseFloat n) (js/parseInt n 10)))))\n"} {:sym pprint-tab, :meta {:doc "Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative.\n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED.", :arglists ([kind colnum colinc])}, :source "(defn\n pprint-tab\n \"Tab at this point in the pretty printing stream. kind specifies whether the tab\\nis :line, :section, :line-relative, or :section-relative.\\n\\nColnum and colinc specify the target column and the increment to move the target\\nforward if the output is already past the original target.\\n\\nThis function is intended for use when writing custom dispatch functions.\\n\\nOutput is sent to *out* which must be a pretty printing writer.\\n\\nTHIS FUNCTION IS NOT YET IMPLEMENTED.\"\n {:added \"1.2\"}\n [kind colnum colinc]\n (check-enumerated-arg\n  kind\n  #{:section :line :line-relative :section-relative})\n (throw (js/Error. \"pprint-tab is not yet implemented\")))\n"} {:sym pprint-set, :meta {}, :source "(def pprint-set (formatter-out \"~<#{~;~@{~w~^ ~:_~}~;}~:>\"))\n"} {:sym print-table, :meta {:doc "Prints a collection of maps in a textual table. Prints table headings\n   ks, and then a line of output for each row, corresponding to the keys\n   in ks. If ks are not specified, use the keys of the first item in rows.", :arglists [[ks rows] [rows]]}, :source "(defn\n print-table\n \"Prints a collection of maps in a textual table. Prints table headings\\n   ks, and then a line of output for each row, corresponding to the keys\\n   in ks. If ks are not specified, use the keys of the first item in rows.\"\n {:added \"1.3\"}\n ([ks rows]\n  (binding\n   [*print-newline*]\n   (when\n    (seq rows)\n    (let\n     [widths\n      (map\n       (fn\n        [k]\n        (apply\n         max\n         (count (str k))\n         (map\n          (fn* [p1__18531#] (count (str (get p1__18531# k))))\n          rows)))\n       ks)\n      spacers\n      (map\n       (fn* [p1__18532#] (apply str (repeat p1__18532# \"-\")))\n       widths)\n      fmt-row\n      (fn\n       [leader divider trailer row]\n       (str\n        leader\n        (apply\n         str\n         (interpose\n          divider\n          (for\n           [[col width]\n            (map\n             vector\n             (map (fn* [p1__18533#] (get row p1__18533#)) ks)\n             widths)]\n           (add-padding width (str col)))))\n        trailer))]\n     (cljs.core/println)\n     (cljs.core/println (fmt-row \"| \" \" | \" \" |\" (zipmap ks ks)))\n     (cljs.core/println (fmt-row \"|-\" \"-+-\" \"-|\" (zipmap ks spacers)))\n     (doseq\n      [row rows]\n      (cljs.core/println (fmt-row \"| \" \" | \" \" |\" row)))))))\n ([rows] (print-table (keys (first rows)) rows)))\n"} {:sym set-pprint-dispatch, :meta {:doc nil, :arglists ([function])}, :source "(defn\n set-pprint-dispatch\n [function]\n (set! *print-pprint-dispatch* function)\n nil)\n"} {:sym fresh-line, :meta {:doc "Make a newline if *out* is not already at the beginning of the line. If *out* is\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.", :arglists ([])}, :source "(defn\n fresh-line\n \"Make a newline if *out* is not already at the beginning of the line. If *out* is\\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.\"\n []\n (if\n  (satisfies? IDeref *out*)\n  (if (not (= 0 (get-column (:base @@*out*)))) (prn))\n  (prn)))\n"} {:sym pprint-indent, :meta {:doc "Create an indent at this point in the pretty printing stream. This defines how\nfollowing lines are indented. relative-to can be either :block or :current depending\nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.", :arglists ([relative-to n])}, :source "(defn\n pprint-indent\n \"Create an indent at this point in the pretty printing stream. This defines how\\nfollowing lines are indented. relative-to can be either :block or :current depending\\nwhether the indent should be computed relative to the start of the logical block or\\nthe current column position. n is an offset.\\n\\nThis function is intended for use when writing custom dispatch functions.\\n\\nOutput is sent to *out* which must be a pretty printing writer.\"\n [relative-to n]\n (check-enumerated-arg relative-to #{:block :current})\n (indent *out* relative-to n))\n"} {:sym *print-radix*, :meta {:doc "Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8,\nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the\nradix specifier is in the form #XXr where XX is the decimal value of *print-base* "}, :source "(def *print-radix* nil)\n"} {:sym IPrettyFlush, :meta {:doc nil}, :methods (-ppflush)} {:sym cl-format, :meta {:doc "An implementation of a Common Lisp compatible format function. cl-format formats its\narguments to an output stream or string based on the format control string given. It\nsupports sophisticated formatting of structured data.\n\nWriter satisfies IWriter, true to output via *print-fn* or nil to output\nto a string, format-in is the format control string and the remaining arguments\nare the data to be formatted.\n\nThe format control string is a string to be output with embedded 'format directives'\ndescribing how to format the various arguments passed in.\n\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format\nreturns nil.\n\nFor example:\n (let [results [46 38 22]]\n        (cl-format true \"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\"\n                   (count results) results))\n\nPrints via *print-fn*:\n There are 3 results: 46, 38, 22\n\nDetailed documentation on format control strings is available in the \"Common Lisp the\nLanguage, 2nd edition\", Chapter 22 (available online at:\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000)\nand in the Common Lisp HyperSpec at\nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm", :arglists ([writer format-in & args])}, :source "(defn\n cl-format\n \"An implementation of a Common Lisp compatible format function. cl-format formats its\\narguments to an output stream or string based on the format control string given. It\\nsupports sophisticated formatting of structured data.\\n\\nWriter satisfies IWriter, true to output via *print-fn* or nil to output\\nto a string, format-in is the format control string and the remaining arguments\\nare the data to be formatted.\\n\\nThe format control string is a string to be output with embedded 'format directives'\\ndescribing how to format the various arguments passed in.\\n\\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format\\nreturns nil.\\n\\nFor example:\\n (let [results [46 38 22]]\\n        (cl-format true \\\"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\\\"\\n                   (count results) results))\\n\\nPrints via *print-fn*:\\n There are 3 results: 46, 38, 22\\n\\nDetailed documentation on format control strings is available in the \\\"Common Lisp the\\nLanguage, 2nd edition\\\", Chapter 22 (available online at:\\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000)\\nand in the Common Lisp HyperSpec at\\nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\"\n {:see-also\n  [[\"http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000\"\n    \"Common Lisp the Language\"]\n   [\"http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\"\n    \"Common Lisp HyperSpec\"]]}\n [writer format-in & args]\n (let\n  [compiled-format\n   (if (string? format-in) (compile-format format-in) format-in)\n   navigator\n   (init-navigator args)]\n  (execute-format writer compiled-format navigator)))\n"} {:sym *print-miser-width*, :meta {:doc "The column at which to enter miser style. Depending on the dispatch table,\nmiser style add newlines in more places to try to keep lines short allowing for further\nlevels of nesting."}, :source "(def *print-miser-width* 40)\n"} {:sym write, :meta {:doc "Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any\nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n", :arglists ([object & kw-args])}, :source "(defn\n write\n \"Write an object subject to the current bindings of the printer control variables.\\nUse the kw-args argument to override individual variables for this call (and any\\nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\\n\\nThe following keyword arguments can be passed with values:\\n  Keyword              Meaning                              Default value\\n  :stream              Writer for output or nil             true (indicates *out*)\\n  :base                Base to use for writing rationals    Current value of *print-base*\\n  :circle*             If true, mark circular structures    Current value of *print-circle*\\n  :length              Maximum elements to show in sublists Current value of *print-length*\\n  :level               Maximum depth                        Current value of *print-level*\\n  :lines*              Maximum lines of output              Current value of *print-lines*\\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\\n  :readably*           If true, print readably              Current value of *print-readably*\\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\\n\\n  * = not yet supported\\n\"\n [object & kw-args]\n (let\n  [options (merge {:stream true} (apply hash-map kw-args))]\n  (binding\n   [cljs.pprint/*print-base*\n    (:base options cljs.pprint/*print-base*)\n    cljs.pprint/*print-circle*\n    (:circle options cljs.pprint/*print-circle*)\n    cljs.core/*print-length*\n    (:length options cljs.core/*print-length*)\n    cljs.core/*print-level*\n    (:level options cljs.core/*print-level*)\n    cljs.pprint/*print-lines*\n    (:lines options cljs.pprint/*print-lines*)\n    cljs.pprint/*print-miser-width*\n    (:miser-width options cljs.pprint/*print-miser-width*)\n    cljs.pprint/*print-pprint-dispatch*\n    (:dispatch options cljs.pprint/*print-pprint-dispatch*)\n    cljs.pprint/*print-pretty*\n    (:pretty options cljs.pprint/*print-pretty*)\n    cljs.pprint/*print-radix*\n    (:radix options cljs.pprint/*print-radix*)\n    cljs.core/*print-readably*\n    (:readably options cljs.core/*print-readably*)\n    cljs.pprint/*print-right-margin*\n    (:right-margin options cljs.pprint/*print-right-margin*)\n    cljs.pprint/*print-suppress-namespaces*\n    (:suppress-namespaces\n     options\n     cljs.pprint/*print-suppress-namespaces*)]\n   (binding\n    []\n    (let\n     [sb\n      (StringBuffer.)\n      optval\n      (if (contains? options :stream) (:stream options) true)\n      base-writer\n      (if\n       (or (true? optval) (nil? optval))\n       (StringBufferWriter. sb)\n       optval)]\n     (if\n      *print-pretty*\n      (with-pretty-writer base-writer (write-out object))\n      (binding [*out* base-writer] (pr object)))\n     (if (true? optval) (string-print (str sb)))\n     (if (nil? optval) (str sb)))))))\n"} {:sym -ppflush, :meta {:doc nil, :arglists ([pp])}, :protocol IPrettyFlush} {:sym *print-right-margin*, :meta {:doc "Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all\nnon-mandatory newlines."}, :source "(def *print-right-margin* 72)\n"} {:sym write-out, :meta {:doc "Write an object to *out* subject to the current bindings of the printer control\nvariables. Use the kw-args argument to override individual variables for this call (and\nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that\nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \"write\" interface. ", :arglists ([object])}, :source "(defn\n write-out\n \"Write an object to *out* subject to the current bindings of the printer control\\nvariables. Use the kw-args argument to override individual variables for this call (and\\nany recursive calls).\\n\\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\\nof the caller.\\n\\nThis method is primarily intended for use by pretty print dispatch functions that\\nalready know that the pretty printer will have set up their environment appropriately.\\nNormal library clients should use the standard \\\"write\\\" interface. \"\n [object]\n (let\n  [length-reached\n   (and\n    *current-length*\n    *print-length*\n    (>= *current-length* *print-length*))]\n  (if-not\n   *print-pretty*\n   (pr object)\n   (if\n    length-reached\n    (-write *out* \"...\")\n    (do\n     (if\n      *current-length*\n      (set! *current-length* (inc *current-length*)))\n     (*print-pprint-dispatch* object))))\n  length-reached))\n"} {:sym *print-base*, :meta {:doc "The base to use for printing integers and rationals."}, :source "(def *print-base* 10)\n"}), cljs.repl ({:sym print-doc, :meta {:doc nil, :arglists ([{n :ns, nm :name, :as m}])}, :source "(defn\n print-doc\n [{n :ns, nm :name, :as m}]\n (println \"-------------------------\")\n (println (str (when-let [ns (:ns m)] (str ns \"/\")) (:name m)))\n (when (:protocol m) (println \"Protocol\"))\n (cond\n  (:forms m)\n  (doseq [f (:forms m)] (println \"  \" f))\n  (:arglists m)\n  (let\n   [arglists (:arglists m)]\n   (if\n    (or (:macro m) (:repl-special-function m))\n    (prn arglists)\n    (prn\n     (if (= 'quote (first arglists)) (second arglists) arglists)))))\n (if\n  (:special-form m)\n  (do\n   (println \"Special Form\")\n   (println \" \" (:doc m))\n   (if\n    (contains? m :url)\n    (when\n     (:url m)\n     (println (str \"\\n  Please see http://clojure.org/\" (:url m))))\n    (println\n     (str\n      \"\\n  Please see http://clojure.org/special_forms#\"\n      (:name m)))))\n  (do\n   (when (:macro m) (println \"Macro\"))\n   (when (:repl-special-function m) (println \"REPL Special Function\"))\n   (println \" \" (:doc m))\n   (when\n    (:protocol m)\n    (doseq\n     [[name {:keys [doc arglists]}] (:methods m)]\n     (println)\n     (println \" \" name)\n     (println \" \" arglists)\n     (when doc (println \" \" doc))))\n   (when\n    n\n    (when-let\n     [fnspec (spec/get-spec (symbol (str (ns-name n)) (name nm)))]\n     (print \"Spec\")\n     (doseq\n      [role [:args :ret :fn]]\n      (when-let\n       [spec (get fnspec role)]\n       (print (str \"\\n \" (name role) \":\") (spec/describe spec)))))))))\n"}), cljs.core.async.impl.ioc-helpers ({:sym EXCEPTION-FRAMES, :meta {}, :source "(def EXCEPTION-FRAMES 4)\n"} {:sym process-exception, :meta {:doc nil, :arglists ([state])}, :source "(defn\n process-exception\n [state]\n (let\n  [exception-frame\n   (aget-object state EXCEPTION-FRAMES)\n   catch-block\n   (:catch-block exception-frame)\n   catch-exception\n   (:catch-exception exception-frame)\n   exception\n   (aget-object state CURRENT-EXCEPTION)]\n  (cond\n   (and exception (not exception-frame))\n   (throw exception)\n   (and\n    exception\n    catch-block\n    (or\n     (= :default catch-exception)\n     (instance? catch-exception exception)))\n   (ioc/aset-all!\n    state\n    STATE-IDX\n    catch-block\n    VALUE-IDX\n    exception\n    CURRENT-EXCEPTION\n    nil\n    EXCEPTION-FRAMES\n    (assoc exception-frame :catch-block nil :catch-exception nil))\n   (and\n    exception\n    (not catch-block)\n    (not (:finally-block exception-frame)))\n   (do\n    (ioc/aset-all! state EXCEPTION-FRAMES (:prev exception-frame))\n    (recur state))\n   (and exception (not catch-block) (:finally-block exception-frame))\n   (ioc/aset-all!\n    state\n    STATE-IDX\n    (:finally-block exception-frame)\n    EXCEPTION-FRAMES\n    (assoc exception-frame :finally-block nil))\n   (and (not exception) (:finally-block exception-frame))\n   (do\n    (ioc/aset-all!\n     state\n     STATE-IDX\n     (:finally-block exception-frame)\n     EXCEPTION-FRAMES\n     (assoc exception-frame :finally-block nil)))\n   (and (not exception) (not (:finally-block exception-frame)))\n   (do\n    (ioc/aset-all!\n     state\n     STATE-IDX\n     (:continue-block exception-frame)\n     EXCEPTION-FRAMES\n     (:prev exception-frame)))\n   :else\n   (throw (js/Error. \"No matching clause\")))))\n"} {:sym STATE-IDX, :meta {}, :source "(def STATE-IDX 1)\n"} {:sym aset-object, :meta {:doc nil, :arglists ([arr idx o])}, :source "(defn aset-object [arr idx o] (aget arr idx o))\n"} {:sym add-exception-frame, :meta {:doc nil, :arglists ([state catch-block catch-exception finally-block continue-block])}, :source "(defn\n add-exception-frame\n [state catch-block catch-exception finally-block continue-block]\n (ioc/aset-all!\n  state\n  EXCEPTION-FRAMES\n  (->ExceptionFrame\n   catch-block\n   catch-exception\n   finally-block\n   continue-block\n   (aget-object state EXCEPTION-FRAMES))))\n"} {:sym run-state-machine-wrapped, :meta {:doc nil, :arglists ([state])}, :source "(defn\n run-state-machine-wrapped\n [state]\n (try\n  (run-state-machine state)\n  (catch\n   js/Object\n   ex\n   (impl/close! (aget-object state USER-START-IDX))\n   (throw ex))))\n"} {:sym FN-IDX, :meta {}, :source "(def FN-IDX 0)\n"} {:sym aget-object, :meta {:doc nil, :arglists ([arr idx])}, :source "(defn aget-object [arr idx] (aget arr idx))\n"} {:sym return-chan, :meta {:doc nil, :arglists ([state value])}, :source "(defn\n return-chan\n [state value]\n (let\n  [c (aget state USER-START-IDX)]\n  (when-not (nil? value) (impl/put! c value (fn-handler (fn [] nil))))\n  (impl/close! c)\n  c))\n"} {:sym BINDINGS-IDX, :meta {}, :source "(def BINDINGS-IDX 3)\n"} {:sym CURRENT-EXCEPTION, :meta {}, :source "(def CURRENT-EXCEPTION 5)\n"} {:sym run-state-machine, :meta {:doc nil, :arglists ([state])}, :source "(defn run-state-machine [state] ((aget-object state FN-IDX) state))\n"} {:sym finished?, :meta {:doc "Returns true if the machine is in a finished state", :arglists ([state-array])}, :source "(defn\n finished?\n \"Returns true if the machine is in a finished state\"\n [state-array]\n (keyword-identical? (aget state-array STATE-IDX) :finished))\n"} {:sym USER-START-IDX, :meta {}, :source "(def USER-START-IDX 6)\n"} {:sym put!, :meta {:doc nil, :arglists ([state blk c val])}, :source "(defn\n put!\n [state blk c val]\n (if-let\n  [cb\n   (impl/put!\n    c\n    val\n    (fn-handler\n     (fn\n      [ret-val]\n      (ioc/aset-all! state VALUE-IDX ret-val STATE-IDX blk)\n      (run-state-machine-wrapped state))))]\n  (do (ioc/aset-all! state VALUE-IDX @cb STATE-IDX blk) :recur)\n  nil))\n"} {:sym take!, :meta {:doc nil, :arglists ([state blk c])}, :source "(defn\n take!\n [state blk c]\n (if-let\n  [cb\n   (impl/take!\n    c\n    (fn-handler\n     (fn\n      [x]\n      (ioc/aset-all! state VALUE-IDX x STATE-IDX blk)\n      (run-state-machine-wrapped state))))]\n  (do (ioc/aset-all! state VALUE-IDX @cb STATE-IDX blk) :recur)\n  nil))\n"} {:sym VALUE-IDX, :meta {}, :source "(def VALUE-IDX 2)\n"}), clojure.string ({:sym ends-with?, :meta {:doc "True if s ends with substr.", :arglists ([s substr])}, :source "(defn\n ends-with?\n \"True if s ends with substr.\"\n [s substr]\n (gstring/endsWith s substr))\n"} {:sym capitalize, :meta {:doc "Converts first character of the string to upper-case, all other\n  characters to lower-case.", :arglists ([s])}, :source "(defn\n capitalize\n \"Converts first character of the string to upper-case, all other\\n  characters to lower-case.\"\n [s]\n (gstring/capitalize s))\n"} {:sym reverse, :meta {:doc "Returns s with its characters reversed.", :arglists ([s])}, :source "(defn\n reverse\n \"Returns s with its characters reversed.\"\n [s]\n (->\n  (.replace s re-surrogate-pair \"$2$1\")\n  (.. (split \"\") (reverse) (join \"\"))))\n"} {:sym join, :meta {:doc "Returns a string of all elements in coll, as returned by (seq coll),\n  separated by an optional separator.", :arglists [[coll] [separator coll]]}, :source "(defn\n join\n \"Returns a string of all elements in coll, as returned by (seq coll),\\n  separated by an optional separator.\"\n ([coll]\n  (loop\n   [sb (StringBuffer.) coll (seq coll)]\n   (if-not\n    (nil? coll)\n    (recur (. sb (append (str (first coll)))) (next coll))\n    (.toString sb))))\n ([separator coll]\n  (loop\n   [sb (StringBuffer.) coll (seq coll)]\n   (if-not\n    (nil? coll)\n    (do\n     (. sb (append (str (first coll))))\n     (let\n      [coll (next coll)]\n      (when-not (nil? coll) (. sb (append separator)))\n      (recur sb coll)))\n    (.toString sb)))))\n"} {:sym replace-first, :meta {:doc "Replaces the first instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :arglists ([s match replacement])}, :source "(defn\n replace-first\n \"Replaces the first instance of match with replacement in s.\\n   match/replacement can be:\\n\\n   string / string\\n   pattern / (string or function of match).\"\n [s match replacement]\n (.replace s match replacement))\n"} {:sym starts-with?, :meta {:doc "True if s starts with substr.", :arglists ([s substr])}, :source "(defn\n starts-with?\n \"True if s starts with substr.\"\n [s substr]\n (gstring/startsWith s substr))\n"} {:sym escape, :meta {:doc "Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.", :arglists ([s cmap])}, :source "(defn\n escape\n \"Return a new string, using cmap to escape each character ch\\n   from s as follows:\\n\\n   If (cmap ch) is nil, append ch to the new string.\\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.\"\n [s cmap]\n (let\n  [buffer (StringBuffer.) length (.-length s)]\n  (loop\n   [index 0]\n   (if\n    (== length index)\n    (. buffer (toString))\n    (let\n     [ch (.charAt s index) replacement (get cmap ch)]\n     (if-not\n      (nil? replacement)\n      (.append buffer (str replacement))\n      (.append buffer ch))\n     (recur (inc index)))))))\n"} {:sym last-index-of, :meta {:doc "Return last index of value (string or char) in s, optionally\n  searching backward from from-index or nil if not found.", :arglists [[s value] [s value from-index]]}, :source "(defn\n last-index-of\n \"Return last index of value (string or char) in s, optionally\\n  searching backward from from-index or nil if not found.\"\n ([s value]\n  (let [result (.lastIndexOf s value)] (if (neg? result) nil result)))\n ([s value from-index]\n  (let\n   [result (.lastIndexOf s value from-index)]\n   (if (neg? result) nil result))))\n"} {:sym includes?, :meta {:doc "True if s includes substr.", :arglists ([s substr])}, :source "(defn\n includes?\n \"True if s includes substr.\"\n [s substr]\n (gstring/contains s substr))\n"} {:sym replace, :meta {:doc "Replaces all instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :arglists ([s match replacement])}, :source "(defn\n replace\n \"Replaces all instance of match with replacement in s.\\n   match/replacement can be:\\n\\n   string / string\\n   pattern / (string or function of match).\"\n [s match replacement]\n (cond\n  (string? match)\n  (.replace\n   s\n   (js/RegExp. (gstring/regExpEscape match) \"g\")\n   replacement)\n  (instance? js/RegExp match)\n  (if\n   (string? replacement)\n   (replace-all s match replacement)\n   (replace-all s match (replace-with replacement)))\n  :else\n  (throw (str \"Invalid match arg: \" match))))\n"} {:sym split-lines, :meta {:doc "Splits s on \n or \r\n.", :arglists ([s])}, :source "(defn split-lines \"Splits s on \\n or \\r\\n.\" [s] (split s #\"\\n|\\r\\n\"))\n"} {:sym lower-case, :meta {:doc "Converts string to all lower-case.", :arglists ([s])}, :source "(defn\n lower-case\n \"Converts string to all lower-case.\"\n [s]\n (.toLowerCase s))\n"} {:sym trim-newline, :meta {:doc "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.", :arglists ([s])}, :source "(defn\n trim-newline\n \"Removes all trailing newline \\\\n or return \\\\r characters from\\n  string.  Similar to Perl's chomp.\"\n [s]\n (loop\n  [index (.-length s)]\n  (if\n   (zero? index)\n   \"\"\n   (let\n    [ch (get s (dec index))]\n    (if\n     (or (identical? \\newline ch) (identical? \\return ch))\n     (recur (dec index))\n     (.substring s 0 index))))))\n"} {:sym upper-case, :meta {:doc "Converts string to all upper-case.", :arglists ([s])}, :source "(defn\n upper-case\n \"Converts string to all upper-case.\"\n [s]\n (.toUpperCase s))\n"} {:sym split, :meta {:doc "Splits string on a regular expression. Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.", :arglists [[s re] [s re limit]]}, :source "(defn\n split\n \"Splits string on a regular expression. Optional argument limit is\\n  the maximum number of splits. Not lazy. Returns vector of the splits.\"\n ([s re] (split s re 0))\n ([s re limit]\n  (discard-trailing-if-needed\n   limit\n   (if\n    (identical? \"/(?:)/\" (str re))\n    (split-with-empty-regex s limit)\n    (if\n     (< limit 1)\n     (vec (.split (str s) re))\n     (loop\n      [s s limit limit parts []]\n      (if\n       (== 1 limit)\n       (conj parts s)\n       (let\n        [m (re-find re s)]\n        (if-not\n         (nil? m)\n         (let\n          [index (.indexOf s m)]\n          (recur\n           (.substring s (+ index (count m)))\n           (dec limit)\n           (conj parts (.substring s 0 index))))\n         (conj parts s))))))))))\n"} {:sym trimr, :meta {:doc "Removes whitespace from the right side of string.", :arglists ([s])}, :source "(defn\n trimr\n \"Removes whitespace from the right side of string.\"\n [s]\n (gstring/trimRight s))\n"} {:sym index-of, :meta {:doc "Return index of value (string or char) in s, optionally searching\n  forward from from-index or nil if not found.", :arglists [[s value] [s value from-index]]}, :source "(defn\n index-of\n \"Return index of value (string or char) in s, optionally searching\\n  forward from from-index or nil if not found.\"\n ([s value]\n  (let [result (.indexOf s value)] (if (neg? result) nil result)))\n ([s value from-index]\n  (let\n   [result (.indexOf s value from-index)]\n   (if (neg? result) nil result))))\n"} {:sym trim, :meta {:doc "Removes whitespace from both ends of string.", :arglists ([s])}, :source "(defn\n trim\n \"Removes whitespace from both ends of string.\"\n [s]\n (gstring/trim s))\n"} {:sym triml, :meta {:doc "Removes whitespace from the left side of string.", :arglists ([s])}, :source "(defn\n triml\n \"Removes whitespace from the left side of string.\"\n [s]\n (gstring/trimLeft s))\n"} {:sym blank?, :meta {:doc "True is s is nil, empty, or contains only whitespace.", :arglists ([s])}, :source "(defn\n blank?\n \"True is s is nil, empty, or contains only whitespace.\"\n [s]\n (gstring/isEmptySafe s))\n"}), cljs.spec.alpha ({:sym form, :meta {:doc "returns the spec as data", :arglists ([spec])}, :source "(defn form \"returns the spec as data\" [spec] (describe* (specize spec)))\n"} {:sym nilable-impl, :meta {:doc "Do not call this directly, use 'nilable'", :arglists ([form pred gfn])}, :source "(defn\n nilable-impl\n \"Do not call this directly, use 'nilable'\"\n [form pred gfn]\n (let\n  [spec (specize pred form)]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform* [_ x] (if (nil? x) nil (conform* spec x)))\n   (unform* [_ x] (if (nil? x) nil (unform* spec x)))\n   (explain*\n    [_ path via in x]\n    (when-not\n     (c/or (pvalid? spec x) (nil? x))\n     (conj\n      (explain-1 form pred (conj path :clojure.core/pred) via in x)\n      {:path (conj path :clojure.core/nil),\n       :pred 'nil?,\n       :val x,\n       :via via,\n       :in in})))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (gen/frequency\n      [[1 (gen/delay (gen/return nil))]\n       [9\n        (gen/delay\n         (gensub\n          pred\n          overrides\n          (conj path :clojure.core/pred)\n          rmap\n          form))]])))\n   (with-gen* [_ gfn] (nilable-impl form pred gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/nilable)\n       (clojure.core/list (s/mres form)))))))))\n"} {:sym *recursion-limit*, :meta {}, :source "(def\n *recursion-limit*\n \"A soft limit on how many times a branching spec (or/alt/*/opt-keys/multi-spec)\\n  can be recursed through during generation. After this a\\n  non-recursive branch will be chosen.\"\n 4)\n"} {:sym *coll-error-limit*, :meta {}, :source "(def\n *coll-error-limit*\n \"The number of errors reported by explain in a collection spec'ed with 'every'\"\n 20)\n"} {:sym explain-printer, :meta {:doc "Default printer for explain-data. nil indicates a successful validation.", :arglists ([ed])}, :source "(defn\n explain-printer\n \"Default printer for explain-data. nil indicates a successful validation.\"\n [ed]\n (if\n  ed\n  (let\n   [problems\n    (sort-by\n     (fn* [p1__18534#] (- (count (:path p1__18534#))))\n     (:clojure.core/problems ed))]\n   (print\n    (with-out-str\n     (doseq\n      [{:keys [path pred val reason via in], :as prob} problems]\n      (when-not (empty? in) (print \"In:\" (pr-str in) \"\"))\n      (print \"val: \")\n      (pr val)\n      (print \" fails\")\n      (when-not (empty? via) (print \" spec:\" (pr-str (last via))))\n      (when-not (empty? path) (print \" at:\" (pr-str path)))\n      (print \" predicate: \")\n      (pr (abbrev pred))\n      (when reason (print \", \" reason))\n      (doseq\n       [[k v] prob]\n       (when-not\n        (#{:path :pred :via :val :reason :in} k)\n        (print \"\\n\\t\" (pr-str k) \" \")\n        (pr v)))\n      (newline))\n     (doseq\n      [[k v] ed]\n      (when-not\n       (#{:clojure.core/problems} k)\n       (print (pr-str k) \" \")\n       (pr v)\n       (newline))))))\n  (println \"Success!\")))\n"} {:sym Specize, :meta {:doc nil}, :methods (specize*)} {:sym alt-impl, :meta {:doc "Do not call this directly, use 'alt'", :arglists ([ks ps forms])}, :source "(defn\n alt-impl\n \"Do not call this directly, use 'alt'\"\n [ks ps forms]\n (assoc (alt* ps ks forms) :id (random-uuid)))\n"} {:sym def-impl, :meta {:doc "Do not call this directly, use 'def'", :arglists ([k form spec])}, :source "(defn\n def-impl\n \"Do not call this directly, use 'def'\"\n [k form spec]\n (assert\n  (c/and (ident? k) (namespace k))\n  \"k must be namespaced keyword or resolveable symbol\")\n (let\n  [spec\n   (if\n    (c/or (spec? spec) (regex? spec) (get @registry-ref spec))\n    spec\n    (spec-impl form spec nil nil))]\n  (swap! registry-ref assoc k (with-name spec k))\n  k))\n"} {:sym *explain-out*, :meta {}, :source "(def *explain-out* explain-printer)\n"} {:sym regex-spec-impl, :meta {:doc "Do not call this directly, use 'spec' with a regex op argument", :arglists ([re gfn])}, :source "(defn\n regex-spec-impl\n \"Do not call this directly, use 'spec' with a regex op argument\"\n [re gfn]\n (reify\n  Specize\n  (specize* [s] s)\n  (specize* [s _] s)\n  Spec\n  (conform*\n   [_ x]\n   (if\n    (c/or (nil? x) (coll? x))\n    (re-conform re (seq x))\n    :clojure.core/invalid))\n  (unform* [_ x] (op-unform re x))\n  (explain*\n   [_ path via in x]\n   (if\n    (c/or (nil? x) (coll? x))\n    (re-explain path via in re (seq x))\n    [{:path path, :pred (op-describe re), :val x, :via via, :in in}]))\n  (gen*\n   [_ overrides path rmap]\n   (if gfn (gfn) (re-gen re overrides path rmap (op-describe re))))\n  (with-gen* [_ gfn] (regex-spec-impl re gfn))\n  (describe* [_] (op-describe re))))\n"} {:sym merge-spec-impl, :meta {:doc "Do not call this directly, use 'merge'", :arglists ([forms preds gfn])}, :source "(defn\n merge-spec-impl\n \"Do not call this directly, use 'merge'\"\n [forms preds gfn]\n (reify\n  Specize\n  (specize* [s] s)\n  (specize* [s _] s)\n  Spec\n  (conform*\n   [_ x]\n   (let\n    [ms\n     (map\n      (fn* [p1__18546# p2__18547#] (dt p1__18546# x p2__18547#))\n      preds\n      forms)]\n    (if (some invalid? ms) :clojure.core/invalid (apply c/merge ms))))\n  (unform*\n   [_ x]\n   (apply\n    c/merge\n    (map (fn* [p1__18548#] (unform p1__18548# x)) (reverse preds))))\n  (explain*\n   [_ path via in x]\n   (apply\n    concat\n    (map\n     (fn*\n      [p1__18549# p2__18550#]\n      (explain-1 p1__18549# p2__18550# path via in x))\n     forms\n     preds)))\n  (gen*\n   [_ overrides path rmap]\n   (if\n    gfn\n    (gfn)\n    (gen/fmap\n     (fn* [p1__18551#] (apply c/merge p1__18551#))\n     (apply\n      gen/tuple\n      (map\n       (fn*\n        [p1__18552# p2__18553#]\n        (gensub p1__18552# overrides path rmap p2__18553#))\n       preds\n       forms)))))\n  (with-gen* [_ gfn] (merge-spec-impl forms preds gfn))\n  (describe*\n   [_]\n   (clojure.core/sequence\n    (clojure.core/seq\n     (clojure.core/concat\n      (clojure.core/list 'clojure.core/merge)\n      forms))))))\n"} {:sym explain-data*, :meta {:doc nil, :arglists ([spec path via in x])}, :source "(defn\n explain-data*\n [spec path via in x]\n (when-let\n  [probs (explain* (specize spec) path via in x)]\n  (when-not\n   (empty? probs)\n   {:clojure.core/problems probs,\n    :clojure.core/spec spec,\n    :clojure.core/value x})))\n"} {:sym MAX_INT, :meta {}, :source "(def MAX_INT 9007199254740991)\n"} {:sym check-asserts, :meta {:doc "Enable or disable spec asserts that have been compiled\nwith '*compile-asserts*' true.  See 'assert'.\nInitially set to boolean value of cljs.spec.alpha/*runtime-asserts*.\nDefaults to false.", :arglists ([flag])}, :source "(defn\n check-asserts\n \"Enable or disable spec asserts that have been compiled\\nwith '*compile-asserts*' true.  See 'assert'.\\nInitially set to boolean value of cljs.spec.alpha/*runtime-asserts*.\\nDefaults to false.\"\n [flag]\n (set! *runtime-asserts* flag))\n"} {:sym assert*, :meta {:doc "Do not call this directly, use 'assert'.", :arglists ([spec x])}, :source "(defn\n assert*\n \"Do not call this directly, use 'assert'.\"\n [spec x]\n (if\n  (valid? spec x)\n  x\n  (let\n   [ed\n    (c/merge\n     (assoc\n      (explain-data* spec [] [] [] x)\n      :clojure.core/failure\n      :assertion-failed))]\n   (throw\n    (js/Error.\n     (str\n      \"Spec assertion failed\\n\"\n      (with-out-str (explain-out ed))))))))\n"} {:sym inst-in-range?, :meta {:doc "Return true if inst at or after start and before end", :arglists ([start end inst])}, :source "(defn\n inst-in-range?\n \"Return true if inst at or after start and before end\"\n [start end inst]\n (c/and\n  (inst? inst)\n  (let\n   [t (inst-ms inst)]\n   (c/and (<= (inst-ms start) t) (< t (inst-ms end))))))\n"} {:sym and-spec-impl, :meta {:doc "Do not call this directly, use 'and'", :arglists ([forms preds gfn])}, :source "(defn\n and-spec-impl\n \"Do not call this directly, use 'and'\"\n [forms preds gfn]\n (let\n  [specs\n   (delay (mapv specize preds forms))\n   cform\n   (case\n    (count preds)\n    2\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       :clojure.core/invalid\n       (conform* (specs 1) ret))))\n    3\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       :clojure.core/invalid\n       (let\n        [ret (conform* (specs 1) ret)]\n        (if\n         (invalid? ret)\n         :clojure.core/invalid\n         (conform* (specs 2) ret))))))\n    (fn\n     [x]\n     (let\n      [specs @specs]\n      (loop\n       [ret x i 0]\n       (if\n        (< i (count specs))\n        (let\n         [nret (conform* (specs i) ret)]\n         (if\n          (invalid? nret)\n          :clojure.core/invalid\n          (recur nret (inc i))))\n        ret)))))]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform* [_ x] (cform x))\n   (unform*\n    [_ x]\n    (reduce\n     (fn* [p1__18545# p2__18544#] (unform p2__18544# p1__18545#))\n     x\n     (reverse preds)))\n   (explain*\n    [_ path via in x]\n    (explain-pred-list forms preds path via in x))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (gensub (first preds) overrides path rmap (first forms))))\n   (with-gen* [_ gfn] (and-spec-impl forms preds gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/and)\n       forms)))))))\n"} {:sym describe*, :meta {:doc nil, :arglists ([spec])}, :protocol Spec} {:sym map-spec-impl, :meta {:doc "Do not call this directly, use 'spec' with a map argument", :arglists ([{:keys [req-un opt-un keys-pred pred-exprs opt-keys req-specs req req-keys opt-specs pred-forms opt gfn], :as argm}])}, :source "(defn\n map-spec-impl\n \"Do not call this directly, use 'spec' with a map argument\"\n [{:keys\n   [req-un\n    opt-un\n    keys-pred\n    pred-exprs\n    opt-keys\n    req-specs\n    req\n    req-keys\n    opt-specs\n    pred-forms\n    opt\n    gfn],\n   :as argm}]\n (let\n  [k->s\n   (zipmap (concat req-keys opt-keys) (concat req-specs opt-specs))\n   keys->specnames\n   (fn* [p1__18536#] (c/or (k->s p1__18536#) p1__18536#))\n   id\n   (random-uuid)]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform*\n    [_ m]\n    (if\n     (keys-pred m)\n     (let\n      [reg (registry)]\n      (loop\n       [ret m [[k v] & ks :as keys] m]\n       (if\n        keys\n        (let\n         [sname (keys->specnames k)]\n         (if-let\n          [s (get reg sname)]\n          (let\n           [cv (conform s v)]\n           (if\n            (invalid? cv)\n            :clojure.core/invalid\n            (recur (if (identical? cv v) ret (assoc ret k cv)) ks)))\n          (recur ret ks)))\n        ret)))\n     :clojure.core/invalid))\n   (unform*\n    [_ m]\n    (let\n     [reg (registry)]\n     (loop\n      [ret m [k & ks :as keys] (c/keys m)]\n      (if\n       keys\n       (if\n        (contains? reg (keys->specnames k))\n        (let\n         [cv (get m k) v (unform (keys->specnames k) cv)]\n         (recur (if (identical? cv v) ret (assoc ret k v)) ks))\n        (recur ret ks))\n       ret))))\n   (explain*\n    [_ path via in x]\n    (if-not\n     (map? x)\n     [{:path path, :pred 'map?, :val x, :via via, :in in}]\n     (let\n      [reg (registry)]\n      (apply\n       concat\n       (when-let\n        [probs\n         (->>\n          (map\n           (fn [pred form] (when-not (pred x) form))\n           pred-exprs\n           pred-forms)\n          (keep identity)\n          seq)]\n        (map\n         (fn*\n          [p1__18537#]\n          (identity\n           {:path path, :pred p1__18537#, :val x, :via via, :in in}))\n         probs))\n       (map\n        (fn\n         [[k v]]\n         (when-not\n          (c/or\n           (not (contains? reg (keys->specnames k)))\n           (pvalid? (keys->specnames k) v k))\n          (explain-1\n           (keys->specnames k)\n           (keys->specnames k)\n           (conj path k)\n           via\n           (conj in k)\n           v)))\n        (seq x))))))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (let\n      [rmap\n       (inck rmap id)\n       gen\n       (fn [k s] (gensub s overrides (conj path k) rmap k))\n       ogen\n       (fn\n        [k s]\n        (when-not\n         (recur-limit? rmap id path k)\n         [k (gen/delay (gensub s overrides (conj path k) rmap k))]))\n       req-gens\n       (map gen req-keys req-specs)\n       opt-gens\n       (remove nil? (map ogen opt-keys opt-specs))]\n      (when\n       (every? identity (concat req-gens opt-gens))\n       (let\n        [reqs (zipmap req-keys req-gens) opts (into {} opt-gens)]\n        (gen/bind\n         (gen/choose 0 (count opts))\n         (fn*\n          [p1__18538#]\n          (let\n           [args\n            (concat (seq reqs) (when (seq opts) (shuffle (seq opts))))]\n           (->>\n            args\n            (take (c/+ p1__18538# (count reqs)))\n            (apply concat)\n            (apply gen/hash-map))))))))))\n   (with-gen* [_ gfn] (map-spec-impl (assoc argm :gfn gfn)))\n   (describe*\n    [_]\n    (cons\n     'clojure.core/keys\n     (cond->\n      []\n      req\n      (conj :req req)\n      opt\n      (conj :opt opt)\n      req-un\n      (conj :req-un req-un)\n      opt-un\n      (conj :opt-un opt-un)))))))\n"} {:sym explain, :meta {:doc "Given a spec and a value that fails to conform, prints an explanation to *out*.", :arglists ([spec x])}, :source "(defn\n explain\n \"Given a spec and a value that fails to conform, prints an explanation to *out*.\"\n [spec x]\n (explain-out (explain-data spec x)))\n"} {:sym with-gen*, :meta {:doc nil, :arglists ([spec gfn])}, :protocol Spec} {:sym or-spec-impl, :meta {:doc "Do not call this directly, use 'or'", :arglists ([keys forms preds gfn])}, :source "(defn\n or-spec-impl\n \"Do not call this directly, use 'or'\"\n [keys forms preds gfn]\n (let\n  [id\n   (random-uuid)\n   kps\n   (zipmap keys preds)\n   specs\n   (delay (mapv specize preds forms))\n   cform\n   (case\n    (count preds)\n    2\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       (let\n        [ret (conform* (specs 1) x)]\n        (if\n         (invalid? ret)\n         :clojure.core/invalid\n         (tagged-ret [(keys 1) ret])))\n       (tagged-ret [(keys 0) ret]))))\n    3\n    (fn\n     [x]\n     (let\n      [specs @specs ret (conform* (specs 0) x)]\n      (if\n       (invalid? ret)\n       (let\n        [ret (conform* (specs 1) x)]\n        (if\n         (invalid? ret)\n         (let\n          [ret (conform* (specs 2) x)]\n          (if\n           (invalid? ret)\n           :clojure.core/invalid\n           (tagged-ret [(keys 2) ret])))\n         (tagged-ret [(keys 1) ret])))\n       (tagged-ret [(keys 0) ret]))))\n    (fn\n     [x]\n     (let\n      [specs @specs]\n      (loop\n       [i 0]\n       (if\n        (< i (count specs))\n        (let\n         [spec (specs i)]\n         (let\n          [ret (conform* spec x)]\n          (if\n           (invalid? ret)\n           (recur (inc i))\n           (tagged-ret [(keys i) ret]))))\n        :clojure.core/invalid)))))]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform* [_ x] (cform x))\n   (unform* [_ [k x]] (unform (kps k) x))\n   (explain*\n    [this path via in x]\n    (when-not\n     (pvalid? this x)\n     (apply\n      concat\n      (map\n       (fn\n        [k form pred]\n        (when-not\n         (pvalid? pred x)\n         (explain-1 form pred (conj path k) via in x)))\n       keys\n       forms\n       preds))))\n   (gen*\n    [_ overrides path rmap]\n    (if\n     gfn\n     (gfn)\n     (let\n      [gen\n       (fn\n        [k p f]\n        (let\n         [rmap (inck rmap id)]\n         (when-not\n          (recur-limit? rmap id path k)\n          (gen/delay (gensub p overrides (conj path k) rmap f)))))\n       gs\n       (remove nil? (map gen keys preds forms))]\n      (when-not (empty? gs) (gen/one-of gs)))))\n   (with-gen* [_ gfn] (or-spec-impl keys forms preds gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/or)\n       (mapcat vector keys forms))))))))\n"} {:sym *fspec-iterations*, :meta {}, :source "(def\n *fspec-iterations*\n \"The number of times an anonymous fn specified by fspec will be (generatively) tested during conform\"\n 21)\n"} {:sym Spec, :meta {:doc nil}, :methods (conform* describe* explain* gen* unform* with-gen*)} {:sym unform, :meta {:doc "Given a spec and a value created by or compliant with a call to\n  'conform' with the same spec, returns a value with all conform\n   destructuring undone.", :arglists ([spec x])}, :source "(defn\n unform\n \"Given a spec and a value created by or compliant with a call to\\n  'conform' with the same spec, returns a value with all conform\\n   destructuring undone.\"\n [spec x]\n (unform* (specize spec) x))\n"} {:sym valid?, :meta {:doc "Helper function that returns true when x is valid for spec.", :arglists [[spec x] [spec x form]]}, :source "(defn\n valid?\n \"Helper function that returns true when x is valid for spec.\"\n ([spec x]\n  (let [spec (specize spec)] (not (invalid? (conform* spec x)))))\n ([spec x form]\n  (let [spec (specize spec form)] (not (invalid? (conform* spec x))))))\n"} {:sym gen, :meta {:doc "Given a spec, returns the generator for it, or throws if none can\n  be constructed. Optionally an overrides map can be provided which\n  should map spec names or paths (vectors of keywords) to no-arg\n  generator-creating fns. These will be used instead of the generators at those\n  names/paths. Note that parent generator (in the spec or overrides\n  map) will supersede those of any subtrees. A generator for a regex\n  op must always return a sequential collection (i.e. a generator for\n  s/? should return either an empty sequence/vector or a\n  sequence/vector with one item in it)", :arglists [[spec] [spec overrides]]}, :source "(defn\n gen\n \"Given a spec, returns the generator for it, or throws if none can\\n  be constructed. Optionally an overrides map can be provided which\\n  should map spec names or paths (vectors of keywords) to no-arg\\n  generator-creating fns. These will be used instead of the generators at those\\n  names/paths. Note that parent generator (in the spec or overrides\\n  map) will supersede those of any subtrees. A generator for a regex\\n  op must always return a sequential collection (i.e. a generator for\\n  s/? should return either an empty sequence/vector or a\\n  sequence/vector with one item in it)\"\n ([spec] (gen spec nil))\n ([spec overrides]\n  (gensub\n   spec\n   overrides\n   []\n   {:clojure.core/recursion-limit *recursion-limit*}\n   spec)))\n"} {:sym nonconforming, :meta {:doc "takes a spec and returns a spec that has the same properties except\n  'conform' returns the original (not the conformed) value. Note, will specize regex ops.", :arglists ([spec])}, :source "(defn\n nonconforming\n \"takes a spec and returns a spec that has the same properties except\\n  'conform' returns the original (not the conformed) value. Note, will specize regex ops.\"\n [spec]\n (let\n  [spec (specize spec)]\n  (reify\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform*\n    [_ x]\n    (let\n     [ret (conform* spec x)]\n     (if (invalid? ret) :clojure.core/invalid x)))\n   (unform* [_ x] (unform* spec x))\n   (explain* [_ path via in x] (explain* spec path via in x))\n   (gen* [_ overrides path rmap] (gen* spec overrides path rmap))\n   (with-gen* [_ gfn] (nonconforming (with-gen* spec gfn)))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/nonconforming)\n       (clojure.core/list (describe* spec)))))))))\n"} {:sym unform*, :meta {:doc nil, :arglists ([spec y])}, :protocol Spec} {:sym abbrev, :meta {:doc nil, :arglists ([form])}, :source "(defn\n abbrev\n [form]\n (cond\n  (seq? form)\n  (walk/postwalk\n   (fn\n    [form]\n    (cond\n     (c/and (symbol? form) (namespace form))\n     (-> form name symbol)\n     (c/and (seq? form) (= 'fn (first form)) (= '[%] (second form)))\n     (last form)\n     :else\n     form))\n   form)\n  (c/and (symbol? form) (namespace form))\n  (-> form name symbol)\n  :else\n  form))\n"} {:sym regex?, :meta {:doc "returns x if x is a (cljs.spec.alpha) regex op, else logical false", :arglists ([x])}, :source "(defn\n regex?\n \"returns x if x is a (cljs.spec.alpha) regex op, else logical false\"\n [x]\n (c/and (:clojure.core/op x) x))\n"} {:sym int-in-range?, :meta {:doc "Return true if start <= val, val < end and val is a fixed\n  precision integer.", :arglists ([start end val])}, :source "(defn\n int-in-range?\n \"Return true if start <= val, val < end and val is a fixed\\n  precision integer.\"\n [start end val]\n (cond\n  (integer? val)\n  (c/and (<= start val) (< val end))\n  (instance? goog.math.Long val)\n  (c/and (.lessThanOrEqual start val) (.lessThan val end))\n  (instance? goog.math.Integer val)\n  (c/and (.lessThanOrEqual start val) (.lessThan val end))\n  :else\n  false))\n"} {:sym spec?, :meta {:doc "returns x if x is a spec object, else logical false", :arglists ([x])}, :source "(defn\n spec?\n \"returns x if x is a spec object, else logical false\"\n [x]\n (when (implements? Spec x) x))\n"} {:sym registry, :meta {:doc "returns the registry map, prefer 'get-spec' to lookup a spec by name", :arglists ([])}, :source "(defn\n registry\n \"returns the registry map, prefer 'get-spec' to lookup a spec by name\"\n []\n @registry-ref)\n"} {:sym rep+impl, :meta {:doc "Do not call this directly, use '+'", :arglists ([form p])}, :source "(defn\n rep+impl\n \"Do not call this directly, use '+'\"\n [form p]\n (pcat*\n  {:ps [p (rep* p p [] true form)],\n   :forms\n   (clojure.core/vec\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list form)\n       (clojure.core/list\n        (clojure.core/sequence\n         (clojure.core/seq\n          (clojure.core/concat\n           (clojure.core/list 'clojure.core/*)\n           (clojure.core/list form))))))))),\n   :ret [],\n   :rep+ form}))\n"} {:sym exercise, :meta {:doc "generates a number (default 10) of values compatible with spec and maps conform over them,\n  returning a sequence of [val conformed-val] tuples. Optionally takes\n  a generator overrides map as per gen", :arglists [[spec] [spec n] [spec n overrides]]}, :source "(defn\n exercise\n \"generates a number (default 10) of values compatible with spec and maps conform over them,\\n  returning a sequence of [val conformed-val] tuples. Optionally takes\\n  a generator overrides map as per gen\"\n ([spec] (exercise spec 10))\n ([spec n] (exercise spec n nil))\n ([spec n overrides]\n  (map\n   (fn* [p1__18569#] (vector p1__18569# (conform spec p1__18569#)))\n   (gen/sample (gen spec overrides) n))))\n"} {:sym explain-data, :meta {:doc "Given a spec and a value x which ought to conform, returns nil if x\n  conforms, else a map with at least the key ::problems whose value is\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\n  keys describing the predicate and the value that failed at that\n  path.", :arglists ([spec x])}, :source "(defn\n explain-data\n \"Given a spec and a value x which ought to conform, returns nil if x\\n  conforms, else a map with at least the key ::problems whose value is\\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\\n  keys describing the predicate and the value that failed at that\\n  path.\"\n [spec x]\n (explain-data*\n  spec\n  []\n  (if-let [name (spec-name spec)] [name] [])\n  []\n  x))\n"} {:sym tuple-impl, :meta {:doc "Do not call this directly, use 'tuple'", :arglists [[forms preds] [forms preds gfn]]}, :source "(defn\n tuple-impl\n \"Do not call this directly, use 'tuple'\"\n ([forms preds] (tuple-impl forms preds nil))\n ([forms preds gfn]\n  (let\n   [specs (delay (mapv specize preds forms)) cnt (count preds)]\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (let\n      [specs @specs]\n      (if-not\n       (c/and (vector? x) (= (count x) cnt))\n       :clojure.core/invalid\n       (loop\n        [ret x i 0]\n        (if\n         (= i cnt)\n         ret\n         (let\n          [v (x i) cv (conform* (specs i) v)]\n          (if\n           (invalid? cv)\n           :clojure.core/invalid\n           (recur\n            (if (identical? cv v) ret (assoc ret i cv))\n            (inc i)))))))))\n    (unform*\n     [_ x]\n     (assert (c/and (vector? x) (= (count x) (count preds))))\n     (loop\n      [ret x i 0]\n      (if\n       (= i (count x))\n       ret\n       (let\n        [cv (x i) v (unform (preds i) cv)]\n        (recur (if (identical? cv v) ret (assoc ret i v)) (inc i))))))\n    (explain*\n     [_ path via in x]\n     (cond\n      (not (vector? x))\n      [{:path path, :pred 'vector?, :val x, :via via, :in in}]\n      (not= (count x) (count preds))\n      [{:path path,\n        :pred\n        (clojure.core/sequence\n         (clojure.core/seq\n          (clojure.core/concat\n           (clojure.core/list 'clojure.core/=)\n           (clojure.core/list\n            (clojure.core/sequence\n             (clojure.core/seq\n              (clojure.core/concat\n               (clojure.core/list 'clojure.core/count)\n               (clojure.core/list '%)))))\n           (clojure.core/list (count preds))))),\n        :val x,\n        :via via,\n        :in in}]\n      :else\n      (apply\n       concat\n       (map\n        (fn\n         [i form pred]\n         (let\n          [v (x i)]\n          (when-not\n           (pvalid? pred v)\n           (explain-1 form pred (conj path i) via (conj in i) v))))\n        (range (count preds))\n        forms\n        preds))))\n    (gen*\n     [_ overrides path rmap]\n     (if\n      gfn\n      (gfn)\n      (let\n       [gen\n        (fn [i p f] (gensub p overrides (conj path i) rmap f))\n        gs\n        (map gen (range (count preds)) preds forms)]\n       (when (every? identity gs) (apply gen/tuple gs)))))\n    (with-gen* [_ gfn] (tuple-impl forms preds gfn))\n    (describe*\n     [_]\n     (clojure.core/sequence\n      (clojure.core/seq\n       (clojure.core/concat\n        (clojure.core/list 'clojure.core/tuple)\n        forms))))))))\n"} {:sym multi-spec-impl, :meta {:doc "Do not call this directly, use 'multi-spec'", :arglists [[form mmvar retag] [form mmvar retag gfn]]}, :source "(defn\n multi-spec-impl\n \"Do not call this directly, use 'multi-spec'\"\n ([form mmvar retag] (multi-spec-impl form mmvar retag nil))\n ([form mmvar retag gfn]\n  (let\n   [id\n    (random-uuid)\n    predx\n    (fn*\n     [p1__18539#]\n     (let\n      [mm @mmvar]\n      (c/and\n       (-get-method mm ((-dispatch-fn mm) p1__18539#))\n       (mm p1__18539#))))\n    dval\n    (fn* [p1__18540#] ((-dispatch-fn @mmvar) p1__18540#))\n    tag\n    (if\n     (keyword? retag)\n     (fn* [p1__18541# p2__18542#] (assoc p1__18541# retag p2__18542#))\n     retag)]\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (if-let [pred (predx x)] (dt pred x form) :clojure.core/invalid))\n    (unform*\n     [_ x]\n     (if-let\n      [pred (predx x)]\n      (unform pred x)\n      (throw\n       (js/Error.\n        (str\n         \"No method of: \"\n         form\n         \" for dispatch value: \"\n         (dval x))))))\n    (explain*\n     [_ path via in x]\n     (let\n      [dv (dval x) path (conj path dv)]\n      (if-let\n       [pred (predx x)]\n       (explain-1 form pred path via in x)\n       [{:path path,\n         :pred form,\n         :val x,\n         :reason \"no method\",\n         :via via,\n         :in in}])))\n    (gen*\n     [_ overrides path rmap]\n     (if\n      gfn\n      (gfn)\n      (let\n       [gen\n        (fn\n         [[k f]]\n         (let\n          [p (f nil)]\n          (let\n           [rmap (inck rmap id)]\n           (when-not\n            (recur-limit? rmap id path k)\n            (gen/delay\n             (gen/fmap\n              (fn* [p1__18543#] (tag p1__18543# k))\n              (gensub\n               p\n               overrides\n               (conj path k)\n               rmap\n               (list 'method form k))))))))\n        gs\n        (->>\n         (methods @mmvar)\n         (remove (fn [[k]] (invalid? k)))\n         (map gen)\n         (remove nil?))]\n       (when (every? identity gs) (gen/one-of gs)))))\n    (with-gen* [_ gfn] (multi-spec-impl form mmvar retag gfn))\n    (describe*\n     [_]\n     (clojure.core/sequence\n      (clojure.core/seq\n       (clojure.core/concat\n        (clojure.core/list 'clojure.core/multi-spec)\n        (clojure.core/list form)\n        (clojure.core/list retag)))))))))\n"} {:sym conform, :meta {:doc "Given a spec and a value, returns :cljs.spec.alpha/invalid if value does\n  not match spec, else the (possibly destructured) value.", :arglists ([spec x])}, :source "(defn\n conform\n \"Given a spec and a value, returns :cljs.spec.alpha/invalid if value does\\n  not match spec, else the (possibly destructured) value.\"\n [spec x]\n (conform* (specize spec) x))\n"} {:sym gen*, :meta {:doc nil, :arglists ([spec overrides path rmap])}, :protocol Spec} {:sym fspec-impl, :meta {:doc "Do not call this directly, use 'fspec'", :arglists ([argspec aform retspec rform fnspec fform gfn])}, :source "(defn\n fspec-impl\n \"Do not call this directly, use 'fspec'\"\n [argspec aform retspec rform fnspec fform gfn]\n (let\n  [specs {:args argspec, :ret retspec, :fn fnspec}]\n  (reify\n   ILookup\n   (-lookup [this k] (get specs k))\n   (-lookup [_ k not-found] (get specs k not-found))\n   Specize\n   (specize* [s] s)\n   (specize* [s _] s)\n   Spec\n   (conform*\n    [_ f]\n    (if\n     (ifn? f)\n     (if\n      (identical? f (validate-fn f specs *fspec-iterations*))\n      f\n      :clojure.core/invalid)\n     :clojure.core/invalid))\n   (unform* [_ f] f)\n   (explain*\n    [_ path via in f]\n    (if\n     (ifn? f)\n     (let\n      [args (validate-fn f specs 100)]\n      (if\n       (identical? f args)\n       nil\n       (let\n        [ret (try (apply f args) (catch js/Error t t))]\n        (if\n         (instance? js/Error ret)\n         [{:path path,\n           :pred '(apply fn),\n           :val args,\n           :reason (.-message ret),\n           :via via,\n           :in in}]\n         (let\n          [cret (dt retspec ret rform)]\n          (if\n           (invalid? cret)\n           (explain-1 rform retspec (conj path :ret) via in ret)\n           (when\n            fnspec\n            (let\n             [cargs (conform argspec args)]\n             (explain-1\n              fform\n              fnspec\n              (conj path :fn)\n              via\n              in\n              {:args cargs, :ret cret})))))))))\n     [{:path path, :pred 'ifn?, :val f, :via via, :in in}]))\n   (gen*\n    [_ overrides _ _]\n    (if\n     gfn\n     (gfn)\n     (gen/return\n      (fn\n       [& args]\n       (assert\n        (pvalid? argspec args)\n        (with-out-str (explain argspec args)))\n       (gen/generate (gen retspec overrides))))))\n   (with-gen*\n    [_ gfn]\n    (fspec-impl argspec aform retspec rform fnspec fform gfn))\n   (describe*\n    [_]\n    (clojure.core/sequence\n     (clojure.core/seq\n      (clojure.core/concat\n       (clojure.core/list 'clojure.core/fspec)\n       (clojure.core/list :args)\n       (clojure.core/list aform)\n       (clojure.core/list :ret)\n       (clojure.core/list rform)\n       (clojure.core/list :fn)\n       (clojure.core/list fform))))))))\n"} {:sym *coll-check-limit*, :meta {}, :source "(def\n *coll-check-limit*\n \"The number of items validated in a collection spec'ed with 'every'\"\n 101)\n"} {:sym get-spec, :meta {:doc "Returns spec registered for keyword/symbol/var k, or nil.", :arglists ([k])}, :source "(defn\n get-spec\n \"Returns spec registered for keyword/symbol/var k, or nil.\"\n [k]\n (get (registry) (if (keyword? k) k (->sym k))))\n"} {:sym every-impl, :meta {:doc "Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'", :arglists [[form pred opts] [form pred {gen-into :into, describe-form :clojure.core/describe, :keys [kind :clojure.core/kind-form count max-count min-count distinct gen-max :clojure.core/kfn :clojure.core/cpred conform-keys :clojure.core/conform-all], :or {gen-max 20}, :as opts} gfn]]}, :source "(defn\n every-impl\n \"Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'\"\n ([form pred opts] (every-impl form pred opts nil))\n ([form\n   pred\n   {gen-into :into,\n    describe-form :clojure.core/describe,\n    :keys\n    [kind\n     :clojure.core/kind-form\n     count\n     max-count\n     min-count\n     distinct\n     gen-max\n     :clojure.core/kfn\n     :clojure.core/cpred\n     conform-keys\n     :clojure.core/conform-all],\n    :or {gen-max 20},\n    :as opts}\n   gfn]\n  (let\n   [conform-into\n    gen-into\n    spec\n    (delay (specize pred))\n    check?\n    (fn* [p1__18554#] (valid? @spec p1__18554#))\n    kfn\n    (c/or kfn (fn [i v] i))\n    addcv\n    (fn [ret i v cv] (conj ret cv))\n    cfns\n    (fn\n     [x]\n     (cond\n      (c/and\n       (vector? x)\n       (c/or (not conform-into) (vector? conform-into)))\n      [identity\n       (fn [ret i v cv] (if (identical? v cv) ret (assoc ret i cv)))\n       identity]\n      (c/and\n       (map? x)\n       (c/or (c/and kind (not conform-into)) (map? conform-into)))\n      [(if conform-keys empty identity)\n       (fn\n        [ret i v cv]\n        (if\n         (c/and (identical? v cv) (not conform-keys))\n         ret\n         (assoc ret (nth (if conform-keys cv v) 0) (nth cv 1))))\n       identity]\n      (c/or\n       (list? conform-into)\n       (seq? conform-into)\n       (c/and (not conform-into) (c/or (list? x) (seq? x))))\n      [empty addcv reverse]\n      :else\n      [(fn* [p1__18555#] (empty (c/or conform-into p1__18555#)))\n       addcv\n       identity]))]\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (let\n      [spec @spec]\n      (cond\n       (not (cpred x))\n       :clojure.core/invalid\n       conform-all\n       (let\n        [[init add complete] (cfns x)]\n        (loop\n         [ret (init x) i 0 [v & vs :as vseq] (seq x)]\n         (if\n          vseq\n          (let\n           [cv (conform* spec v)]\n           (if\n            (invalid? cv)\n            :clojure.core/invalid\n            (recur (add ret i v cv) (inc i) vs)))\n          (complete ret))))\n       :else\n       (if\n        (indexed? x)\n        (let\n         [step (max 1 (long (/ (c/count x) *coll-check-limit*)))]\n         (loop\n          [i 0]\n          (if\n           (>= i (c/count x))\n           x\n           (if\n            (valid? spec (nth x i))\n            (recur (c/+ i step))\n            :clojure.core/invalid))))\n        (let\n         [limit *coll-check-limit*]\n         (loop\n          [i 0 [v & vs :as vseq] (seq x)]\n          (cond\n           (c/or (nil? vseq) (= i limit))\n           x\n           (valid? spec v)\n           (recur (inc i) vs)\n           :else\n           :clojure.core/invalid)))))))\n    (unform*\n     [_ x]\n     (if\n      conform-all\n      (let\n       [spec @spec [init add complete] (cfns x)]\n       (loop\n        [ret (init x) i 0 [v & vs :as vseq] (seq x)]\n        (if\n         (>= i (c/count x))\n         (complete ret)\n         (recur (add ret i v (unform* spec v)) (inc i) vs))))\n      x))\n    (explain*\n     [_ path via in x]\n     (c/or\n      (coll-prob\n       x\n       kind\n       kind-form\n       distinct\n       count\n       min-count\n       max-count\n       path\n       via\n       in)\n      (apply\n       concat\n       ((if conform-all identity (partial take *coll-error-limit*))\n        (keep\n         identity\n         (map\n          (fn\n           [i v]\n           (let\n            [k (kfn i v)]\n            (when-not\n             (check? v)\n             (let\n              [prob (explain-1 form pred path via (conj in k) v)]\n              prob))))\n          (range)\n          x))))))\n    (gen*\n     [_ overrides path rmap]\n     (if\n      gfn\n      (gfn)\n      (let\n       [pgen (gensub pred overrides path rmap form)]\n       (gen/bind\n        (cond\n         gen-into\n         (gen/return (empty gen-into))\n         kind\n         (gen/fmap\n          (fn*\n           [p1__18556#]\n           (if (empty? p1__18556#) p1__18556# (empty p1__18556#)))\n          (gensub kind overrides path rmap form))\n         :else\n         (gen/return []))\n        (fn\n         [init]\n         (gen/fmap\n          (fn*\n           [p1__18557#]\n           (if (vector? init) p1__18557# (into init p1__18557#)))\n          (cond\n           distinct\n           (if\n            count\n            (gen/vector-distinct\n             pgen\n             {:num-elements count, :max-tries 100})\n            (gen/vector-distinct\n             pgen\n             {:min-elements (c/or min-count 0),\n              :max-elements\n              (c/or\n               max-count\n               (max gen-max (c/* 2 (c/or min-count 0)))),\n              :max-tries 100}))\n           count\n           (gen/vector pgen count)\n           (c/or min-count max-count)\n           (gen/vector\n            pgen\n            (c/or min-count 0)\n            (c/or max-count (max gen-max (c/* 2 (c/or min-count 0)))))\n           :else\n           (gen/vector pgen 0 gen-max))))))))\n    (with-gen* [_ gfn] (every-impl form pred opts gfn))\n    (describe*\n     [_]\n     (c/or\n      describe-form\n      (clojure.core/sequence\n       (clojure.core/seq\n        (clojure.core/concat\n         (clojure.core/list 'clojure.core/every)\n         (clojure.core/list (s/mres form))\n         (mapcat identity opts))))))))))\n"} {:sym spec-impl, :meta {:doc "Do not call this directly, use 'spec'", :arglists [[form pred gfn cpred?] [form pred gfn cpred? unc]]}, :source "(defn\n spec-impl\n \"Do not call this directly, use 'spec'\"\n ([form pred gfn cpred?] (spec-impl form pred gfn cpred? nil))\n ([form pred gfn cpred? unc]\n  (cond\n   (spec? pred)\n   (cond-> pred gfn (with-gen gfn))\n   (regex? pred)\n   (regex-spec-impl pred gfn)\n   (ident? pred)\n   (cond-> (the-spec pred) gfn (with-gen gfn))\n   :else\n   (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n    Spec\n    (conform*\n     [_ x]\n     (let\n      [ret (pred x)]\n      (if cpred? ret (if ret x :clojure.core/invalid))))\n    (unform*\n     [_ x]\n     (if\n      cpred?\n      (if unc (unc x) (throw (js/Error. \"no unform fn for conformer\")))\n      x))\n    (explain*\n     [_ path via in x]\n     (when\n      (invalid? (dt pred x form cpred?))\n      [{:path path, :pred form, :val x, :via via, :in in}]))\n    (gen* [_ _ _ _] (if gfn (gfn) (gen/gen-for-pred pred)))\n    (with-gen* [_ gfn] (spec-impl form pred gfn cpred? unc))\n    (describe* [_] form)))))\n"} {:sym invalid?, :meta {:doc "tests the validity of a conform return value", :arglists ([ret])}, :source "(defn\n invalid?\n \"tests the validity of a conform return value\"\n [ret]\n (keyword-identical? :clojure.core/invalid ret))\n"} {:sym amp-impl, :meta {:doc "Do not call this directly, use '&'", :arglists ([re preds pred-forms])}, :source "(defn\n amp-impl\n \"Do not call this directly, use '&'\"\n [re preds pred-forms]\n {:clojure.core/op :clojure.core/amp,\n  :p1 re,\n  :ps preds,\n  :forms pred-forms})\n"} {:sym cat-impl, :meta {:doc "Do not call this directly, use 'cat'", :arglists ([ks ps forms])}, :source "(defn\n cat-impl\n \"Do not call this directly, use 'cat'\"\n [ks ps forms]\n (pcat* {:ks ks, :ps ps, :forms forms, :ret {}}))\n"} {:sym explain-str, :meta {:doc "Given a spec and a value that fails to conform, returns an explanation as a string.", :arglists ([spec x])}, :source "(defn\n explain-str\n \"Given a spec and a value that fails to conform, returns an explanation as a string.\"\n [spec x]\n (with-out-str (explain spec x)))\n"} {:sym *compile-asserts*, :meta {:doc "If true, compiler will enable spec asserts, which are then\nsubject to runtime control via check-asserts? If false, compiler\nwill eliminate all spec assert overhead. See 'assert'.\nInitially set to the negation of the ':elide-asserts' compiler option.\nDefaults to true."}, :source "(defonce *compile-asserts* (s/init-compile-asserts))\n"} {:sym with-gen, :meta {:doc "Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator", :arglists ([spec gen-fn])}, :source "(defn\n with-gen\n \"Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator\"\n [spec gen-fn]\n (let\n  [spec (reg-resolve spec)]\n  (if\n   (regex? spec)\n   (assoc spec :clojure.core/gfn gen-fn)\n   (with-gen* (specize spec) gen-fn))))\n"} {:sym conform*, :meta {:doc nil, :arglists ([spec x])}, :protocol Spec} {:sym check-asserts?, :meta {:doc "Returns the value set by check-asserts.", :arglists ([])}, :source "(defn\n check-asserts?\n \"Returns the value set by check-asserts.\"\n []\n *runtime-asserts*)\n"} {:sym rep-impl, :meta {:doc "Do not call this directly, use '*'", :arglists ([form p])}, :source "(defn\n rep-impl\n \"Do not call this directly, use '*'\"\n [form p]\n (rep* p p [] false form))\n"} {:sym describe, :meta {:doc "returns an abbreviated description of the spec as data", :arglists ([spec])}, :source "(defn\n describe\n \"returns an abbreviated description of the spec as data\"\n [spec]\n (abbrev (form spec)))\n"} {:sym explain-out, :meta {:doc "Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\n    by default explain-printer.", :arglists ([ed])}, :source "(defn\n explain-out\n \"Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\\n    by default explain-printer.\"\n [ed]\n (*explain-out* ed))\n"} {:sym specize*, :meta {:doc nil, :arglists ([_] [_ form])}, :protocol Specize} {:sym maybe-impl, :meta {:doc "Do not call this directly, use '?'", :arglists ([p form])}, :source "(defn\n maybe-impl\n \"Do not call this directly, use '?'\"\n [p form]\n (assoc\n  (alt* [p (accept :clojure.core/nil)] nil [form :clojure.core/nil])\n  :maybe\n  form))\n"} {:sym explain*, :meta {:doc nil, :arglists ([spec path via in x])}, :protocol Spec}), clojure.walk ({:sym walk, :meta {:doc "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :arglists ([inner outer form])}, :source "(defn\n walk\n \"Traverses form, an arbitrary data structure.  inner and outer are\\n  functions.  Applies inner to each element of form, building up a\\n  data structure of the same type, then applies outer to the result.\\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n {:added \"1.1\"}\n [inner outer form]\n (cond\n  (list? form)\n  (outer (apply list (map inner form)))\n  (seq? form)\n  (outer (doall (map inner form)))\n  (record? form)\n  (outer (reduce (fn [r x] (conj r (inner x))) form form))\n  (coll? form)\n  (outer (into (empty form) (map inner form)))\n  :else\n  (outer form)))\n"} {:sym postwalk, :meta {:doc "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :arglists ([f form])}, :source "(defn\n postwalk\n \"Performs a depth-first, post-order traversal of form.  Calls f on\\n  each sub-form, uses f's return value in place of the original.\\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n {:added \"1.1\"}\n [f form]\n (walk (partial postwalk f) f form))\n"} {:sym prewalk, :meta {:doc "Like postwalk, but does pre-order traversal.", :arglists ([f form])}, :source "(defn\n prewalk\n \"Like postwalk, but does pre-order traversal.\"\n {:added \"1.1\"}\n [f form]\n (walk (partial prewalk f) identity (f form)))\n"} {:sym keywordize-keys, :meta {:doc "Recursively transforms all map keys from strings to keywords.", :arglists ([m])}, :source "(defn\n keywordize-keys\n \"Recursively transforms all map keys from strings to keywords.\"\n {:added \"1.1\"}\n [m]\n (let\n  [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n  (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n"} {:sym stringify-keys, :meta {:doc "Recursively transforms all map keys from keywords to strings.", :arglists ([m])}, :source "(defn\n stringify-keys\n \"Recursively transforms all map keys from keywords to strings.\"\n {:added \"1.1\"}\n [m]\n (let\n  [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n  (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n"} {:sym prewalk-replace, :meta {:doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.", :arglists ([smap form])}, :source "(defn\n prewalk-replace\n \"Recursively transforms form by replacing keys in smap with their\\n  values.  Like clojure/replace but works on any data structure.  Does\\n  replacement at the root of the tree first.\"\n {:added \"1.1\"}\n [smap form]\n (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n"} {:sym postwalk-replace, :meta {:doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.", :arglists ([smap form])}, :source "(defn\n postwalk-replace\n \"Recursively transforms form by replacing keys in smap with their\\n  values.  Like clojure/replace but works on any data structure.  Does\\n  replacement at the leaves of the tree first.\"\n {:added \"1.1\"}\n [smap form]\n (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n"}), play-cljs.core ({:sym :bezier, :examples [{:doc "Draws a cubic Bezier curve on the screen.\n   \n   :x1  -  The x-coordinate of the first anchor point (number)\n   :y1  -  The y-coordinate of the first anchor point (number)\n   :x2  -  The x-coordinate of the first control point (number)\n   :y2  -  The y-coordinate of the first control point (number)\n   :x3  -  The x-coordinate of the second control point (number)\n   :y3  -  The y-coordinate of the second control point (number)\n   :x4  -  The x-coordinate of the second anchor point (number)\n   :y4  -  The y-coordinate of the second anchor point (number)\n   \n   :z1  -  The z-coordinate of the first anchor point (number)\n   :z2  -  The z-coordinate of the first control point (number)\n   :z3  -  The z-coordinate of the second anchor point (number)\n   :z4  -  The z-coordinate of the second control point (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:stroke {:colors [0 0 0]} [:bezier {:x1 85, :y1 20, :x2 10, :y2 10, :x3 90, :y3 90, :x4 15, :y4 80}]]}, :body (do (defonce bezier-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto bezier-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render bezier-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[:stroke\n {:colors [0 0 0]}\n [:bezier\n  {:x1 85, :y1 20, :x2 10, :y2 10, :x3 90, :y3 90, :x4 15, :y4 80}]]\n", :id "play-cljs.core/:bezier/0"}]} {:sym :hsb, :examples [{:doc "Causes the color values in all children to be interpreted as HSB colors.\n   \n   :max-h  -  Range for hue (number)\n   :max-s  -  Range for saturation (number)\n   :max-b  -  Range for brightness (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:hsb {:max-h 100, :max-s 100, :max-b 100} [:fill {:colors [20 50 70]} [:rect {:x 10, :y 10, :width 70, :height 70}]]]}, :body (do (defonce hsb-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto hsb-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render hsb-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[:hsb\n {:max-h 100, :max-s 100, :max-b 100}\n [:fill\n  {:colors [20 50 70]}\n  [:rect {:x 10, :y 10, :width 70, :height 70}]]]\n", :id "play-cljs.core/:hsb/0"}]} {:sym get-screen, :meta {:doc "Returns the `Screen` object currently being displayed.", :arglists ([game])}, :protocol Game} {:sym :stroke, :examples [{:doc "Sets the color used to draw lines and borders around the children.\n   \n   :color  -  The name of the color (string)\n   :colors -  The RGB or HSB color values (vector of numbers)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:stroke {:color "green"} [:rect {:x 50, :y 50, :width 70, :height 70}]]}, :body (do (defonce stroke-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto stroke-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render stroke-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[:stroke {:color \"green\"} [:rect {:x 50, :y 50, :width 70, :height 70}]]\n", :id "play-cljs.core/:stroke/0"}]} {:sym set-size, :meta {:doc "Sets the virtual width and height of the game.", :arglists ([game width height])}, :protocol Game} {:sym :animation, :examples [{:doc "Draws its children in a continuous loop.\n   \n   :duration  -  The number of milliseconds each child should be displayed (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:animation {:x 10, :y 10, :duration 200} [:image {:name "player_walk1.png", :width 80, :height 80}] [:image {:name "player_walk2.png", :width 80, :height 80}] [:image {:name "player_walk3.png", :width 80, :height 80}]]}, :body (do (defonce animation-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto animation-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render animation-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:animation\n {:x 10, :y 10, :duration 200}\n [:image {:name \"player_walk1.png\", :width 80, :height 80}]\n [:image {:name \"player_walk2.png\", :width 80, :height 80}]\n [:image {:name \"player_walk3.png\", :width 80, :height 80}]]\n", :id "play-cljs.core/:animation/0"}]} {:sym :arc, :examples [{:doc "Draws an arc to the screen.\n   \n   :width  -  The width of the arc (number)\n   :height -  The height of the arc (number)\n   :start  -  Angle to start the arc, in radians (number)\n   :stop   -  Angle to stop the arc, in radians (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:arc {:x 200, :y 0, :width 200, :height 200, :start 0, :stop 3.14}]}, :body (do (defonce arc-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto arc-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render arc-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[:arc {:x 200, :y 0, :width 200, :height 200, :start 0, :stop 3.14}]\n", :id "play-cljs.core/:arc/0"}]} {:sym :triangle, :examples [{:doc "A triangle is a plane created by connecting three points.\n   \n   :x1  -  The x-coordinate of the first point (number)\n   :y1  -  The y-coordinate of the first point (number)\n   :x2  -  The x-coordinate of the second point (number)\n   :y2  -  The y-coordinate of the second point (number)\n   :x3  -  The x-coordinate of the third point (number)\n   :y3  -  The y-coordinate of the third point (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:triangle {:x1 10, :y1 10, :x2 50, :y2 25, :x3 10, :y3 35}]}, :body (do (defonce triangle-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto triangle-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render triangle-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[:triangle {:x1 10, :y1 10, :x2 50, :y2 25, :x3 10, :y3 35}]\n", :id "play-cljs.core/:triangle/0"}]} {:sym get-canvas, :meta {:doc "Returns the internal canvas object.", :arglists ([game])}, :protocol Game} {:sym pre-render, :meta {:doc "Renders the provided data structure off-screen and associates it with the given name. Returns an `Image` object.", :arglists ([game image-name width height content])}, :protocol Game} {:sym load-image, :meta {:doc "Loads an image. Returns an `Image` object.", :arglists ([game path])}, :protocol Game} {:sym :fill, :examples [{:doc "Sets the color of the children.\n   \n   :color  -  The name of the color (string)\n   :colors -  The RGB or HSB color values (vector of numbers)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:fill {:color "purple"} [:rect {:x 40, :y 40, :width 150, :height 150}]]}, :body (do (defonce fill-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto fill-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render fill-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[:fill\n {:color \"purple\"}\n [:rect {:x 40, :y 40, :width 150, :height 150}]]\n", :id "play-cljs.core/:fill/0"}]} {:sym create-game, :meta {:doc "Returns a game object.", :arglists [[width height] [width height {:keys [parent]}]]}, :source "(defn\n create-game\n \"Returns a game object.\"\n ([width height] (create-game width height {}))\n ([width height {:keys [parent]}]\n  (let\n   [*hidden-state\n    (atom\n     {:screen nil,\n      :renderer nil,\n      :canvas nil,\n      :listeners [],\n      :total-time 0,\n      :delta-time 0,\n      :pressed-keys #{},\n      :assets {}})\n    setup-finished?\n    (promise-chan)]\n   (reify\n    Game\n    (start\n     [this]\n     (when-let [renderer (get-renderer this)] (.remove renderer))\n     (run! events/unlistenByKey (:listeners @*hidden-state))\n     (swap! *hidden-state assoc :listeners [])\n     (js/p5.\n      (fn\n       [renderer]\n       (set!\n        (.-setup renderer)\n        (fn\n         []\n         (let\n          [canvas-wrapper\n           (cond->\n            (.createCanvas renderer width height)\n            parent\n            (.parent parent))\n           canvas\n           (.-canvas canvas-wrapper)]\n          (.removeAttribute canvas \"style\")\n          (swap!\n           *hidden-state\n           assoc\n           :renderer\n           renderer\n           :canvas\n           canvas))\n         (put! setup-finished? true)))\n       (set!\n        (.-draw renderer)\n        (fn\n         []\n         (swap!\n          *hidden-state\n          (fn\n           [hidden-state]\n           (let\n            [time (.millis renderer)]\n            (assoc\n             hidden-state\n             :total-time\n             time\n             :delta-time\n             (- time (:total-time hidden-state))))))\n         (.clear renderer)\n         (some-> this get-screen on-render)))))\n     (listen\n      this\n      \"keydown\"\n      (fn\n       [e]\n       (swap! *hidden-state update :pressed-keys conj (.-keyCode e))))\n     (listen\n      this\n      \"keyup\"\n      (fn\n       [e]\n       (if\n        (contains? #{91 93} (.-keyCode e))\n        (swap! *hidden-state assoc :pressed-keys #{})\n        (swap!\n         *hidden-state\n         update\n         :pressed-keys\n         disj\n         (.-keyCode e)))))\n     (listen\n      this\n      \"blur\"\n      (fn* [] (swap! *hidden-state assoc :pressed-keys #{}))))\n    (listen\n     [this listen-type listener]\n     (swap!\n      *hidden-state\n      update\n      :listeners\n      conj\n      (events/listen js/window listen-type listener)))\n    (render\n     [this content]\n     (when-let\n      [renderer (get-renderer this)]\n      (draw-sketch! this renderer content {})))\n    (pre-render\n     [this image-name width height content]\n     (when-let\n      [renderer (get-renderer this)]\n      (let\n       [object (.createGraphics renderer width height)]\n       (draw-sketch! this object content {})\n       (swap! *hidden-state update :assets assoc image-name object)\n       object)))\n    (load-image\n     [this path]\n     (when-let\n      [renderer (get-renderer this)]\n      (let\n       [object (.loadImage renderer path (fn []))]\n       (swap! *hidden-state update :assets assoc path object)\n       object)))\n    (load-tiled-map\n     [this map-name]\n     (when-let\n      [renderer (get-renderer this)]\n      (let\n       [object (.loadTiledMap renderer map-name (fn []))]\n       (swap! *hidden-state update :assets assoc map-name object)\n       object)))\n    (get-screen [this] (:screen @*hidden-state))\n    (set-screen\n     [this screen]\n     (go\n      (<! setup-finished?)\n      (some-> this get-screen on-hide)\n      (swap! *hidden-state assoc :screen screen)\n      (on-show screen)))\n    (get-renderer [this] (:renderer @*hidden-state))\n    (get-canvas [this] (:canvas @*hidden-state))\n    (get-total-time [this] (:total-time @*hidden-state))\n    (get-delta-time [this] (:delta-time @*hidden-state))\n    (get-pressed-keys [this] (:pressed-keys @*hidden-state))\n    (get-width\n     [this]\n     (when-let [renderer (get-renderer this)] (.-width renderer)))\n    (get-height\n     [this]\n     (when-let [renderer (get-renderer this)] (.-height renderer)))\n    (set-size\n     [this width height]\n     (when-let\n      [renderer (get-renderer this)]\n      (.resizeCanvas renderer width height)))\n    (get-asset [game name] (get-in @*hidden-state [:assets name]))))))\n"} {:sym :rgb, :examples [{:doc "Causes the color values in all children to be interpreted as RGB colors.\n   \n   :max-r  -  Range for red (number)\n   :max-g  -  Range for green (number)\n   :max-b  -  Range for blue (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:rgb {:max-r 100, :max-g 100, :max-b 100} [:fill {:colors [20 50 70]} [:rect {:x 10, :y 10, :width 70, :height 70}]]]}, :body (do (defonce rgb-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto rgb-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render rgb-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[:rgb\n {:max-r 100, :max-g 100, :max-b 100}\n [:fill\n  {:colors [20 50 70]}\n  [:rect {:x 10, :y 10, :width 70, :height 70}]]]\n", :id "play-cljs.core/:rgb/0"}]} {:sym get-width, :meta {:doc "Returns the virtual width of the game.", :arglists ([game])}, :protocol Game} {:sym get-asset, :meta {:doc "Gets the asset with the given name.", :arglists ([game name])}, :protocol Game} {:sym get-height, :meta {:doc "Returns the virtual height of the game.", :arglists ([game])}, :protocol Game} {:sym :div, :examples [{:doc "Acts as a generic container of options that it passes\ndown to its children. The `x` and `y` are special in this example,\nserving as the pointer's position. Notice that the :rect is\nhard-coded at (0,0) but the :div is passing its own position down.", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:div {:x x, :y y} [:fill {:color "lightblue"} [:rect {:x 0, :y 0, :width 100, :height 100}]]]}, :body (do (defonce div-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto div-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 50, y 50}} (clojure.core/deref *state)] (try (let [content focus] (render div-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[:div\n {:x x, :y y}\n [:fill\n  {:color \"lightblue\"}\n  [:rect {:x 0, :y 0, :width 100, :height 100}]]]\n", :id "play-cljs.core/:div/0"}]} {:sym on-show, :meta {:doc "Runs once, when the screen first appears.", :arglists ([screen])}, :protocol Screen} {:sym Game, :meta {:doc "A game object contains the internal renderer object and various bits of state\nthat are important to the overall execution of the game. Every play-cljs game\nshould create just one such object by calling `create-game`."}, :methods (get-asset get-canvas get-delta-time get-height get-pressed-keys get-renderer get-screen get-total-time get-width listen load-image load-tiled-map pre-render render set-screen set-size start)} {:sym Screen, :meta {:doc "A screen object provides the basic lifecycle for a game.\nSimple games may only need to have one screen. They are a useful way to\nisolate different aspects of your game. For example, you could make one\nscreen display the title and menu, and another screen contain the game\nitself.\n\nYou can create a screen by using `reify` like this:\n\n```\n(def main-screen\n  (reify p/Screen\n    (on-show [this])\n    (on-hide [this])\n    (on-render [this])))\n```"}, :methods (on-hide on-render on-show)} {:sym start, :meta {:doc "Creates the canvas element.", :arglists ([game])}, :protocol Game} {:sym :line, :examples [{:doc "Draws a line (a direct path between two points) to the screen.\n   \n   :x1  -  The x-coordinate of the first point (number)\n   :y1  -  The y-coordinate of the first point (number)\n   :x2  -  The x-coordinate of the second point (number)\n   :y2  -  The y-coordinate of the second point (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:line {:x1 0, :y1 0, :x2 50, :y2 50}]}, :body (do (defonce line-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto line-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render line-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[:line {:x1 0, :y1 0, :x2 50, :y2 50}]\n", :id "play-cljs.core/:line/0"}]} {:sym get-delta-time, :meta {:doc "Returns the time since the last frame was rendered, in milliseconds.", :arglists ([game])}, :protocol Game} {:sym on-hide, :meta {:doc "Runs once, when the screen is no longer displayed.", :arglists ([screen])}, :protocol Screen} {:sym :quad, :examples [{:doc "Draw a quad. A quad is a quadrilateral, a four sided polygon.\n   \n   :x1  -  The x-coordinate of the first point (number)\n   :y1  -  The y-coordinate of the first point (number)\n   :x2  -  The x-coordinate of the second point (number)\n   :y2  -  The y-coordinate of the second point (number)\n   :x3  -  The x-coordinate of the third point (number)\n   :y3  -  The y-coordinate of the third point (number)\n   :x4  -  The x-coordinate of the fourth point (number)\n   :y4  -  The y-coordinate of the fourth point (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:quad {:x1 50, :y1 55, :x2 70, :y2 15, :x3 10, :y3 15, :x4 20, :y4 55}]}, :body (do (defonce quad-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto quad-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render quad-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[:quad {:x1 50, :y1 55, :x2 70, :y2 15, :x3 10, :y3 15, :x4 20, :y4 55}]\n", :id "play-cljs.core/:quad/0"}]} {:sym :shape, :examples [{:doc "Draws a complex shape.\n   \n   :points  -  The x and y vertexes to draw (vector of numbers)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:shape {:points [30 20 85 20 85 75 30 75]}]}, :body (do (defonce shape-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto shape-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render shape-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[:shape {:points [30 20 85 20 85 75 30 75]}]\n", :id "play-cljs.core/:shape/0"}]} {:sym get-pressed-keys, :meta {:doc "Returns a set containing the key codes for the keys currently being pressed.", :arglists ([game])}, :protocol Game} {:sym :ellipse, :examples [{:doc "Draws an ellipse (oval) to the screen.\n   \n   :width  -  The width of the ellipse (number)\n   :height -  The height of the ellipse (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:ellipse {:x 100, :y 100, :width 50, :height 70}]}, :body (do (defonce ellipse-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto ellipse-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render ellipse-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[:ellipse {:x 100, :y 100, :width 50, :height 70}]\n", :id "play-cljs.core/:ellipse/0"}]} {:sym on-render, :meta {:doc "Runs each time the game is ready to render another frame.", :arglists ([screen])}, :protocol Screen} {:sym :curve, :examples [{:doc "Draws a curved line on the screen between two points,\n   given as the middle four parameters.\n   \n   :x1  -  The x-coordinate of the beginning control point (number)\n   :y1  -  The y-coordinate of the beginning control point (number)\n   :x2  -  The x-coordinate of the first point (number)\n   :y2  -  The y-coordinate of the first point (number)\n   :x3  -  The x-coordinate of the second point (number)\n   :y3  -  The y-coordinate of the second point (number)\n   :x4  -  The x-coordinate of the ending control point (number)\n   :y4  -  The y-coordinate of the ending control point (number)\n   \n   :z1  -  The z-coordinate of the beginning control point (number)\n   :z2  -  The z-coordinate of the first point (number)\n   :z3  -  The z-coordinate of the second point (number)\n   :z4  -  The z-coordinate of the ending control point (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:stroke {:colors [255 102 0]} [:curve {:x1 5, :y1 26, :x2 5, :y2 26, :x3 73, :y3 24, :x4 73, :y4 180}]]}, :body (do (defonce curve-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto curve-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render curve-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[:stroke\n {:colors [255 102 0]}\n [:curve\n  {:x1 5, :y1 26, :x2 5, :y2 26, :x3 73, :y3 24, :x4 73, :y4 180}]]\n", :id "play-cljs.core/:curve/0"}]} {:sym :image, :examples [{:doc "Displays an image.\n   \n   :name    -  The file name of the image (string)\n   :width   -  The width of the image (number)\n   :height  -  The height of the image (number)\n   :sx      -  The x-coordinate of the subsection of the source image to draw into the destination rectangle (number)\n   :sy      -  The y-coordinate of the subsection of the source image to draw into the destination rectangle (number)\n   :swidth  -  The width of the subsection of the source image to draw into the destination rectangle (number)\n   :sheight -  The height of the subsection of the source image to draw into the destination rectangle (number)\n   :scale-x -  Percent to scale the image in the x-axis (number)\n   :scale-y -  Percent to scale the image in the y-axis (number)\n   :flip-x  -  Whether to flip the image on its x-axis (boolean)\n   :flip-y  -  Whether to flip the image on its y-axis (boolean)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:image {:name "player_stand.png", :x 0, :y 0, :width 80, :height 80}]}, :body (do (defonce image-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto image-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render image-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[:image {:name \"player_stand.png\", :x 0, :y 0, :width 80, :height 80}]\n", :id "play-cljs.core/:image/0"}]} {:sym draw-sketch!, :examples [{:doc "Creates a new entity type called :smiley that draws a smiley face.\nAfter defining the method, it can be rendered like this: [:smiley {:x 0 :y 0}]", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr (defmethod play-cljs.core/draw-sketch! :smiley [game renderer content parent-opts] (let [[command opts & children] content opts (play-cljs.utils/update-opts opts parent-opts play-cljs.utils/basic-defaults)] (play-cljs.core/draw-sketch! game renderer [:div {:x 100, :y 100} [:fill {:color "yellow"} [:ellipse {:width 100, :height 100} [:fill {:color "black"} [:ellipse {:x -20, :y -10, :width 10, :height 10}] [:ellipse {:x 20, :y -10, :width 10, :height 10}]] [:fill {} [:arc {:width 60, :height 60, :start 0, :stop 3.14}]]]]] opts) (play-cljs.core/draw-sketch! game renderer children opts)))}, :body (do (defonce smiley-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {}) var-obj focus] (doto smiley-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 150, y 150}} (clojure.core/deref *state)] (try (render smiley-game [:smiley {:x 0, :y 0}]) (callback var-obj) (catch js/Error e (callback e))))))))) nil), :body-str "(defmethod\n play-cljs.core/draw-sketch!\n :smiley\n [game renderer content parent-opts]\n (let\n  [[command opts & children]\n   content\n   opts\n   (play-cljs.utils/update-opts\n    opts\n    parent-opts\n    play-cljs.utils/basic-defaults)]\n  (play-cljs.core/draw-sketch!\n   game\n   renderer\n   [:div\n    {:x 100, :y 100}\n    [:fill\n     {:color \"yellow\"}\n     [:ellipse\n      {:width 100, :height 100}\n      [:fill\n       {:color \"black\"}\n       [:ellipse {:x -20, :y -10, :width 10, :height 10}]\n       [:ellipse {:x 20, :y -10, :width 10, :height 10}]]\n      [:fill\n       {}\n       [:arc {:width 60, :height 60, :start 0, :stop 3.14}]]]]]\n   opts)\n  (play-cljs.core/draw-sketch! game renderer children opts)))\n", :id "play-cljs.core/draw-sketch!/0"}]} {:sym :point, :examples [{:doc "Draws a point, a coordinate in space at the dimension of one pixel.", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [[:point {:x 5, :y 5}] [:point {:x 10, :y 5}] [:point {:x 15, :y 5}] [:point {:x 20, :y 5}] [:point {:x 25, :y 5}] [:point {:x 30, :y 5}] [:point {:x 35, :y 5}]]}, :body (do (defonce point-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto point-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render point-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[[:point {:x 5, :y 5}]\n [:point {:x 10, :y 5}]\n [:point {:x 15, :y 5}]\n [:point {:x 20, :y 5}]\n [:point {:x 25, :y 5}]\n [:point {:x 30, :y 5}]\n [:point {:x 35, :y 5}]]\n", :id "play-cljs.core/:point/0"}]} {:sym :contour, :examples [{:doc "Draws a negative shape.\n   \n   :points  -  The x and y vertexes to draw (vector of numbers)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:shape {:points [40 40 80 40 80 80 40 80]} [:contour {:points [20 20 20 40 40 40 40 20]}]]}, :body (do (defonce contour-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto contour-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render contour-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[:shape\n {:points [40 40 80 40 80 80 40 80]}\n [:contour {:points [20 20 20 40 40 40 40 20]}]]\n", :id "play-cljs.core/:contour/0"}]} {:sym render, :meta {:doc "Renders the provided data structure.", :arglists ([game content])}, :protocol Game} {:sym listen, :meta {:doc "Adds an event listener.", :arglists ([game listen-type listener])}, :protocol Game} {:sym load-tiled-map, :meta {:doc "Loads a tiled map. Returns a `TiledMap` object.\nA tiled map with the provided name must already be loaded\n(see the TiledMap docs for details).", :arglists ([game map-name])}, :protocol Game} {:sym set-screen, :meta {:doc "Sets the `Screen` object to be displayed.", :arglists ([game screen])}, :protocol Game} {:sym :rect, :examples [{:doc "Draws a rectangle to the screen.\n   A rectangle is a four-sided shape with every angle at ninety degrees.\n   \n   :width  -  The width of the rectangle (number)\n   :height -  The height of the rectangle (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:rect {:x 10, :y 15, :width 20, :height 30}]}, :body (do (defonce rect-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto rect-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render rect-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[:rect {:x 10, :y 15, :width 20, :height 30}]\n", :id "play-cljs.core/:rect/0"}]} {:sym get-total-time, :meta {:doc "Returns the total time transpired since the game started, in milliseconds.", :arglists ([game])}, :protocol Game} {:sym get-renderer, :meta {:doc "Returns the internal renderer object.", :arglists ([game])}, :protocol Game} {:sym :text, :examples [{:doc "Draws text to the screen.\n   \n   :value  -  The text to display (string)\n   :size   -  The font size (number)\n   :font   -  The name of the font (string)\n   :style  -  The font style (:normal, :italic, :bold)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:text {:value "Hello, world!", :x 0, :y 50, :size 16, :font "Georgia", :style :italic}]}, :body (do (defonce text-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card})) (let [*state (atom {})] (doto text-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render text-game content) (callback content)) (catch js/Error e (callback e))))))))) nil), :body-str "[:text\n {:value \"Hello, world!\",\n  :x 0,\n  :y 50,\n  :size 16,\n  :font \"Georgia\",\n  :style :italic}]\n", :id "play-cljs.core/:text/0"}]}), cljs.core.async.impl.timers ({:sym MAX_LEVEL, :meta {}, :source "(def MAX_LEVEL 15)\n"} {:sym P, :meta {}, :source "(def P (/ 1 2))\n"} {:sym random-level, :meta {:doc nil, :arglists [[] [level]]}, :source "(defn\n random-level\n ([] (random-level 0))\n ([level]\n  (if\n   (and (< (.random js/Math) P) (< level MAX_LEVEL))\n   (recur (inc level))\n   level)))\n"} {:sym skip-list-node, :meta {:doc nil, :arglists [[level] [k v level]]}, :source "(defn\n skip-list-node\n ([level] (skip-list-node nil nil level))\n ([k v level]\n  (let\n   [arr (make-array (inc level))]\n   (loop\n    [i 0]\n    (when (< i (alength arr)) (aset arr i nil) (recur (inc i))))\n   (SkipListNode. k v arr))))\n"} {:sym least-greater-node, :meta {:doc nil, :arglists [[x k level] [x k level update]]}, :source "(defn\n least-greater-node\n ([x k level] (least-greater-node x k level nil))\n ([x k level update]\n  (if-not\n   (neg? level)\n   (let\n    [x\n     (loop\n      [x x]\n      (if-let\n       [x' (aget (.-forward x) level)]\n       (if (< (.-key x') k) (recur x') x)\n       x))]\n    (when-not (nil? update) (aset update level x))\n    (recur x k (dec level) update))\n   x)))\n"} {:sym skip-list, :meta {:doc nil, :arglists ([])}, :source "(defn skip-list [] (SkipList. (skip-list-node 0) 0))\n"} {:sym timeouts-map, :meta {}, :source "(def timeouts-map (skip-list))\n"} {:sym TIMEOUT_RESOLUTION_MS, :meta {}, :source "(def TIMEOUT_RESOLUTION_MS 10)\n"} {:sym timeout, :meta {:doc "returns a channel that will close after msecs", :arglists ([msecs])}, :source "(defn\n timeout\n \"returns a channel that will close after msecs\"\n [msecs]\n (let\n  [timeout\n   (+ (.valueOf (js/Date.)) msecs)\n   me\n   (.ceilingEntry timeouts-map timeout)]\n  (or\n   (when\n    (and me (< (.-key me) (+ timeout TIMEOUT_RESOLUTION_MS)))\n    (.-val me))\n   (let\n    [timeout-channel (channels/chan nil)]\n    (.put timeouts-map timeout timeout-channel)\n    (dispatch/queue-delay\n     (fn\n      []\n      (.remove timeouts-map timeout)\n      (impl/close! timeout-channel))\n     msecs)\n    timeout-channel))))\n"}), cljs.spec.gen.alpha ({:sym quick-check, :meta {:doc nil, :arglists ([& args])}, :source "(defn quick-check [& args] (apply @quick-check-ref args))\n"} {:sym for-all*, :meta {:doc "Dynamically loaded clojure.test.check.properties/for-all*.", :arglists ([& args])}, :source "(defn\n for-all*\n \"Dynamically loaded clojure.test.check.properties/for-all*.\"\n [& args]\n (apply @for-all*-ref args))\n"} {:sym delay-impl, :meta {:doc nil, :arglists ([gfnd])}, :source "(defn\n delay-impl\n [gfnd]\n (generator (fn [rnd size] ((:gen @gfnd) rnd size))))\n"} {:sym cat, :meta {:doc "Returns a generator of a sequence catenated from results of\ngens, each of which should generate something sequential.", :arglists ([& gens])}, :source "(defn\n cat\n \"Returns a generator of a sequence catenated from results of\\ngens, each of which should generate something sequential.\"\n [& gens]\n (fmap (fn* [p1__18570#] (apply concat p1__18570#)) (apply tuple gens)))\n"} {:sym gen-for-pred, :meta {:doc "Given a predicate, returns a built-in generator if one exists.", :arglists ([pred])}, :source "(defn\n gen-for-pred\n \"Given a predicate, returns a built-in generator if one exists.\"\n [pred]\n (if (set? pred) (elements pred) (get @gen-builtins pred)))\n"})}, :rel-path "../../", :hide-sidebar? true, :static? true, :ns-sym play-cljs.core, :vars [{:sym set-screen, :meta {:doc "Sets the `Screen` object to be displayed.", :arglists ([game screen])}, :protocol Game}]}</script>
        <script type="text/javascript" src="../../main.js"></script>
    </body>
</html>
