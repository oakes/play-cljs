<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="../../style.css">
        <link rel="stylesheet" type="text/css" href="../../paren-soup-light.css">
    </head>
    <body>
        <span id="app"><div data-reactroot="" data-reactid="1" data-react-checksum="188090564"><div style="left:0;" class="vars" data-reactid="2"><!-- react-empty: 3 --><div class="var-info" data-reactid="4"><div data-reactid="5"><h2 data-reactid="6">:shape</h2></div><div class="section" data-reactid="7"><h2 data-reactid="8">Example</h2><div class="section" data-reactid="9"><div class="section doc" data-reactid="10">Draws a complex shape.
   
   :points  -  The x and y vertexes to draw (vector of numbers)</div><div id="play-cljs.core/:shape/0" class="card" data-reactid="11"></div><div class="paren-soup" data-reactid="12"><div style="display:list-item;" class="instarepl" data-reactid="13"></div><div class="content" data-reactid="14"><span class='collection vector'><span class='delimiter'>[</span><span class='keyword'>:shape</span> <span class='collection map'><span class='delimiter'>{</span><span class='keyword'>:points</span> <span class='collection vector'><span class='delimiter'>[</span><span class='number'>30</span> <span class='number'>20</span> <span class='number'>85</span> <span class='number'>20</span> <span class='number'>85</span> <span class='number'>75</span> <span class='number'>30</span> <span class='number'>75</span><span class='delimiter'>]</span></span><span class='delimiter'>}</span></span><span class='delimiter'>]</span></span>
</div></div></div></div></div><div class="footer" data-reactid="15"><!-- react-text: 16 -->Generated by <!-- /react-text --><a href="https://github.com/oakes/Dynadoc" target="_blank" data-reactid="17">Dynadoc</a></div></div></div></span>
        <script type="text/edn" id="initial-state">{:ns-meta nil, :var-sym :shape, :type :cljs, :nses [{:var-syms [cljs cljs-version main-files assert-cljs-edn!], :type :clj, :sym adzerk.boot-cljs} {:var-syms [compiled analyzed], :type :clj, :sym adzerk.boot-cljs.js-deps} {:var-syms [main non-standard-defaults compiler-options modules set-option source-map], :type :clj, :sym adzerk.boot-cljs.middleware} {:var-syms [last-cause find-original-path path->js path get-name merge-cause-ex-data path->ns deserialize-object last-cause-message find-relative-path serialize-object], :type :clj, :sym adzerk.boot-cljs.util} {:var-syms [reload], :type :clj, :sym adzerk.boot-reload} {:var-syms [js-reserved path->ns ns->file], :type :clj, :sym adzerk.boot-reload.util} {:var-syms [deps load-deps], :type :clj, :sym boot-tools-deps.core} {:var-syms [clifn defclifn], :type :clj, :sym boot.cli} {:var-syms [tmppath tmptime output-dirs replace-task! sync! reset-fileset fileset-changed post-env! fileset-namespaces get-env with-pre-wrap not-by-path *warnings* deftask tmp-dir patch! user-dirs tmpget cleanup rm input-files fileset-reduce not-by-meta output-files bootignore add-cached-source with-post-wrap merge-env! tmpdir mv by-meta init! output-fileset get-checkouts gpg-decrypt by-name not-by-ext add-cached-asset tmp-get input-fileset new-fileset commit! not-by-re configure-repositories! by-ext mv-asset by-re *app-version* boot user-files set-env! task-options! file-filter temp-dir! mv-resource add-resource load-data-readers! tmp-path template json-parse reset-build! pre-env! fileset-diff new-build-at rebuild! ls *boot-script* watch-dirs add-source last-file-change fileset-removed cp *boot-opts* add-asset launch-nrepl yaml-generate yaml-parse empty-dir! add-cached-resource get-sys-env not-by-name set-sys-env! mv-source cache-dir! json-generate git-files touch fileset-added disable-task! tmp-dir! tmpfile with-pass-thru input-dirs tmp-file by-path tmp-time *boot-version* add-meta], :type :clj, :sym boot.core} {:var-syms [windows? sync! delete-empty-subdirs! guard hard-link delete-file path srcdir->outdir parent? tmpdir clean! copy-with-lastmod patch parent parent-seq copy-files *hard-link* name *include* move *exclude* *ignore* *sync-delete* file-seq relative-to lockfile file-seq-nofollow file? walk-file-tree patch-cp? empty-dir! watcher! split-path print-ex exists? sym-link dir? delete-all match-filter? tmpfile time-diff tmpfile-permissions copy-atomically keep-filters? tree-for], :type :clj, :sym boot.file} {:var-syms [windows? tree-diff map->FileSystemTree read-only skip-subtree link! merge-trees mkignores patch! mkvisitor ->FileSystemTree IToPath touch! path->segs ->path tmp-attrs open-opts continue mkparents! link-opts copy! tree-patch copy-opts write! mkjarfs delete! mktree], :type :clj, :sym boot.filesystem} {:var-syms [patch patch-result], :type :clj, :sym boot.filesystem.patch} {:var-syms [syntax-quote-fn unquote-splicing? quote-fn unquote? *resolve* resolve-symbol template syntax-quote defquote template-fn], :type :clj, :sym boot.from.backtick} {:var-syms [cli parse-opts summarize compile-option-specs], :type :clj, :sym boot.from.clojure.tools.cli} {:var-syms [sha-256 sha Digestible sha-1 md5 sha-384 -digest md2 sha-512 digest sha1 sha-224 algorithms *buffer-size*], :type :clj, :sym boot.from.digest} {:var-syms [cyan-bg magenta red-font bold-yellow-bg-font bold-green bold-yellow bold-red-bg bold-white-bg bold-cyan italic cyan-font strip-ansi bold-green-bg-font bold-red-bg-font visual-length black bold-black-bg bold bold-yellow-bg white-font bold-white bold-red red-bg cyan-bg-font bold-cyan-bg magenta-bg-font yellow-bg black-font yellow-bg-font white yellow bold-black-bg-font bold-green-bg bold-font inverse reset-font green-bg-font inverse-font white-bg-font green cyan black-bg-font green-font bold-magenta bold-red-font blue-bg-font bold-magenta-bg-font bold-cyan-font bold-white-bg-font blue-bg green-bg bold-blue-bg italic-font csi black-bg blue-font magenta-font yellow-font red-bg-font bold-yellow-font white-bg bold-cyan-bg-font magenta-bg bold-magenta-bg sgr bold-magenta-font red blue bold-black-font bold-blue-font bold-white-font bold-black bold-blue-bg-font bold-green-font bold-blue], :type :clj, :sym boot.from.io.aviso.ansi} {:var-syms [max-value-length format-columns write-rows max-length], :type :clj, :sym boot.from.io.aviso.columns} {:var-syms [*traditional* *fonts* format-exception *default-frame-filter* write-exception* *default-frame-rules* exception-dispatch demangle expand-stack-trace write-exception parse-exception analyze-exception], :type :clj, :sym boot.from.io.aviso.exception} {:var-syms [pretty-print format-exception pretty-print-stack-trace copy uncaught-exception-handler install-pretty-exceptions paste pretty-repl-caught pretty-pst], :type :clj, :sym boot.from.io.aviso.repl} {:var-syms [StringWriter flush-writer write into-string write-string writeln writef eol], :type :clj, :sym boot.from.io.aviso.writer} {:var-syms [feed-from flush exit-code done feed-from-string stream-to-string proc stream-to destroy read-line stream-to-out], :type :clj, :sym boot.from.me.raynes.conch} {:var-syms [format-cell table *style* table-str], :type :clj, :sym boot.from.table.core} {:var-syms [auto-resize-widths outer-border-length get-widths get-initial-widths ensure-valid-width *width* inner-border-length], :type :clj, :sym boot.from.table.width} {:var-syms [tag branch-current ls-tags clean? dirty? status last-commit describe ls-files make-gitignore-matcher], :type :clj, :sym boot.git} {:var-syms [gpg sign gpg-program signing-args sign-jar decrypt], :type :clj, :sym boot.gpg} {:var-syms [update-zip! spit-jar! jarentry spit-zip! dupe? update-jar!], :type :clj, :sym boot.jar} {:var-syms [normalize no-incoming choose topo-sort], :type :clj, :sym boot.kahnsort} {:var-syms [cli-opts parse-bootignore -main shebang? pr-boot-form emit], :type :clj, :sym boot.main} {:var-syms [prn-conflicts dep-conflicts safe-read-string compare-version resolved-versions sortable-version], :type :clj, :sym boot.pedantic} {:var-syms [sealed-classloader-fns with-worker apply-global-exclusions require-in copy-url classloader-resources resolve-release-versions resources pom-xml concat-merger jars-dep-graph eval-in* full-id with-eval-in worker-pod jar-entries* pom-xml-map dependency-pom-properties pod-pool pom-properties data resolve-dependency-jar dependency-pom-properties-map add-dependencies first-wins-merger standard-jar-exclusions destroy-pod canonical-id coord->map with-call-worker send! pom-properties-map canonical-coord unpack-jar this-pod make-pod extend-addable-classloader outdated with-eval-worker resolve-dependencies make-pod-cp pod-id non-caching-url-input-stream into-merger add-shutdown-hook! eval-fn-call pod-name with-invoke-in modifiable-classloader? with-call-in add-dependencies-in jar-entries seal-app-classloader jar-entries-memoized* call-in* classloader-hierarchy copy-resource resolve-nontransitive-dependencies default-dependencies eval-in-callee set-worker-pod! env set-this-pod! caller-namespace add-classpath set-data! with-invoke-worker dependency-loaded? apply-exclusions copy-dependency-jar-entries set-pod-id! map->coord standard-jar-mergers resource-last-modified resolve-dependency-jars jars-in-dep-order with-pod get-classpath pods get-pods eval-in-caller extract-ids set-pods! add-dependencies-worker shutdown-hooks lifecycle-pool], :type :clj, :sym boot.pod} {:var-syms [*default-dependencies* *default-middleware* launch-nrepl], :type :clj, :sym boot.repl} {:var-syms [sift-action read-pass print-fileset], :type :clj, :sym boot.task-helpers} {:var-syms [notify-method boot-logo get-themefiles audible-notify! visual-notify!], :type :clj, :sym boot.task-helpers.notify} {:var-syms [target notify help speak pom sift show web install push jar checkout javac with-cp war add-repo aot zip watch repl wait uber], :type :clj, :sym boot.task.built-in} {:var-syms [->TmpDir ->TmpFileSet add add-tmp map->TmpFileSet removed rm diff path add-cached ITmpFileSet mv hash dir bdir commit! added *hard-link* file time map->TmpDir CACHE_VERSION map->TmpFile state ITmpFile ls cp tmpfileset? ->TmpFile tmpfile? fileset-patch restrict-dirs id changed], :type :clj, :sym boot.tmpdir} {:var-syms [->TmpRegistry -mk! mkdir! mk! mark-delete-me! -get munged-file -init! get init! clean-delete-me! dir-id registry map->TmpRegistry unmk! make-file! tmp-file? -unmk! delete! ITmpRegistry -tmpfile?], :type :clj, :sym boot.tmpregistry} {:var-syms [deploy local run-docs], :type :clj, :sym boot.user} {:var-syms [sh with-let dbug *verbosity* without-exiting exit-error with-err-str guard dotoseq extends-protocol with-rethrow with-semaphore dosh colorize?-system-default jarname do-while-let exit-ok dep-as-map bind-syms warn path->ns let-assert-keys read-string-all pp-str with-semaphore-noblock *sh-dir* with-resolve dbug* print-tree auto-flush *colorize?* fail print-ex map-as-dep pp* while-let warn-deprecated index-of info extract-ids], :type :clj, :sym boot.util} {:var-syms [->clj *to-pod* *from-pod* *for-eval*], :type :clj, :sym boot.xform} {:var-syms [type? get-namespace error-message elide-reader-meta missing-rename? resolve-invokeable-ns analyze-let with-core-macros var-meta desugar-ns-specs js-tag? analyze-map NUMERIC_SET analyze-record analyze-seq* constants-ns-sym resolve-alias *cljs-dep-set* resolve-var write-analysis-cache disallowing-ns* process-rewrite-form js-star-seg dep-has-global-exports? register-specs gen-user-ns *passes* has-extern?* get-expander-ns message parse-invoke *cljs-warning-handlers* disallowing-recur analyze-seq*-wrap confirm-bindings has-extern? foreign-dep? missing-rename-macro? missing-uses missing-use? with-warning-handlers es5-allowed analyze used? node-module-dep? parse-type gets check-rename-macros-inferring-missing *allow-ns* transit-write-opts forms-seq* infer-invoke *cljs-static-fns* array-types *check-alias-dupes* macro-ns-name *reload-macros* resolve-existing-var required? NOT_NATIVE *unchecked-arrays* IGNORE_SYM parse-invoke* *checked-arrays* aliasable-clj-ns? loaded-js-ns? analyze-vector transit-read-opts namespaces elide-analyzer-meta analyze-let-body get-col basic-validate-ns-spec *cljs-warnings* alias->type analyzed? analyze-deps array-type? dotted-symbol? *cljs-macros-is-classpath* locate-src ns-side-effects *allow-redef* analyze-fn-method-body infer-type parse-import-spec clj-ns->cljs-ns constant-value? dump-specs *fn-invoke-direct* use->require inferred-use-macros read-analysis-cache analyze-symbol confirm-var-exists analyze-keyword SENTINEL analyze-let-bindings munge-global-export *loop-lets* js-tag js-reserved *load-tests* requires-analysis? check-use-macros-inferring-missing load-core macroexpand-1* check-use-macros get-expander analyze-js-star build-dot-form js-star-interp *recur-frames* analyze-fn-methods-pass2* macroexpand-1 analyze-file resolve-macro-var analyze-let-binding-init infer-tag canonicalize-import-specs analyze-form-seq analyze-let-body* analyze-js-star* inferred-rename-macros parse-ns-error-msg missing-use-macro? analyzed resolve-symbol all-warn missing-renames resolve* *cljs-macros-path* load-mutex confirm-var-exist-warning unchecked-arrays? analyze-dot analyze-do-statements get-line analyze-do-statements* analyze-seq find-def-clash get-expander* no-warn allowing-redef fn-name-var munge-node-lib *load-macros* excluded? empty-env public-name? default-warning-handler resolve-ns-alias intern-macros BOOLEAN_OR_SEQ *macro-infer* gen-constant-id BOOLEAN_SYM cache-file macro-autoload-ns? get-tag implicit-nses valid-proto parse-ns normalize-js-tag analyze-list warning implicit-import? missing-use-macros rewrite-cljs-aliases analyze* -cljs-macros-loaded check-uses find-matching-method invoke-arg-type-validators *cljs-file* *file-defs* infer-if *verbose* analyze-js-value ns->module-type source-info wrapping-errors transit analyze-fn-method-param analyze-set numeric-type? ast? checked-arrays elide-env js-module-exists?* parse-require-spec analyze-wrap-meta ANY_SYM get-js-tag parse forms-seq *analyze-deps* analyze-let-bindings* analysis-error? replace-env-pass parse-ns-excludes analyze-fn-methods-pass2 core-name? get-let-tag specials resolve-macro-ns-alias check-invoke-arg-types confirm-ns default-namespaces *unchecked-if* canonicalize-specs confirm-var-exists-throw js-module-exists? analyze-form with-core-macros-file var-ast add-consts error invokeable-ns? *cljs-ns*], :type :clj, :sym cljs.analyzer} {:var-syms [emit-constants-table-to-file protocol-prefix emit-arguments-to-array compile-file* distinct-keys? munge compile-root get-define valid-define-value? find-source emit-cached-core emits-keyword emit-inferred-externs-to-file *lexical-renames* emit-let with-core-cljs find-root-sources cljs-reserved-file-names base-types resolve-type emit-variadic-fn-method js-reserved *recompiled* rename-to-js requires-compilation? emits emit-constant emit-constants-table get-first-ns-segment emit-fn-params munge-reserved emit-source fn-self-name load-libs compile-file macro-ns? munge-param-return find-ns-starts-with emit* checking-types? cljs-files-in emit-fn-method emit-comment hash-scope emit-apply-to emits-symbol falsey-constant? *source-map-data* mapped-types resolve-types cached-core *inputs* emit-str compiled-by-string truthy-constant? emitln url-path emit safe-test? emit-externs emit-source-map distinct-constants? emit-wrap shadow-depth], :type :clj, :sym cljs.compiler} {:var-syms [ensure with-compiler-env default-compiler-env *compiler*], :type :clj, :sym cljs.env} {:var-syms [parse-extern-node get-type parse-externs externs-map annotate index-externs get-type*], :type :clj, :sym cljs.externs} {:var-syms [zip-file goog-dependencies load-foreign-library find-js-jar find-js-fs find-js-resources to-url -requires build-index jar-entry-names find-js-classpath goog-dependencies* -provides native-node-modules IJavaScript -source lib-spec-merge dependency-order-visit js-dependency-index -relative-path load-foreign-library* load-library -url find-url -foreign? get-file load-library* jar-entry-names* -closure-lib? library-dependencies find-classpath-lib parse-js-ns dependency-order], :type :clj, :sym cljs.js-deps} {:var-syms [update-result encode invert-reverse-map relativize-path decode seg->map source-compare decode-reverse lines->segs merge-source-maps update-reverse-result indexed-sources encode* seg-combine], :type :clj, :sym cljs.source-map} {:var-syms [chars64 encode int->char decode char->int], :type :clj, :sym cljs.source-map.base64} {:var-syms [encode-val encode vlq-continuation-bit vlq-base-mask bit-shift-right-zero-fill decode vlq-base-shift from-vlq-signed to-vlq-signed vlq-base], :type :clj, :sym cljs.source-map.base64-vlq} {:var-syms [read-uuid valid-js-literal-key? read-inst read-queue *cljs-data-readers* ->JSValue read-js], :type :clj, :sym cljs.tagged-literals} {:var-syms [output-directory windows? *clojurescript-version* boolean? file-or-resource distinct-by path normalize-path clojurescript-version ext content-sha valid-js-id-start? ns->relpath get-name debug-prn-mutex map-merge to-target-file mkdirs compile-if url? module-file-seq conjunction-str suggestion path-seq compiled-by-version measure ns->source last-modified debug-prn file? unknown-opts levenshtein-distance filename to-path topo-sort munge-path build-options changed? relative-name], :type :clj, :sym cljs.util} {:var-syms [primitives-classnames +' decimal? restart-agent sort-by macroexpand ensure chunk-first eduction tree-seq unchecked-remainder-int seq reduce when-first find-ns get-thread-bindings contains? every? proxy-mappings keep-indexed cond->> subs ref-min-history set take-last bit-set reader-conditional gen-class qualified-keyword? while ->Eduction butlast satisfies? line-seq unchecked-subtract-int *print-namespace-maps* take-nth first re-groups seq? dec' ns-unmap println-str with-bindings* inst-ms iterator-seq iterate slurp newline short-array fn? doall prefers enumeration-seq dedupe dissoc atom import bit-shift-right print-method peek aget pvalues bound-fn vswap! last pr namespace push-thread-bindings bases = dosync remove-ns take vector? thread-bound? send-via boolean bit-shift-left any? find-var rand-int aclone vreset! chunk dec future-call resultset-seq struct map juxt ns-publics < *source-path* with-loading-context test rest ex-data compile isa? boolean? .. munge delay set-error-mode! re-seq char? make-hierarchy set-agent-send-executor! swap-vals! keep char mapcat unchecked-long aset-long some? unchecked-negate gen-interface *command-line-args* reverse inst? range sort -cache-protocol-fn unchecked-inc-int map-indexed with-bindings rand-nth comp await spit future-done? *read-eval* dorun simple-symbol? disj *2 eval cons refer print-dup -reset-methods floats pos? fnil merge-with nthrest load if-not *verbose-defrecords* sequential? *print-level* shuffle boolean-array find alength bit-xor deliver doseq unsigned-bit-shift-right neg? var-set unchecked-float pmap error-mode num reduced? disj! float? aset-float deftype bean booleans ns-unalias when-let int-array set? inc' cat StackTraceElement->vec *suppress-read* flush take-while vary-meta <= alter -' if-some conj! repeatedly zipmap reset-vals! alter-var-root biginteger remove * re-pattern min pop! chunk-append prn-str with-precision format reversible? shutdown-agents conj bound? transduce lazy-seq *print-length* *file* compare-and-set! *use-context-classloader* await1 let ref-set pop-thread-bindings interleave printf map? -> defstruct *err* get doto identity into areduce long double volatile? definline nfirst meta find-protocol-impl bit-and-not *default-data-reader-fn* var? method-sig unchecked-add-int unquote-splicing hash-ordered-coll future reset-meta! cycle fn seque empty? short definterface filterv hash quot ns-aliases read unchecked-double key longs not= string? uri? aset-double unchecked-multiply-int chunk-rest pcalls *allow-unresolved-vars* remove-all-methods ns-resolve as-> aset-boolean trampoline double? when-not *1 vec *print-meta* when int map-entry? ns-refers rand second vector-of hash-combine > replace int? associative? unchecked-int set-error-handler! inst-ms* keyword? force bound-fn* namespace-munge group-by prn extend unchecked-multiply some->> default-data-readers ->VecSeq even? unchecked-dec Inst tagged-literal? double-array in-ns create-ns re-matcher defn ref bigint extends? promise aset-char rseq construct-proxy agent-errors *compile-files* *math-context* float pr-str concat aset-short set-agent-send-off-executor! ns symbol to-array-2d mod amap pop use unquote declare dissoc! reductions aset-byte indexed? ref-history-count - assoc! hash-set reduce-kv or cast reset! name ffirst sorted-set counted? byte-array tagged-literal println extend-type macroexpand-1 assoc-in char-name-string bit-test defmethod EMPTY-NODE time memoize alter-meta! future? zero? simple-keyword? require unchecked-dec-int persistent! nnext add-watch not-every? class? rem agent-error some future-cancelled? memfn neg-int? struct-map drop *data-readers* nth sorted? nil? extend-protocol split-at *e load-reader random-sample cond-> dotimes select-keys bit-and bounded-count update list* reify update-in prefer-method aset-int *clojure-version* ensure-reduced *' instance? with-open mix-collection-hash re-find run! val defonce unchecked-add loaded-libs ->Vec bytes? not with-meta unreduced the-ns record? type identical? unchecked-divide-int ns-name max-key *unchecked-math* defn- *out* file-seq agent ns-map set-validator! ident? defprotocol swap! vals unchecked-subtract *warn-on-reflection* sorted-set-by sync qualified-ident? assert *compile-path* true? release-pending-sends print empty remove-method *in* print-ctor letfn volatile! / read-line reader-conditional? bit-or clear-agent-errors vector proxy-super >= drop-last not-empty distinct partition loop add-classpath bit-flip long-array descendants merge accessor integer? mapv partition-all partition-by numerator object-array with-out-str condp derive load-string special-symbol? ancestors subseq error-handler gensym cond ratio? delay? intern print-simple flatten doubles halt-when with-in-str remove-watch ex-info ifn? some-> nat-int? proxy-name ns-interns all-ns find-protocol-method subvec for binding partial chunked-seq? find-keyword replicate min-key reduced char-escape-string re-matches array-map unchecked-byte with-local-vars ns-imports send-off defmacro every-pred keys rationalize load-file distinct? pos-int? extenders unchecked-short methods odd? ->ArrayChunk float-array *3 alias frequencies read-string proxy rsubseq inc get-method with-redefs uuid? bit-clear filter locking list + split-with aset ->VecNode keyword *ns* destructure *assert* defmulti chars str next hash-map if-let underive ref-max-history Throwable->map false? *print-readably* ints class some-fn case *flush-on-newline* to-array bigdec list? simple-ident? bit-not io! xml-seq byte max == *agent* lazy-cat comment parents count supers *fn-loader* sorted-map-by apply interpose deref assoc rational? transient clojure-version chunk-cons comparator sorted-map send drop-while proxy-call-with-super realized? char-array resolve compare complement *compiler-options* *print-dup* defrecord with-redefs-fn sequence constantly get-proxy-class make-array shorts completing update-proxy unchecked-negate-int hash-unordered-coll repeat unchecked-inc *reader-resolver* nthnext and create-struct get-validator number? await-for chunk-next print-str not-any? into-array qualified-symbol? init-proxy chunk-buffer seqable? symbol? when-some unchecked-char ->> future-cancel var-get commute coll? get-in fnext denominator bytes refer-clojure], :type :clj, :sym clojure.core} {:var-syms [Pub reduce remove> timeout unsub* admix* unmix* mix pub take unsub-all* <! map Mux mapcat> buffer close! offer! chan solo-mode* tap go admix promise-chan unique muxch* solo-mode transduce onto-chan to-chan dropping-buffer untap-all into >!! alt! pipeline sub go-loop map> pipe unmix filter< sub* remove< alt!! untap* <!! toggle untap-all* sliding-buffer partition Mult merge partition-by unsub-all >! unmix-all* split unmix-all filter> tap* untap alts! unsub poll! thread map< fn-handler do-alts pipeline-blocking pipeline-async Mix toggle* mult thread-call alts!! mapcat< ioc-alts! unblocking-buffer? do-alt put! take!], :type :clj, :sym clojure.core.async} {:var-syms [->PromiseBuffer ->DroppingBuffer dropping-buffer fixed-buffer ->FixedBuffer sliding-buffer ->SlidingBuffer promise-buffer], :type :clj, :sym clojure.core.async.impl.buffers} {:var-syms [cleanup chan box MMC abort assert-unlock ->ManyToManyChannel], :type :clj, :sym clojure.core.async.impl.channels} {:var-syms [counted-thread-factory processors], :type :clj, :sym clojure.core.async.impl.concurrent} {:var-syms [executor run], :type :clj, :sym clojure.core.async.impl.dispatch} {:var-syms [thread-pool-executor], :type :clj, :sym clojure.core.async.impl.exec.threadpool} {:var-syms [index-state-machine ->PopTry EXCEPTION-FRAMES block-references reads-from index-block map->Case map->InstanceInterop add-block instruction? ->RawCode let-binding-to-ssa map->CondBr map->Const ->Call ->Jmp ->CondBr map->PushTry count-persistent-values get-binding gen-plan -item-to-ssa ->Case get-block id-for-inst index-instruction pdebug writes-to ->Dot map->CustomTerminator terminator-code set-block ->CatchHandler STATE-IDX ->PushTry mark-transitions ->Fn map->CatchHandler ->Return aset-object run-passes IEmittableInstruction map->Call ITerminator map->Fn emit-instruction IInstruction map->Dot make-env propagate-recur terminate-block ->InstanceInterop map->PopTry persistent-value? propagate-transitions assoc-in-plan run-state-machine-wrapped push-alter-binding aset-all! debug parse-to-state-machine get-plan FN-IDX aget-object return-chan all pop-binding ->EndFinally nested-go? ->Recur add-instruction no-op passes push-binding ->CustomTerminator BINDINGS-IDX map->Return item-to-ssa map->EndFinally async-custom-terminators ->StaticCall map->RawCode CURRENT-EXCEPTION emit-hinted ->Const map->StaticCall print-plan run-state-machine get-in-plan update-in-plan map->Recur map->Jmp finished? USER-START-IDX put! take! var-name state-machine VALUE-IDX], :type :clj, :sym clojure.core.async.impl.ioc-macros} {:var-syms [mutex], :type :clj, :sym clojure.core.async.impl.mutex} {:var-syms [remove! close-buf! close! Handler blockable? active? Buffer full? add! lock-id exec Executor add!* ReadPort Channel closed? UnblockingBuffer MAX-QUEUE-SIZE commit put! take! WritePort], :type :clj, :sym clojure.core.async.impl.protocols} {:var-syms [->TimeoutQueueEntry timeout timeout-daemon TIMEOUT_RESOLUTION_MS], :type :clj, :sym clojure.core.async.impl.timers} {:var-syms [defcache clear-soft-cache! make-reference ->FnCache ->SoftCache soft-cache-factory ->TTLCache has? evict miss lookup hit through ttl-cache-factory lu-cache-factory ->LIRSCache ->LRUCache ->BasicCache lirs-cache-factory basic-cache-factory CacheProtocol seed fifo-cache-factory ->FIFOCache ->LUCache lru-cache-factory], :type :clj, :sym clojure.core.cache} {:var-syms [memo-ttl ->PluggableMemoization memo memoized? lu fifo memo-unwrap through* memo-fifo memo-swap! ->RetryingDelay lru build-memoizer snapshot ttl memo-lu memo-clear! memo-lru], :type :clj, :sym clojure.core.memoize} {:var-syms [IKVReduce CollReduce coll-reduce internal-reduce InternalReduce kv-reduce], :type :clj, :sym clojure.core.protocols} {:var-syms [stop-server repl-init start-server start-servers stop-servers repl-read *session* repl], :type :clj, :sym clojure.core.server} {:var-syms [diff equality-partition EqualityPartition diff-similar Diff], :type :clj, :sym clojure.data} {:var-syms [pprint -write read-json read-str read json-str write-str pprint-json JSONWriter write write-json print-json], :type :clj, :sym clojure.data.json} {:var-syms [->PersistentPriorityMap priority-map-by apply-keyfn priority-map-keyfn priority-map-keyfn-by priority-map], :type :clj, :sym clojure.data.priority-map} {:var-syms [read read-string], :type :clj, :sym clojure.edn} {:var-syms [validated read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym clojure.instant} {:var-syms [default-streams-impl make-output-stream make-parents delete-file input-stream make-writer as-relative-path copy as-file output-stream make-reader Coercions file make-input-stream IOFactory resource writer as-url reader], :type :clj, :sym clojure.java.io} {:var-syms [sh *sh-dir* with-sh-dir *sh-env* with-sh-env], :type :clj, :sym clojure.java.shell} {:var-syms [main with-bindings stack-element-str repl-caught repl-exception repl-read load-script skip-if-eol skip-whitespace root-cause repl-requires demunge with-read-known repl repl-prompt], :type :clj, :sym clojure.main} {:var-syms [pprint simple-dispatch get-pretty-writer *print-suppress-namespaces* *print-pretty* *print-pprint-dispatch* pprint-newline code-dispatch print-length-loop pprint-tab pprint-logical-block print-table pp set-pprint-dispatch fresh-line formatter-out formatter pprint-indent *print-radix* cl-format *print-miser-width* write *print-right-margin* write-out with-pprint-dispatch *print-base*], :type :clj, :sym clojure.pprint} {:var-syms [->Field ->Method TypeReference reflect map->Field map->Method typename ->JavaReflector ->AsmReflector resolve-class flag-descriptors do-reflect ClassResolver Reflector ->Constructor map->Constructor type-reflect], :type :clj, :sym clojure.reflect} {:var-syms [source-fn doc stack-element-str find-doc dir pst dir-fn source set-break-handler! root-cause demunge thread-stopper apropos], :type :clj, :sym clojure.repl} {:var-syms [union map-invert join select intersection superset? index subset? rename rename-keys project difference], :type :clj, :sym clojure.set} {:var-syms [form & nilable-impl *recursion-limit* *coll-error-limit* fspec explain-printer Specize every keys* alt-impl def-impl *explain-out* regex-spec-impl merge-spec-impl explain-data* check-asserts assert* inst-in-range? nilable and-spec-impl describe* map-spec-impl coll-of cat * explain with-gen* or-spec-impl *fspec-iterations* Spec unform valid? gen every-kv int-in alt nonconforming unform* abbrev regex? int-in-range? or spec? registry rep+impl exercise-fn exercise multi-spec explain-data tuple-impl multi-spec-impl tuple conform gen* fspec-impl assert ? *coll-check-limit* merge get-spec conformer every-impl spec keys spec-impl + invalid? amp-impl map-of cat-impl explain-str *compile-asserts* with-gen conform* check-asserts? rep-impl double-in inst-in describe explain-out and specize* def maybe-impl explain* fdef], :type :clj, :sym clojure.spec.alpha} {:var-syms [uuid gen-for-pred lazy-prim set one-of any-printable vector-distinct boolean string-alphanumeric map delay simple-type char bind symbol-ns any lazy-prims cat double char-alpha int return gen-for-name symbol quick-check char-alphanumeric choose for-all* string-ascii frequency double* generate delay-impl lazy-combinators tuple string vector large-integer keyword-ns not-empty elements sample list large-integer* keyword hash-map ratio such-that fmap char-ascii simple-type-printable lazy-combinator bytes], :type :clj, :sym clojure.spec.gen.alpha} {:var-syms [print-stack-trace print-trace-element print-cause-trace e root-cause print-throwable], :type :clj, :sym clojure.stacktrace} {:var-syms [ends-with? capitalize reverse join replace-first starts-with? escape last-index-of re-quote-replacement includes? replace split-lines lower-case trim-newline upper-case split trimr index-of trim triml blank?], :type :clj, :sym clojure.string} {:var-syms [macroexpand valid-binding-symbol? analyze-let analyze-map parse-def parse-quote parse-new analyze-fn-method parse-invoke analyze parse-dot parse-do analyze-const parse-loop* analyze-vector var? parse-if -analyze-form create-var parse-try analyze-symbol macroexpand-1 analyze-body parse-letfn* parse-catch analyze-seq parse-recur empty-env analyze-in-env parse-fn* validate-bindings parse-let* parse-throw analyze-set -parse parse wrapping-meta parse-set! specials analyze-form parse-var], :type :clj, :sym clojure.tools.analyzer} {:var-syms [update-children postwalk children walk prewalk children* cycling ast->eav update-children-reduced nodes], :type :clj, :sym clojure.tools.analyzer.ast} {:var-syms [ensure deref-env *env* with-env], :type :clj, :sym clojure.tools.analyzer.env} {:var-syms [analyze-ns parse-case* global-env analyze qualify-arglists parse-reify* analyze+eval analyze-method-impls desugar-symbol create-var run-passes parse-monitor-enter parse-import* build-ns-map macroexpand-1 desugar-host-expr parse-deftype* parse-opts+methods -deftype default-passes empty-env update-ns-map! macroexpand-all scheduled-default-passes parse default-passes-opts parse-monitor-exit specials ->ExceptionThrown], :type :clj, :sym clojure.tools.analyzer.jvm} {:var-syms [unbox static-methods members special-arrays static-field primitive? instance-methods numeric? instance-method static-members wider-tag static-method wider-primitive prim-or-obj ns->relpath try-best-match maybe-class instance-members maybe-class-from-string box array-class ns-url members* subsumes? wider-tag* name-matches? convertible? instance-field prim-interface inline? tag-match? maybe-class-literal specials macro? wider-than object-members], :type :clj, :sym clojure.tools.analyzer.jvm.utils} {:var-syms [schedule-passes satisfies-affected? schedule group compile-passes schedule* calculate-deps desugar-deps maybe-looping-pass collapse], :type :clj, :sym clojure.tools.analyzer.passes} {:var-syms [add-binding-atom], :type :clj, :sym clojure.tools.analyzer.passes.add-binding-atom} {:var-syms [cleanup], :type :clj, :sym clojure.tools.analyzer.passes.cleanup} {:var-syms [constant-lift], :type :clj, :sym clojure.tools.analyzer.passes.constant-lifter} {:var-syms [elides elide-meta replace-meta get-elides -elide-meta], :type :clj, :sym clojure.tools.analyzer.passes.elide-meta} {:var-syms [emit-bindings -emit-form emit-form -emit-form* emit-hygienic-form], :type :clj, :sym clojure.tools.analyzer.passes.emit-form} {:var-syms [-analyze-host-expr analyze-host-expr maybe-static-field maybe-instance-method analyze-host-call maybe-instance-field analyze-host-field maybe-static-method], :type :clj, :sym clojure.tools.analyzer.passes.jvm.analyze-host-expr} {:var-syms [annotate-host-info], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-host-info} {:var-syms [annotate-loops check-recur -check-recur -loops], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-loops} {:var-syms [-annotate-tag annotate-tag], :type :clj, :sym clojure.tools.analyzer.passes.jvm.annotate-tag} {:var-syms [if-let-box boxed? -box box], :type :clj, :sym clojure.tools.analyzer.passes.jvm.box} {:var-syms [classify-invoke], :type :clj, :sym clojure.tools.analyzer.passes.jvm.classify-invoke} {:var-syms [constant-lift constant-lift*], :type :clj, :sym clojure.tools.analyzer.passes.jvm.constant-lifter} {:var-syms [-emit-form emit-form -emit-form* class->str emit-hygienic-form class->sym], :type :clj, :sym clojure.tools.analyzer.passes.jvm.emit-form} {:var-syms [fix-case-test], :type :clj, :sym clojure.tools.analyzer.passes.jvm.fix-case-test} {:var-syms [-infer-tag infer-tag =-arglists?], :type :clj, :sym clojure.tools.analyzer.passes.jvm.infer-tag} {:var-syms [validate-tag validate-call validate validate-interfaces -validate], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate} {:var-syms [find-mismatches dirty -validate-loop-locals validate-loop-locals -validate-loop-locals* -cleanup-dirty-nodes], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate-loop-locals} {:var-syms [validate-recur], :type :clj, :sym clojure.tools.analyzer.passes.jvm.validate-recur} {:var-syms [warn-on-reflection warn], :type :clj, :sym clojure.tools.analyzer.passes.jvm.warn-on-reflection} {:var-syms [-merge-source-info source-info], :type :clj, :sym clojure.tools.analyzer.passes.source-info} {:var-syms [preserving-raw-forms trim -trim], :type :clj, :sym clojure.tools.analyzer.passes.trim} {:var-syms [normalize uniquify-locals* -uniquify-locals *locals-frame* uniquify-binding *locals-counter* uniquify-locals-around uniquify-locals uniquify], :type :clj, :sym clojure.tools.analyzer.passes.uniquify} {:var-syms [warn-earmuff], :type :clj, :sym clojure.tools.analyzer.passes.warn-earmuff} {:var-syms [type? ctx boolean? mapv' rseqv protocol-node? select-keys' -source-info classify reference? update-vals resolve-sym private? constant? regex? dynamic? compile-if into! const-val dissoc-env update-kv record? butlast+last obj? source-info mmerge resolve-ns update-keys arglist-for-arity macro? merge'], :type :clj, :sym clojure.tools.analyzer.utils} {:var-syms [cli parse-opts summarize get-default-options format-lines make-summary-part], :type :clj, :sym clojure.tools.cli} {:var-syms [resolve-deps make-classpath], :type :clj, :sym clojure.tools.deps.alpha} {:var-syms [-main], :type :clj, :sym clojure.tools.deps.alpha.makecp} {:var-syms [manifest-type manifest-types detect-manifest coord-paths coord-type compare-versions dep-id coord-deps], :type :clj, :sym clojure.tools.deps.alpha.providers} {:var-syms [read-deps], :type :clj, :sym clojure.tools.deps.alpha.reader} {:var-syms [map-keys], :type :clj, :sym clojure.tools.deps.alpha.util.coll} {:var-syms [exclusions->data make-session make-local-repo remote-repo default-local-repo dep->data console-listener ->CustomProvider the-system standard-repos coord->artifact], :type :clj, :sym clojure.tools.deps.alpha.util.maven} {:var-syms [immediate-dependencies remove-edge depends? depend immediate-dependents set-conj remove-node ->MapDependencyGraph transitive-dependents-set topo-comparator transitive-dependencies map->MapDependencyGraph DependencyGraph topo-sort transitive-dependents nodes graph DependencyGraphUpdate remove-all dependent? transitive-dependencies-set], :type :clj, :sym clojure.tools.namespace.dependency} {:var-syms [add-files remove-files read-file-ns-decl clojure-file?], :type :clj, :sym clojure.tools.namespace.file} {:var-syms [find-namespaces-in-jarfile find-namespaces-in-dir find-ns-decls-in-jarfile read-ns-decl-from-jarfile-entry find-ns-decls find-clojure-sources-in-dir clojure-sources-in-jar find-namespaces find-ns-decls-in-dir], :type :clj, :sym clojure.tools.namespace.find} {:var-syms [ns-decl? deps-from-ns-decl read-ns-decl comment?], :type :clj, :sym clojure.tools.namespace.parse} {:var-syms [add tracker remove], :type :clj, :sym clojure.tools.namespace.track} {:var-syms [*read-eval* *suppress-read* *default-data-reader-fn* read read-symbol default-data-readers *data-readers* *read-delim* resolve-symbol *alias-map* read-regex syntax-quote read-string map-func], :type :clj, :sym clojure.tools.reader} {:var-syms [default-uuid-reader validated clojure.tools.reader.default_data_readers.proxy$java.lang.ThreadLocal$ff19274a read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym clojure.tools.reader.default-data-readers} {:var-syms [match-number skip-line int-pattern read-comment parse-symbol number-literal? read-past float-pattern throwing-reader ratio-pattern], :type :clj, :sym clojure.tools.reader.impl.commons} {:var-syms [throw-bad-dispatch throw-invalid-unicode-escape throw-bad-ns throw-unknown-reader-tag throw-eof-at-dispatch throw-bad-metadata-target throw-invalid-number reader-error throw-invalid-unicode-literal throw-ns-map-no-map throw-unsupported-character throw-feature-not-keyword throw-eof-delimited throw-eof-in-character throw-bad-char eof-error throw-bad-metadata throw-eof-reading throw-eof-error illegal-arg-error throw-invalid-octal-len throw-invalid-unicode-digit throw-invalid-unicode-digit-in-token throw-invalid-unicode-len throw-single-colon throw-odd-map throw-bad-octal-number throw-bad-reader-tag throw-unmatch-delimiter throw-invalid-character-literal throw-invalid-unicode-char throw-bad-escape-char throw-no-dispatch throw-eof-at-start throw-invalid], :type :clj, :sym clojure.tools.reader.impl.errors} {:var-syms [inspect inspect*], :type :clj, :sym clojure.tools.reader.impl.inspect} {:var-syms [whitespace? char numeric? make-var second' desugar-meta <=clojure-1-7-alpha5 ex-info? newline? namespace-keys compile-when], :type :clj, :sym clojure.tools.reader.impl.utils} {:var-syms [ReaderCoercer indexing-push-back-reader log-source* merge-meta ->StringReader to-pbr to-rdr Reader source-logging-push-back-reader unread peek-char push-back-reader IPushbackReader indexing-reader? string-reader read-char get-column-number get-file-name read-line ->PushbackReader PushbackReaderCoercer string-push-back-reader log-source ->SourceLoggingPushbackReader ->InputStreamReader line-start? input-stream-push-back-reader source-logging-reader? IndexingReader get-line-number input-stream-reader ->IndexingPushbackReader], :type :clj, :sym clojure.tools.reader.reader-types} {:var-syms [postwalk keywordize-keys walk prewalk-replace stringify-keys prewalk postwalk-demo prewalk-demo macroexpand-all postwalk-replace], :type :clj, :sym clojure.walk} {:var-syms [chan <!! put!], :type :clj, :sym dynadoc.aliases} {:var-syms [dynadoc], :type :clj, :sym dynadoc.boot} {:var-syms [var-sym->url spec->html example->html init-editor expandable-section ns-sym->url sidebar var->html page-url export-form export source->html app init-example-editor], :type :clj, :sym dynadoc.common} {:var-syms [print-server handler page-state get-clj-vars dev-start get-cljs-nses-and-vars-dynamically -main get-clj-nses get-examples var-map->vars get-cljs-nses-and-vars start *options public-files get-cljs-vars page export *web-server get-cljs-nses get-clj-var-info], :type :clj, :sym dynadoc.core} {:var-syms [defexample registry-ref parse-example defexamples parse-val parse-ns defexample* parse-keys defexamples*], :type :clj, :sym dynadoc.example} {:var-syms [read-cljs-file visible? get-cljs-arglists get-cljs-nses-and-vars], :type :clj, :sym dynadoc.static} {:var-syms [form->serializable parse-uri flatten-vals cli-options process-example], :type :clj, :sym dynadoc.utils} {:var-syms [*cljs-info watch-request *channel->uri init-watcher!], :type :clj, :sym dynadoc.watch} {:var-syms [when-resolves], :type :clj, :sym dynapath.defaults} {:var-syms [can-read? DynamicClasspath add-classpath-url can-add? base-readable-addable-classpath classpath-urls], :type :clj, :sym dynapath.dynamic-classpath} {:var-syms [all-classpath-urls addable-classpath? add-classpath-url readable-classpath? classpath-urls], :type :clj, :sym dynapath.util} {:var-syms [thunk-timeout uglify-time-unit], :type :clj, :sym eval-soup.clojail} {:var-syms [wrap-security code->results wrap-timeout eval_soup.core.proxy$java.lang.SecurityManager$ff19274a with-security], :type :clj, :sym eval-soup.core} {:var-syms [process-handler process-paths extract-paths-by-type created? watch! stop! deleted? remove-duplicate-paths file? remove-children-paths process-context directory? modified? catch-errors], :type :clj, :sym hawk.core} {:var-syms [standard-watch-event-kinds polling-watcher-impl barbary-watch-event-kinds stop! new-watcher barbary-watcher-impl sensitivity-watch-event-modifiers Watcher java-watcher-impl take! register!], :type :clj, :sym hawk.watcher} {:var-syms [line->segments tag->hiccup line->html code->hiccup split-lines code->html line->hiccup tags-for-line->hiccup tag->html escape-html-str tags-for-line->html structurize-hiccup escape-html-char parse-lines], :type :clj, :sym html-soup.core} {:var-syms [ns-tracker], :type :clj, :sym ns-tracker.core} {:var-syms [dependent seq-union dependencies remove-key depends? depend dependents graph remove-all], :type :clj, :sym ns-tracker.dependency} {:var-syms [deps-from-ns-decl], :type :clj, :sym ns-tracker.nsdeps} {:var-syms [in-ns-decl? read-in-ns-decl], :type :clj, :sym ns-tracker.parse} {:var-syms [*read-eval* *suppress-read* *default-data-reader-fn* read read-symbol default-data-readers *data-readers* *read-delim* resolve-symbol *alias-map* *wrap-value-and-add-metadata?* read-regex syntax-quote read-string map-func], :type :clj, :sym oakclojure.tools.reader} {:var-syms [default-uuid-reader validated oakclojure.tools.reader.default_data_readers.proxy$java.lang.ThreadLocal$ff19274a read-instant-timestamp read-instant-calendar read-instant-date parse-timestamp], :type :clj, :sym oakclojure.tools.reader.default-data-readers} {:var-syms [match-number skip-line int-pattern read-comment parse-symbol number-literal? read-past float-pattern throwing-reader ratio-pattern], :type :clj, :sym oakclojure.tools.reader.impl.commons} {:var-syms [throw-bad-dispatch throw-invalid-unicode-escape throw-bad-ns throw-unknown-reader-tag throw-eof-at-dispatch throw-bad-metadata-target throw-invalid-number reader-error throw-invalid-unicode-literal throw-ns-map-no-map throw-unsupported-character throw-feature-not-keyword throw-eof-delimited throw-eof-in-character throw-bad-char eof-error throw-bad-metadata throw-eof-reading throw-eof-error illegal-arg-error throw-invalid-octal-len throw-invalid-unicode-digit throw-invalid-unicode-digit-in-token throw-invalid-unicode-len throw-single-colon throw-odd-map throw-bad-octal-number throw-bad-reader-tag throw-unmatch-delimiter throw-invalid-character-literal throw-invalid-unicode-char throw-bad-escape-char throw-no-dispatch throw-eof-at-start throw-invalid], :type :clj, :sym oakclojure.tools.reader.impl.errors} {:var-syms [inspect inspect*], :type :clj, :sym oakclojure.tools.reader.impl.inspect} {:var-syms [whitespace? char numeric? make-var second' desugar-meta <=clojure-1-7-alpha5 ex-info? newline? namespace-keys compile-when], :type :clj, :sym oakclojure.tools.reader.impl.utils} {:var-syms [ReaderCoercer indexing-push-back-reader log-source* merge-meta ->StringReader to-pbr to-rdr Reader source-logging-push-back-reader unread peek-char push-back-reader IPushbackReader indexing-reader? string-reader read-char get-column-number get-file-name read-line ->PushbackReader PushbackReaderCoercer string-push-back-reader log-source ->SourceLoggingPushbackReader ->InputStreamReader line-start? input-stream-push-back-reader source-logging-reader? IndexingReader get-line-number input-stream-reader ->IndexingPushbackReader], :type :clj, :sym oakclojure.tools.reader.reader-types} {:var-syms [on-receive accept run-server send! send-websocket-handshake! on-close with-channel Channel close sec-websocket-accept websocket? open?], :type :clj, :sym org.httpkit.server} {:var-syms [:bezier :hsb get-screen :stroke set-size :animation :arc :triangle get-canvas pre-render load-image :fill create-game :rgb get-width :hsl get-asset get-height :div on-show Game Screen start :line get-delta-time on-hide :quad :shape get-pressed-keys :ellipse on-render :curve :image draw-sketch! :point :contour render listen load-tiled-map set-screen :rect get-total-time get-renderer :text], :type :cljs, :sym play-cljs.core} {:var-syms [update-opts check-opts halign->constant valign->constant style->constant basic-defaults text-defaults image-defaults], :type :cljs, :sym play-cljs.options} {:var-syms [wrap-content-type content-type-response], :type :clj, :sym ring.middleware.content-type} {:var-syms [file-request wrap-file], :type :clj, :sym ring.middleware.file} {:var-syms [head-request wrap-head head-response], :type :clj, :sym ring.middleware.head} {:var-syms [keyword-params-request wrap-keyword-params], :type :clj, :sym ring.middleware.keyword-params} {:var-syms [wrap-params params-request assoc-form-params assoc-query-params], :type :clj, :sym ring.middleware.params} {:var-syms [wrap-reload], :type :clj, :sym ring.middleware.reload} {:var-syms [wrap-resource resource-request], :type :clj, :sym ring.middleware.resource} {:var-syms [percent-encode url-decode fix-string-replace-bug form-encode form-decode-str form-decode assoc-conj url-encode FormEncodeable form-encode* base64-decode percent-decode base64-encode], :type :clj, :sym ring.util.codec} {:var-syms [last-modified-date close! piped-input-stream string-input-stream], :type :clj, :sym ring.util.io} {:var-syms [ext-mime-type default-mime-types], :type :clj, :sym ring.util.mime-type} {:var-syms [re-token re-quoted re-charset re-value], :type :clj, :sym ring.util.parsing} {:var-syms [request-url body-string content-length content-type path-info character-encoding urlencoded-form? set-context in-context?], :type :clj, :sym ring.util.request} {:var-syms [get-header redirect redirect-status-codes set-cookie response find-header file-response resource-response get-charset created header charset url-response redirect-after-post update-header resource-data status not-found content-type response?], :type :clj, :sym ring.util.response} {:var-syms [http-date-formats format-date parse-date], :type :clj, :sym ring.util.time} {:var-syms [mount unmount local reactive ref-node react render-static-markup request-render with-key build-defcs ref defc static defcs cursor state cursor-in dom-node with-ref build-defc render-html build-defcc derived-atom defcc], :type :clj, :sym rum.core} {:var-syms [->Cursor], :type :clj, :sym rum.cursor} {:var-syms [derived-atom], :type :clj, :sym rum.derived-atom} {:var-syms [normalize-css-value render-class! render-inner-html! *select-value* render-attrs! render-style-kv! normalize-css-key unitless-css-props render-static-markup to-str normalize-attr-key render-textarea-value! render-content! nothing? normalize-element render-attr! render-classes! append! get-value ToString parse-selector -render-html render-html HtmlRenderer render-element! normalized-attrs escape-html render-style! adler32], :type :clj, :sym rum.server-render} {:var-syms [call-all filter-vals collect collect*], :type :clj, :sym rum.util} {:var-syms [compile-merge-attrs compile-react compile-react-element to-js compile-attr ICompile compile-attrs compile-html IJSValue], :type :clj, :sym sablono.compiler} {:var-syms [map-lookup? attributes compact-map children element match-tag strip-css class class-name merge-with-class], :type :clj, :sym sablono.normalize} {:var-syms [join-classes to-str react-fn camel-case-keys element? *base-url* as-str html-to-dom-attrs ToString ToURI camel-case to-uri], :type :clj, :sym sablono.util} {:var-syms [special-indent code->tags indent-for-line adjust-indent read-safe unwrap-value get-tags-before-line forward-indent-for-line tag-map back-indent-for-line], :type :clj, :sym tag-soup.core}], :cljs-nses-and-vars {play-cljs.options ({:sym update-opts, :meta {:doc nil, :arglists ([opts parent-opts defaults])}, :source "(defn\n update-opts\n [opts parent-opts defaults]\n (let\n  [parent-opts (merge defaults parent-opts)]\n  (->\n   (merge defaults (dissoc parent-opts :x :y) opts)\n   (update :x + (:x parent-opts))\n   (update :y + (:y parent-opts)))))\n"} {:sym check-opts, :meta {:doc nil, :arglists ([spec opts])}, :source "(defn\n check-opts\n [spec opts]\n (when\n  (= :cljs.spec.alpha/invalid (s/conform spec opts))\n  (throw (js/Error. (s/explain-str spec opts)))))\n"} {:sym halign->constant, :meta {:doc nil, :arglists ([renderer halign])}, :source "(defn\n halign->constant\n [renderer halign]\n (get\n  {:left (.-LEFT renderer),\n   :center (.-CENTER renderer),\n   :right (.-RIGHT renderer)}\n  halign))\n"} {:sym valign->constant, :meta {:doc nil, :arglists ([renderer valign])}, :source "(defn\n valign->constant\n [renderer valign]\n (get\n  {:top (.-TOP renderer),\n   :center (.-CENTER renderer),\n   :bottom (.-BOTTOM renderer),\n   :baseline (.-BASELINE renderer)}\n  valign))\n"} {:sym style->constant, :meta {:doc nil, :arglists ([renderer style])}, :source "(defn\n style->constant\n [renderer style]\n (get\n  {:normal (.-NORMAL renderer),\n   :italic (.-ITALIC renderer),\n   :bold (.-BOLD renderer)}\n  style))\n"} {:sym basic-defaults, :meta {}, :source "(def basic-defaults {:x 0, :y 0})\n"} {:sym text-defaults, :meta {}, :source "(def\n text-defaults\n (merge\n  basic-defaults\n  {:size 32,\n   :font \"Helvetica\",\n   :halign :left,\n   :valign :baseline,\n   :leading 0,\n   :style :normal}))\n"} {:sym image-defaults, :meta {}, :source "(def\n image-defaults\n (merge basic-defaults {:scale-x 1, :scale-y 1, :sx 0, :sy 0}))\n"}), play-cljs.core ({:sym :bezier, :examples [{:doc "Draws a cubic Bezier curve on the screen.\n   \n   :x1  -  The x-coordinate of the first anchor point (number)\n   :y1  -  The y-coordinate of the first anchor point (number)\n   :x2  -  The x-coordinate of the first control point (number)\n   :y2  -  The y-coordinate of the first control point (number)\n   :x3  -  The x-coordinate of the second control point (number)\n   :y3  -  The y-coordinate of the second control point (number)\n   :x4  -  The x-coordinate of the second anchor point (number)\n   :y4  -  The y-coordinate of the second anchor point (number)\n   \n   :z1  -  The z-coordinate of the first anchor point (number)\n   :z2  -  The z-coordinate of the first control point (number)\n   :z3  -  The z-coordinate of the second anchor point (number)\n   :z4  -  The z-coordinate of the second control point (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:stroke {:colors [0 0 0]} [:bezier {:x1 85, :y1 20, :x2 10, :y2 10, :x3 90, :y3 90, :x4 15, :y4 80}]]}, :body (do (defonce bezier-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto bezier-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render bezier-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:stroke\n {:colors [0 0 0]}\n [:bezier\n  {:x1 85, :y1 20, :x2 10, :y2 10, :x3 90, :y3 90, :x4 15, :y4 80}]]\n", :id "play-cljs.core/:bezier/0"}]} {:sym :hsb, :examples [{:doc "Causes the color values in all children to be interpreted as HSB colors.\n   \n   :max-h  -  Range for hue (number between 0 and 360)\n   :max-s  -  Range for saturation (number between 0 and 100)\n   :max-b  -  Range for brightness (number between 0 and 100)\n   :max-a  -  Range for alpha (number between 0 and 255)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:hsb {:max-h 90, :max-s 50, :max-b 100} [:fill {:colors [20 50 70]} [:rect {:x 10, :y 10, :width 70, :height 70}]]]}, :body (do (defonce hsb-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto hsb-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render hsb-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:hsb\n {:max-h 90, :max-s 50, :max-b 100}\n [:fill\n  {:colors [20 50 70]}\n  [:rect {:x 10, :y 10, :width 70, :height 70}]]]\n", :id "play-cljs.core/:hsb/0"}]} {:sym get-screen, :meta {:doc "Returns the `Screen` object currently being displayed.", :arglists ([game])}, :protocol Game} {:sym :stroke, :examples [{:doc "Sets the color used to draw lines and borders around the children.\n   \n   :color  -  The name of the color (string)\n   :colors -  The RGB or HSB color values (vector of numbers)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:stroke {:color "green"} [:rect {:x 50, :y 50, :width 70, :height 70}]]}, :body (do (defonce stroke-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto stroke-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render stroke-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:stroke {:color \"green\"} [:rect {:x 50, :y 50, :width 70, :height 70}]]\n", :id "play-cljs.core/:stroke/0"}]} {:sym set-size, :meta {:doc "Sets the virtual width and height of the game.", :arglists ([game width height])}, :protocol Game} {:sym :animation, :examples [{:doc "Draws its children in a continuous loop.\n   \n   :duration  -  The number of milliseconds each child should be displayed (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:animation {:x 10, :y 10, :duration 200} [:image {:name "player_walk1.png", :width 80, :height 80}] [:image {:name "player_walk2.png", :width 80, :height 80}] [:image {:name "player_walk3.png", :width 80, :height 80}]]}, :body (do (defonce animation-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto animation-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render animation-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:animation\n {:x 10, :y 10, :duration 200}\n [:image {:name \"player_walk1.png\", :width 80, :height 80}]\n [:image {:name \"player_walk2.png\", :width 80, :height 80}]\n [:image {:name \"player_walk3.png\", :width 80, :height 80}]]\n", :id "play-cljs.core/:animation/0"}]} {:sym :arc, :examples [{:doc "Draws an arc to the screen.\n   \n   :width  -  The width of the arc (number)\n   :height -  The height of the arc (number)\n   :start  -  Angle to start the arc, in radians (number)\n   :stop   -  Angle to stop the arc, in radians (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:arc {:x 200, :y 0, :width 200, :height 200, :start 0, :stop 3.14}]}, :body (do (defonce arc-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto arc-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render arc-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:arc {:x 200, :y 0, :width 200, :height 200, :start 0, :stop 3.14}]\n", :id "play-cljs.core/:arc/0"}]} {:sym :triangle, :examples [{:doc "A triangle is a plane created by connecting three points.\n   \n   :x1  -  The x-coordinate of the first point (number)\n   :y1  -  The y-coordinate of the first point (number)\n   :x2  -  The x-coordinate of the second point (number)\n   :y2  -  The y-coordinate of the second point (number)\n   :x3  -  The x-coordinate of the third point (number)\n   :y3  -  The y-coordinate of the third point (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:triangle {:x1 10, :y1 10, :x2 50, :y2 25, :x3 10, :y3 35}]}, :body (do (defonce triangle-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto triangle-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render triangle-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:triangle {:x1 10, :y1 10, :x2 50, :y2 25, :x3 10, :y3 35}]\n", :id "play-cljs.core/:triangle/0"}]} {:sym get-canvas, :meta {:doc "Returns the internal canvas object.", :arglists ([game])}, :protocol Game} {:sym pre-render, :meta {:doc "Renders the provided data structure off-screen and associates it with the given name. Returns an `Image` object.", :arglists ([game image-name width height content])}, :protocol Game} {:sym load-image, :meta {:doc "Loads an image. Returns an `Image` object.", :arglists ([game path])}, :protocol Game} {:sym :fill, :examples [{:doc "Sets the color of the children.\n   \n   :color  -  The name of the color (string)\n   :colors -  The RGB or HSB color values (vector of numbers)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:fill {:color "purple"} [:rect {:x 40, :y 40, :width 150, :height 150}]]}, :body (do (defonce fill-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto fill-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render fill-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:fill\n {:color \"purple\"}\n [:rect {:x 40, :y 40, :width 150, :height 150}]]\n", :id "play-cljs.core/:fill/0"}]} {:sym create-game, :meta {:doc "Returns a game object. You can pass an options map with the following:\n  \n  :parent  -  A DOM element in which to place the canvas\n  :debug?  -  Whether or not to enable debug mode\n              (defaults to true if :optimizations are set to :none)", :arglists [[width height] [width height {:keys [parent debug?], :or {debug? (not js/COMPILED)}, :as opts}]]}, :source "(defn\n create-game\n \"Returns a game object. You can pass an options map with the following:\\n  \\n  :parent  -  A DOM element in which to place the canvas\\n  :debug?  -  Whether or not to enable debug mode\\n              (defaults to true if :optimizations are set to :none)\"\n ([width height] (create-game width height {}))\n ([width\n   height\n   {:keys [parent debug?], :or {debug? (not js/COMPILED)}, :as opts}]\n  (if\n   debug?\n   (js/console.log\n    (str\n     \"Debug mode is enabled. If things are slow, try passing \"\n     \"{:debug? false} to the third argument of create-game.\"))\n   (set! (.-disableFriendlyErrors js/p5) true))\n  (let\n   [*hidden-state\n    (atom\n     {:screen nil,\n      :renderer nil,\n      :canvas nil,\n      :listeners [],\n      :total-time 0,\n      :delta-time 0,\n      :pressed-keys #{},\n      :assets {}})\n    setup-finished?\n    (promise-chan)\n    parent-opts\n    (if debug? {:debug? true} {})]\n   (reify\n    Game\n    (start\n     [this]\n     (when-let [renderer (get-renderer this)] (.remove renderer))\n     (run! events/unlistenByKey (:listeners @*hidden-state))\n     (swap! *hidden-state assoc :listeners [])\n     (js/p5.\n      (fn\n       [renderer]\n       (set!\n        (.-setup renderer)\n        (fn\n         []\n         (let\n          [canvas-wrapper\n           (cond->\n            (.createCanvas renderer width height)\n            parent\n            (.parent parent))\n           canvas\n           (.-canvas canvas-wrapper)]\n          (.removeAttribute canvas \"style\")\n          (swap!\n           *hidden-state\n           assoc\n           :renderer\n           renderer\n           :canvas\n           canvas))\n         (put! setup-finished? true)))\n       (set!\n        (.-draw renderer)\n        (fn\n         []\n         (swap!\n          *hidden-state\n          (fn\n           [hidden-state]\n           (let\n            [time (.millis renderer)]\n            (assoc\n             hidden-state\n             :total-time\n             time\n             :delta-time\n             (- time (:total-time hidden-state))))))\n         (.clear renderer)\n         (some-> this get-screen on-render)))))\n     (listen\n      this\n      \"keydown\"\n      (fn\n       [e]\n       (swap! *hidden-state update :pressed-keys conj (.-keyCode e))))\n     (listen\n      this\n      \"keyup\"\n      (fn\n       [e]\n       (if\n        (contains? #{91 93} (.-keyCode e))\n        (swap! *hidden-state assoc :pressed-keys #{})\n        (swap!\n         *hidden-state\n         update\n         :pressed-keys\n         disj\n         (.-keyCode e)))))\n     (listen\n      this\n      \"blur\"\n      (fn* [] (swap! *hidden-state assoc :pressed-keys #{}))))\n    (listen\n     [this listen-type listener]\n     (swap!\n      *hidden-state\n      update\n      :listeners\n      conj\n      (events/listen js/window listen-type listener)))\n    (render\n     [this content]\n     (when-let\n      [renderer (get-renderer this)]\n      (draw-sketch! this renderer content parent-opts)))\n    (pre-render\n     [this image-name width height content]\n     (when-let\n      [renderer (get-renderer this)]\n      (let\n       [object (.createGraphics renderer width height)]\n       (draw-sketch! this object content parent-opts)\n       (swap! *hidden-state update :assets assoc image-name object)\n       object)))\n    (load-image\n     [this path]\n     (when-let\n      [renderer (get-renderer this)]\n      (let\n       [object (.loadImage renderer path (fn []))]\n       (swap! *hidden-state update :assets assoc path object)\n       object)))\n    (load-tiled-map\n     [this map-name]\n     (when-let\n      [renderer (get-renderer this)]\n      (let\n       [object (.loadTiledMap renderer map-name (fn []))]\n       (swap! *hidden-state update :assets assoc map-name object)\n       object)))\n    (get-screen [this] (:screen @*hidden-state))\n    (set-screen\n     [this screen]\n     (go\n      (<! setup-finished?)\n      (some-> this get-screen on-hide)\n      (swap! *hidden-state assoc :screen screen)\n      (on-show screen)))\n    (get-renderer [this] (:renderer @*hidden-state))\n    (get-canvas [this] (:canvas @*hidden-state))\n    (get-total-time [this] (:total-time @*hidden-state))\n    (get-delta-time [this] (:delta-time @*hidden-state))\n    (get-pressed-keys [this] (:pressed-keys @*hidden-state))\n    (get-width\n     [this]\n     (when-let [renderer (get-renderer this)] (.-width renderer)))\n    (get-height\n     [this]\n     (when-let [renderer (get-renderer this)] (.-height renderer)))\n    (set-size\n     [this width height]\n     (when-let\n      [renderer (get-renderer this)]\n      (.resizeCanvas renderer width height)))\n    (get-asset [game name] (get-in @*hidden-state [:assets name]))))))\n"} {:sym :rgb, :examples [{:doc "Causes the color values in all children to be interpreted as RGB colors.\n   \n   :max-r  -  Range for red (number between 0 and 255)\n   :max-g  -  Range for green (number between 0 and 255)\n   :max-b  -  Range for blue (number between 0 and 255)\n   :max-a  -  Range for alpha (number between 0 and 255)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:rgb {:max-r 64, :max-g 64, :max-b 64} [:fill {:colors [20 50 70]} [:rect {:x 10, :y 10, :width 70, :height 70}]]]}, :body (do (defonce rgb-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto rgb-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render rgb-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:rgb\n {:max-r 64, :max-g 64, :max-b 64}\n [:fill\n  {:colors [20 50 70]}\n  [:rect {:x 10, :y 10, :width 70, :height 70}]]]\n", :id "play-cljs.core/:rgb/0"}]} {:sym get-width, :meta {:doc "Returns the virtual width of the game.", :arglists ([game])}, :protocol Game} {:sym :hsl, :examples [{:doc "Causes the color values in all children to be interpreted as HSL colors.\n   \n   :max-h  -  Range for hue (number between 0 and 360)\n   :max-s  -  Range for saturation (number between 0 and 100)\n   :max-l  -  Range for lightness (number between 0 and 100)\n   :max-a  -  Range for alpha (number between 0 and 255)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:hsl {:max-h 90, :max-s 50, :max-l 100} [:fill {:colors [20 50 70]} [:rect {:x 10, :y 10, :width 70, :height 70}]]]}, :body (do (defonce hsl-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto hsl-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render hsl-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:hsl\n {:max-h 90, :max-s 50, :max-l 100}\n [:fill\n  {:colors [20 50 70]}\n  [:rect {:x 10, :y 10, :width 70, :height 70}]]]\n", :id "play-cljs.core/:hsl/0"}]} {:sym get-asset, :meta {:doc "Gets the asset with the given name.", :arglists ([game name])}, :protocol Game} {:sym get-height, :meta {:doc "Returns the virtual height of the game.", :arglists ([game])}, :protocol Game} {:sym :div, :examples [{:doc "Acts as a generic container of options that it passes\ndown to its children. The `x` and `y` are special in this example,\nserving as the pointer's position. Notice that the :rect is\nhard-coded at (0,0) but the :div is passing its own position down.", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:div {:x x, :y y} [:fill {:color "lightblue"} [:rect {:x 0, :y 0, :width 100, :height 100}]]]}, :body (do (defonce div-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto div-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 50, y 50}} (clojure.core/deref *state)] (try (let [content focus] (render div-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:div\n {:x x, :y y}\n [:fill\n  {:color \"lightblue\"}\n  [:rect {:x 0, :y 0, :width 100, :height 100}]]]\n", :id "play-cljs.core/:div/0"}]} {:sym on-show, :meta {:doc "Runs once, when the screen first appears.", :arglists ([screen])}, :protocol Screen} {:sym Game, :meta {:doc "A game object contains the internal renderer object and various bits of state\nthat are important to the overall execution of the game. Every play-cljs game\nshould create just one such object by calling `create-game`."}, :methods (get-asset get-canvas get-delta-time get-height get-pressed-keys get-renderer get-screen get-total-time get-width listen load-image load-tiled-map pre-render render set-screen set-size start)} {:sym Screen, :meta {:doc "A screen object provides the basic lifecycle for a game.\nSimple games may only need to have one screen. They are a useful way to\nisolate different aspects of your game. For example, you could make one\nscreen display the title and menu, and another screen contain the game\nitself.\n\nYou can create a screen by using `reify` like this:\n\n```\n(def main-screen\n  (reify p/Screen\n    (on-show [this])\n    (on-hide [this])\n    (on-render [this])))\n```"}, :methods (on-hide on-render on-show)} {:sym start, :meta {:doc "Creates the canvas element.", :arglists ([game])}, :protocol Game} {:sym :line, :examples [{:doc "Draws a line (a direct path between two points) to the screen.\n   \n   :x1  -  The x-coordinate of the first point (number)\n   :y1  -  The y-coordinate of the first point (number)\n   :x2  -  The x-coordinate of the second point (number)\n   :y2  -  The y-coordinate of the second point (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:line {:x1 0, :y1 0, :x2 50, :y2 50}]}, :body (do (defonce line-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto line-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render line-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:line {:x1 0, :y1 0, :x2 50, :y2 50}]\n", :id "play-cljs.core/:line/0"}]} {:sym get-delta-time, :meta {:doc "Returns the time since the last frame was rendered, in milliseconds.", :arglists ([game])}, :protocol Game} {:sym on-hide, :meta {:doc "Runs once, when the screen is no longer displayed.", :arglists ([screen])}, :protocol Screen} {:sym :quad, :examples [{:doc "Draw a quad. A quad is a quadrilateral, a four sided polygon.\n   \n   :x1  -  The x-coordinate of the first point (number)\n   :y1  -  The y-coordinate of the first point (number)\n   :x2  -  The x-coordinate of the second point (number)\n   :y2  -  The y-coordinate of the second point (number)\n   :x3  -  The x-coordinate of the third point (number)\n   :y3  -  The y-coordinate of the third point (number)\n   :x4  -  The x-coordinate of the fourth point (number)\n   :y4  -  The y-coordinate of the fourth point (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:quad {:x1 50, :y1 55, :x2 70, :y2 15, :x3 10, :y3 15, :x4 20, :y4 55}]}, :body (do (defonce quad-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto quad-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render quad-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:quad {:x1 50, :y1 55, :x2 70, :y2 15, :x3 10, :y3 15, :x4 20, :y4 55}]\n", :id "play-cljs.core/:quad/0"}]} {:sym :shape, :examples [{:doc "Draws a complex shape.\n   \n   :points  -  The x and y vertexes to draw (vector of numbers)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:shape {:points [30 20 85 20 85 75 30 75]}]}, :body (do (defonce shape-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto shape-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render shape-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:shape {:points [30 20 85 20 85 75 30 75]}]\n", :id "play-cljs.core/:shape/0"}]} {:sym get-pressed-keys, :meta {:doc "Returns a set containing the key codes for the keys currently being pressed.", :arglists ([game])}, :protocol Game} {:sym :ellipse, :examples [{:doc "Draws an ellipse (oval) to the screen.\n   \n   :width  -  The width of the ellipse (number)\n   :height -  The height of the ellipse (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:ellipse {:x 100, :y 100, :width 50, :height 70}]}, :body (do (defonce ellipse-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto ellipse-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render ellipse-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:ellipse {:x 100, :y 100, :width 50, :height 70}]\n", :id "play-cljs.core/:ellipse/0"}]} {:sym on-render, :meta {:doc "Runs each time the game is ready to render another frame.", :arglists ([screen])}, :protocol Screen} {:sym :curve, :examples [{:doc "Draws a curved line on the screen between two points,\n   given as the middle four parameters.\n   \n   :x1  -  The x-coordinate of the beginning control point (number)\n   :y1  -  The y-coordinate of the beginning control point (number)\n   :x2  -  The x-coordinate of the first point (number)\n   :y2  -  The y-coordinate of the first point (number)\n   :x3  -  The x-coordinate of the second point (number)\n   :y3  -  The y-coordinate of the second point (number)\n   :x4  -  The x-coordinate of the ending control point (number)\n   :y4  -  The y-coordinate of the ending control point (number)\n   \n   :z1  -  The z-coordinate of the beginning control point (number)\n   :z2  -  The z-coordinate of the first point (number)\n   :z3  -  The z-coordinate of the second point (number)\n   :z4  -  The z-coordinate of the ending control point (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:stroke {:colors [255 102 0]} [:curve {:x1 5, :y1 26, :x2 5, :y2 26, :x3 73, :y3 24, :x4 73, :y4 180}]]}, :body (do (defonce curve-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto curve-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render curve-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:stroke\n {:colors [255 102 0]}\n [:curve\n  {:x1 5, :y1 26, :x2 5, :y2 26, :x3 73, :y3 24, :x4 73, :y4 180}]]\n", :id "play-cljs.core/:curve/0"}]} {:sym :image, :examples [{:doc "Displays an image.\n   \n   :name    -  The file name of the image (string)\n   :width   -  The width of the image (number)\n   :height  -  The height of the image (number)\n   :sx      -  The x-coordinate of the subsection of the source image to draw into the destination rectangle (number)\n   :sy      -  The y-coordinate of the subsection of the source image to draw into the destination rectangle (number)\n   :swidth  -  The width of the subsection of the source image to draw into the destination rectangle (number)\n   :sheight -  The height of the subsection of the source image to draw into the destination rectangle (number)\n   :scale-x -  Percent to scale the image in the x-axis (number)\n   :scale-y -  Percent to scale the image in the y-axis (number)\n   :flip-x  -  Whether to flip the image on its x-axis (boolean)\n   :flip-y  -  Whether to flip the image on its y-axis (boolean)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:image {:name "player_stand.png", :x 0, :y 0, :width 80, :height 80}]}, :body (do (defonce image-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto image-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render image-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:image {:name \"player_stand.png\", :x 0, :y 0, :width 80, :height 80}]\n", :id "play-cljs.core/:image/0"}]} {:sym draw-sketch!, :examples [{:doc "Extending this multimethod allows you to create new entity types.\n   In this example, we create a new entity type called :smiley that draws a smiley face.\n   After defining the method, it can be rendered like this: [:smiley {:x 0 :y 0}]", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr (defmethod play-cljs.core/draw-sketch! :smiley [game renderer content parent-opts] (let [[_ opts & children] content opts (play-cljs.options/update-opts opts parent-opts play-cljs.options/basic-defaults)] (play-cljs.core/draw-sketch! game renderer [:div {:x 100, :y 100} [:fill {:color "yellow"} [:ellipse {:width 100, :height 100} [:fill {:color "black"} [:ellipse {:x -20, :y -10, :width 10, :height 10}] [:ellipse {:x 20, :y -10, :width 10, :height 10}]] [:fill {} [:arc {:width 60, :height 60, :start 0, :stop 3.14}]]]]] opts) (play-cljs.core/draw-sketch! game renderer children opts)))}, :body (do (defonce smiley-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {}) var-obj focus] (doto smiley-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 150, y 150}} (clojure.core/deref *state)] (try (render smiley-game [:smiley {:x 0, :y 0}]) (callback var-obj) (catch js/Error e (callback e)))))))))), :body-str "(defmethod\n play-cljs.core/draw-sketch!\n :smiley\n [game renderer content parent-opts]\n (let\n  [[_ opts & children]\n   content\n   opts\n   (play-cljs.options/update-opts\n    opts\n    parent-opts\n    play-cljs.options/basic-defaults)]\n  (play-cljs.core/draw-sketch!\n   game\n   renderer\n   [:div\n    {:x 100, :y 100}\n    [:fill\n     {:color \"yellow\"}\n     [:ellipse\n      {:width 100, :height 100}\n      [:fill\n       {:color \"black\"}\n       [:ellipse {:x -20, :y -10, :width 10, :height 10}]\n       [:ellipse {:x 20, :y -10, :width 10, :height 10}]]\n      [:fill\n       {}\n       [:arc {:width 60, :height 60, :start 0, :stop 3.14}]]]]]\n   opts)\n  (play-cljs.core/draw-sketch! game renderer children opts)))\n", :id "play-cljs.core/draw-sketch!/0"}]} {:sym :point, :examples [{:doc "Draws a point, a coordinate in space at the dimension of one pixel.", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [[:point {:x 5, :y 5}] [:point {:x 10, :y 5}] [:point {:x 15, :y 5}] [:point {:x 20, :y 5}] [:point {:x 25, :y 5}] [:point {:x 30, :y 5}] [:point {:x 35, :y 5}]]}, :body (do (defonce point-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto point-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render point-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[[:point {:x 5, :y 5}]\n [:point {:x 10, :y 5}]\n [:point {:x 15, :y 5}]\n [:point {:x 20, :y 5}]\n [:point {:x 25, :y 5}]\n [:point {:x 30, :y 5}]\n [:point {:x 35, :y 5}]]\n", :id "play-cljs.core/:point/0"}]} {:sym :contour, :examples [{:doc "Draws a negative shape.\n   \n   :points  -  The x and y vertexes to draw (vector of numbers)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:shape {:points [40 40 80 40 80 80 40 80]} [:contour {:points [20 20 20 40 40 40 40 20]}]]}, :body (do (defonce contour-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto contour-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render contour-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:shape\n {:points [40 40 80 40 80 80 40 80]}\n [:contour {:points [20 20 20 40 40 40 40 20]}]]\n", :id "play-cljs.core/:contour/0"}]} {:sym render, :meta {:doc "Renders the provided data structure.", :arglists ([game content])}, :protocol Game} {:sym listen, :meta {:doc "Adds an event listener.", :arglists ([game listen-type listener])}, :protocol Game} {:sym load-tiled-map, :meta {:doc "Loads a tiled map. Returns a `TiledMap` object.\nA tiled map with the provided name must already be loaded\n(see the TiledMap docs for details).", :arglists ([game map-name])}, :protocol Game} {:sym set-screen, :meta {:doc "Sets the `Screen` object to be displayed.", :arglists ([game screen])}, :protocol Game} {:sym :rect, :examples [{:doc "Draws a rectangle to the screen.\n   A rectangle is a four-sided shape with every angle at ninety degrees.\n   \n   :width  -  The width of the rectangle (number)\n   :height -  The height of the rectangle (number)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:rect {:x 10, :y 15, :width 20, :height 30}]}, :body (do (defonce rect-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto rect-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render rect-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:rect {:x 10, :y 15, :width 20, :height 30}]\n", :id "play-cljs.core/:rect/0"}]} {:sym get-total-time, :meta {:doc "Returns the total time transpired since the game started, in milliseconds.", :arglists ([game])}, :protocol Game} {:sym get-renderer, :meta {:doc "Returns the internal renderer object.", :arglists ([game])}, :protocol Game} {:sym :text, :examples [{:doc "Draws text to the screen.\n   \n   :value  -  The text to display (string)\n   :size   -  The font size (number)\n   :font   -  The name of the font (string)\n   :style  -  The font style (:normal, :italic, :bold)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:text {:value "Hello, world!", :x 0, :y 50, :size 16, :font "Georgia", :style :italic}]}, :body (do (defonce text-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto text-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render text-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:text\n {:value \"Hello, world!\",\n  :x 0,\n  :y 50,\n  :size 16,\n  :font \"Georgia\",\n  :style :italic}]\n", :id "play-cljs.core/:text/0"}]})}, :rel-path "../../", :hide-sidebar? true, :static? true, :check-for-updates? false, :ns-sym play-cljs.core, :vars [{:sym :shape, :examples [{:doc "Draws a complex shape.\n   \n   :points  -  The x and y vertexes to draw (vector of numbers)", :with-card card, :with-callback callback, :with-focus {:binding [:sym focus], :init-expr [:shape {:points [30 20 85 20 85 75 30 75]}]}, :body (do (defonce shape-game (create-game (.-clientWidth card) (.-clientHeight card) {:parent card, :debug? true})) (let [*state (atom {})] (doto shape-game (start-example-game card *state) (set-screen (reify Screen (on-show [this]) (on-hide [this]) (on-render [this] (let [{:keys [x y], :or {x 0, y 0}} (clojure.core/deref *state)] (try (let [content focus] (render shape-game content) (callback content)) (catch js/Error e (callback e)))))))))), :body-str "[:shape {:points [30 20 85 20 85 75 30 75]}]\n", :id "play-cljs.core/:shape/0"}]}]}</script>
        <script type="text/javascript" src="../../main.js"></script>
    </body>
</html>
